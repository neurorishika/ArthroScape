{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to ArthroScape","text":"<p>ArthroScape is a comprehensive simulation package for arthropod behavior, developed by Rishika Mohanta.</p> <p>This documentation provides a detailed guide to the package, including installation instructions, usage examples, and a complete API reference.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multi-Animal Simulation: Simulate complex interactions between multiple agents.</li> <li>Odor Plume Dynamics: Realistic odor release and diffusion models.</li> <li>Sensory Perception: Configurable odor perception models including adaptation and noise.</li> <li>Behavioral Algorithms: Customizable behavioral strategies for agents.</li> <li>Visualization: Tools for visualizing simulation results and trajectories.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If you are new to ArthroScape, start with the Installation guide, then check out the Usage section to run your first simulation.</p>"},{"location":"#project-status","title":"Project Status","text":"<ul> <li>Latest Build Date: 2025-03-07</li> <li>Version: 0.1.0</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the LICENSE file included in the repository.</p>"},{"location":"architecture/","title":"Architecture &amp; Internals","text":"<p>This document explains the internal design of ArthroScape. It is intended as a reference for developers and coding agents who need to understand the flow of information and code organization.</p>"},{"location":"architecture/#high-level-overview","title":"High-Level Overview","text":"<p>ArthroScape is a vectorized, agent-based simulation framework. It models the interaction between agents (e.g., flies) and a dynamic environment (arena with odor).</p> <p>Key design principles:</p> <ol> <li>Separation of Concerns: Physics (<code>Arena</code>), Decision Making (<code>Behavior</code>), and State Management (<code>Simulator</code>) are decoupled.</li> <li>Vectorization: To support efficient simulation of many agents, core loops use NumPy arrays and Numba JIT compilation instead of iterating over agent objects.</li> <li>Configuration-Driven: A single <code>SimulationConfig</code> object controls almost all aspects of the simulation.</li> </ol>"},{"location":"architecture/#code-organization","title":"Code Organization","text":"<p>The core logic resides in <code>arthroscape/sim/</code>.</p> Module Role Key Classes/Functions <code>config.py</code> Configuration. Defines the schema for simulation parameters. <code>SimulationConfig</code> <code>simulator.py</code> State Management. Holds the state of agents and orchestrates the simulation loop. <code>MultiAnimalSimulator</code> <code>arena.py</code> Environment. Manages spatial boundaries, obstacles, and the odor grid. Handles coordinate transforms. <code>Arena</code>, <code>GridArena</code>, <code>PeriodicSquareArena</code> <code>behavior.py</code> Decision Making. Determines how agents update their state and heading based on inputs. <code>BehaviorAlgorithm</code>, <code>DefaultBehavior</code> <code>odor_perception.py</code> Sensing. Models the processing of raw odor signals (filtering, adaptation). <code>AgentOdorPerception</code>, <code>LowPassPerception</code> <code>odor_release.py</code> Stimulus Generation. Controls how odor is added to the environment (by agents or static sources). <code>OdorReleaseStrategy</code>, <code>ConstantOdorRelease</code> <code>runner.py</code> Execution. High-level functions to run simulations (serial or parallel). <code>run_simulations_vectorized</code> <code>visualization.py</code> Analysis. Plotting and animation tools. <code>VisualizationPipeline</code>"},{"location":"architecture/#the-simulation-loop","title":"The Simulation Loop","text":"<p>The simulation proceeds in discrete time steps. The <code>MultiAnimalSimulator.step()</code> method is the heartbeat of the system.</p>"},{"location":"architecture/#1-initialization","title":"1. Initialization","text":"<ul> <li>Config: A <code>SimulationConfig</code> is created.</li> <li>Arena: The <code>Arena</code> is initialized (grid size, walls).</li> <li>Agents: Initial positions and headings are sampled. Arrays for <code>x</code>, <code>y</code>, <code>heading</code>, <code>state</code> are allocated.</li> </ul>"},{"location":"architecture/#2-update-cycle-per-frame","title":"2. Update Cycle (Per Frame)","text":"<p>In each frame, the following sequence occurs:</p>"},{"location":"architecture/#a-odor-dynamics","title":"A. Odor Dynamics","text":"<ol> <li>Release: The <code>OdorReleaseStrategy</code> calculates where odor should be deposited (e.g., at current agent positions).</li> <li>Deposition: The <code>Arena</code> updates the odor grid with these deposits.</li> <li>Physics: The <code>Arena</code> applies diffusion and decay to the odor grid.</li> </ol>"},{"location":"architecture/#b-sensory-input","title":"B. Sensory Input","text":"<ol> <li>Sensing: Agents query the <code>Arena</code> to get odor concentrations at their left and right antennae positions.</li> <li>Perception: The <code>AgentOdorPerception</code> module processes these raw values (e.g., applying a low-pass filter or adaptation logic) to produce the \"perceived\" odor.</li> </ol>"},{"location":"architecture/#c-behavioral-decision","title":"C. Behavioral Decision","text":"<ol> <li>State Update: The <code>BehaviorAlgorithm</code> decides if the agent should transition between <code>STOP</code> (0) and <code>WALK</code> (1) states.</li> <li>Heading Update: The algorithm calculates a new heading based on the perceived odor gradient, wind (if any), and random noise.</li> <li>Persistence: If a <code>DirectionalPersistenceStrategy</code> is active, the new heading is blended with the previous heading to simulate inertia.</li> </ol>"},{"location":"architecture/#d-kinematics-physics","title":"D. Kinematics &amp; Physics","text":"<ol> <li>Movement: Agents update their positions (<code>x</code>, <code>y</code>) based on their current state (walking/stopped), speed, and heading.</li> <li>Boundary Handling: The <code>Arena</code> checks for collisions.<ul> <li>Walls: Agents slide along walls or stop.</li> <li>Periodic Boundaries: Agents wrap around to the other side.</li> </ul> </li> </ol>"},{"location":"architecture/#3-data-recording","title":"3. Data Recording","text":"<p>At the end of the simulation, data is aggregated into a dictionary of NumPy arrays (time x animals) and saved to HDF5.</p>"},{"location":"architecture/#vectorization-strategy","title":"Vectorization Strategy","text":"<p>ArthroScape is optimized for speed using Numba.</p> <ul> <li>Data Structure: Instead of a list of <code>Agent</code> objects, the simulator maintains structure-of-arrays (SoA): <code>self.x</code>, <code>self.y</code>, <code>self.headings</code> are all 1D NumPy arrays of size <code>N</code> (number of animals).</li> <li>JIT Compilation: Computationally intensive functions in <code>arena.py</code> (like <code>deposit_odor_kernels_vectorized_numba</code> or <code>get_odor_vectorized_numba</code>) are compiled with <code>@njit</code>.</li> <li>Batch Operations: The <code>BehaviorAlgorithm</code> and <code>Arena</code> methods are designed to accept and return arrays, processing all agents in a single call.</li> </ul>"},{"location":"architecture/#extending-the-system","title":"Extending the System","text":"<ul> <li>New Behaviors: Inherit from <code>BehaviorAlgorithm</code> and implement <code>update_state</code> and <code>update_heading</code>.</li> <li>New Arenas: Inherit from <code>GridArena</code> and define your own <code>wall_mask</code> or boundary logic.</li> <li>New Sensors: Inherit from <code>AgentOdorPerception</code> to implement complex sensory processing models.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>ArthroScape uses Poetry for dependency management. This ensures a reproducible environment without polluting your system python.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: Version &gt;= 3.10 and &lt; 3.13</li> <li>Poetry: Installation Instructions</li> <li>Git: For version control.</li> </ul>"},{"location":"installation/#steps","title":"Steps","text":"<ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/neurorishika/ArthroScape.git\ncd ArthroScape\n</code></pre> </li> <li> <p>Install dependencies:</p> <p>Run the following command in the project root to install all required packages into a virtual environment managed by Poetry.</p> <pre><code>poetry install\n</code></pre> <p>This will read <code>pyproject.toml</code> and <code>poetry.lock</code> to install the exact versions of dependencies.</p> </li> <li> <p>Verify Installation:</p> <p>You can verify the installation by running the tests (if available) or checking the package version.</p> <pre><code>poetry run python -c \"import arthroscape; print(arthroscape.__file__)\"\n</code></pre> </li> </ol>"},{"location":"installation/#vs-code-setup","title":"VS Code Setup","text":"<p>If you use VS Code:</p> <ol> <li>Open the project folder in VS Code.</li> <li>When opening a Python file, select the Python interpreter.</li> <li>Choose the interpreter associated with the Poetry virtual environment (usually located in <code>.venv</code> or a path managed by Poetry).</li> </ol>"},{"location":"installation/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>To use the project's environment in Jupyter Notebooks:</p> <pre><code>poetry run jupyter notebook\n</code></pre> <p>This ensures that the kernel has access to the <code>arthroscape</code> package and all its dependencies.</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>ArthroScape can be used in two primary ways:</p> <ol> <li>Command Line Interface (CLI): For quick simulations using standard arenas and parameters.</li> <li>Python API: For full control over configuration, custom behaviors, and complex experiments.</li> </ol>"},{"location":"usage/#command-line-interface-cli","title":"Command Line Interface (CLI)","text":"<p>The easiest way to run simulations is using the provided script <code>scripts/run_simulation.py</code>.</p>"},{"location":"usage/#basic-syntax","title":"Basic Syntax","text":"<pre><code>poetry run python scripts/run_simulation.py [OPTIONS]\n</code></pre>"},{"location":"usage/#common-options","title":"Common Options","text":"Option Description Default <code>--arena</code> Arena type (<code>circular</code>, <code>pbc</code>, <code>pbc-line</code>) <code>circular</code> <code>--animals</code> Number of animals per replicate <code>1</code> <code>--replicates</code> Number of independent simulations to run <code>1</code> <code>--odor_release</code> Odor strategy (<code>constant</code>, <code>conditional</code>, <code>none</code>) <code>constant</code> <code>--visualize</code> Generate plots and animations after simulation <code>False</code> <code>--parallel</code> Run replicates in parallel <code>False</code> <code>--save</code> Custom path for the output <code>.h5</code> file Auto-generated"},{"location":"usage/#external-odor-source-options","title":"External Odor Source Options","text":"Option Description Default <code>--odor_image</code> Path to an image file to use as static odor landscape None <code>--odor_video</code> Path to a video file to use as dynamic odor field None <code>--odor_scale</code> Scaling factor for external odor values <code>1.0</code> <code>--odor_invert</code> Invert the odor source (dark = high concentration) <code>False</code> <code>--odor_mode</code> How to apply odor (<code>replace</code>, <code>add</code>, <code>multiply</code>, <code>max</code>) <code>replace</code> <code>--video_loop</code> Loop the video when it ends <code>False</code> <code>--video_sync</code> Video sync mode (<code>one_to_one</code>, <code>video_fps</code>, <code>simulation_fps</code>) <code>simulation_fps</code>"},{"location":"usage/#examples","title":"Examples","text":""},{"location":"usage/#1-circular-arena-with-5-animals","title":"1. Circular Arena with 5 Animals","text":"<p>Run a simulation in a circular arena with 5 animals, and visualize the results.</p> <pre><code>poetry run python scripts/run_simulation.py --arena circular --animals 5 --visualize\n</code></pre>"},{"location":"usage/#2-periodic-boundary-conditions-pbc","title":"2. Periodic Boundary Conditions (PBC)","text":"<p>Run a simulation in a square arena with periodic boundaries (toroidal), with 10 animals and no odor release.</p> <pre><code>poetry run python scripts/run_simulation.py --arena pbc --animals 10 --odor_release none --visualize\n</code></pre>"},{"location":"usage/#3-high-throughput-parallel-simulation","title":"3. High-Throughput Parallel Simulation","text":"<p>Run 20 replicates of a single-animal simulation in parallel, without visualization (faster).</p> <pre><code>poetry run python scripts/run_simulation.py --arena pbc --animals 1 --replicates 20 --parallel\n</code></pre>"},{"location":"usage/#4-using-an-image-as-odor-landscape","title":"4. Using an Image as Odor Landscape","text":"<p>Load a grayscale image as the odor map. Brighter pixels = higher concentration.</p> <pre><code>poetry run python scripts/run_simulation.py --arena pbc --animals 5 \\\n    --odor_image path/to/odor_map.png --odor_scale 10.0 --visualize\n</code></pre>"},{"location":"usage/#5-inverting-an-image-dark-high-odor","title":"5. Inverting an Image (Dark = High Odor)","text":"<p>If your image has dark regions representing high odor concentration, use <code>--odor_invert</code>.</p> <pre><code>poetry run python scripts/run_simulation.py --arena pbc --animals 5 \\\n    --odor_image path/to/dark_plume.png --odor_invert --odor_scale 5.0\n</code></pre>"},{"location":"usage/#6-combining-image-odor-with-agent-pheromone","title":"6. Combining Image Odor with Agent Pheromone","text":"<p>Add an image-based background odor while agents also release pheromone.</p> <pre><code>poetry run python scripts/run_simulation.py --arena pbc --animals 10 \\\n    --odor_image food_source.png --odor_mode add --odor_scale 2.0 \\\n    --odor_release constant --deposit_amount 0.1 --visualize\n</code></pre>"},{"location":"usage/#7-using-a-video-as-dynamic-odor-field","title":"7. Using a Video as Dynamic Odor Field","text":"<p>Load a video where each frame represents the odor landscape at that time step.</p> <pre><code>poetry run python scripts/run_simulation.py --arena pbc --animals 5 \\\n    --odor_video plume_recording.mp4 --odor_scale 3.0 --video_loop --visualize\n</code></pre> <p>Video Odor Source Limitation</p> <p>The standard CLI runner applies only the first frame of the video as the initial odor state. For true per-frame video updates, use a custom simulation loop with the Python API. See the External Odor Sources How-To Guide for details.</p>"},{"location":"usage/#graphical-analysis-tool","title":"Graphical Analysis Tool","text":"<p>ArthroScape includes a graphical user interface (GUI) for analyzing simulation results.</p>"},{"location":"usage/#launching-the-ui","title":"Launching the UI","text":"<pre><code>poetry run python scripts/analysis_ui.py\n</code></pre>"},{"location":"usage/#features","title":"Features","text":"<ul> <li>Load Data: Select an HDF5 results file (<code>.h5</code>) generated by a simulation.</li> <li>Output Folder: Choose where to save the analysis plots.</li> <li>Analysis Options:</li> <li>Trajectories Plot: Visualizes agent paths overlaid on the odor landscape.</li> <li>Odor Grid: Shows the final state of the odor concentration field.</li> <li>Odor Time Series: Plots the odor concentration experienced by agents over time.</li> <li>Animation Video: Generates an MP4 video of the simulation.</li> <li>Wraparound: Enable this for PBC arenas to correctly visualize trajectories crossing boundaries.</li> </ul>"},{"location":"usage/#advanced-configuration-python-api","title":"Advanced Configuration (Python API)","text":"<p>For advanced use cases, you should configure the simulation using a Python script. This allows you to modify parameters not exposed in the CLI.</p>"},{"location":"usage/#setting-up-a-configuration","title":"Setting up a Configuration","text":"<p>The <code>SimulationConfig</code> class in <code>arthroscape.sim.config</code> holds all simulation parameters. You can instantiate this class with custom values.</p> <pre><code>from arthroscape.sim.config import SimulationConfig\nfrom arthroscape.sim.main import run_simulations_vectorized\n# ... import other components ...\n\n# 1. Create a custom configuration\nconfig = SimulationConfig(\n    T=300.0,                # Duration in seconds\n    fps=60.0,               # Frames per second\n    walking_speed=20.0,     # mm/s\n    turn_rate=1.5,          # Hz\n    grid_resolution=0.5,    # mm per cell\n    # ... other parameters ...\n)\n\n# 2. Run simulation with this config\n# (See 'Tutorials &gt; Getting Started' for full script example)\n</code></pre>"},{"location":"usage/#key-configuration-parameters","title":"Key Configuration Parameters","text":"<ul> <li><code>T</code>: Total simulation time (seconds).</li> <li><code>walking_speed</code>: Agent speed (mm/s).</li> <li><code>turn_rate</code>: Frequency of turns (Hz).</li> <li><code>asymmetry_factor</code>: Strength of turning bias due to odor gradients.</li> <li><code>odor_decay_tau</code>: Time constant for odor decay (set to <code>np.inf</code> for no decay).</li> <li><code>diffusion_coefficient</code>: Rate of odor diffusion.</li> </ul> <p>See the Config API Reference for the full list of parameters.</p>"},{"location":"usage/#modifying-defaults","title":"Modifying Defaults","text":"<p>If you want to change the default parameters used by the CLI (e.g., <code>scripts/run_simulation.py</code>), you can modify the default values in <code>arthroscape/sim/config.py</code> directly. Note that this will affect all simulations that rely on the default configuration.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the technical reference for the ArthroScape package.</p>"},{"location":"api/#modules","title":"Modules","text":"<ul> <li>Simulation: Core simulation components.</li> </ul>"},{"location":"api/sim/arena/","title":"Arena","text":""},{"location":"api/sim/arena/#arthroscape.sim.arena","title":"<code>arthroscape.sim.arena</code>","text":"<p>Arena module for the ArthroScape simulation.</p> <p>This module defines the <code>Arena</code> abstract base class and its concrete implementation <code>GridArena</code>. The arena manages the spatial environment, including the odor field (concentration grid) and obstacles (walls). It handles coordinate conversions between world space (continuous) and grid space (discrete), as well as odor diffusion and decay dynamics.</p>"},{"location":"api/sim/arena/#arthroscape.sim.arena.Arena","title":"<code>Arena</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for the simulation arena.</p> <p>The Arena defines the interface for querying odor concentrations, checking for obstacles, and updating the odor field.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>class Arena(ABC):\n    \"\"\"\n    Abstract base class for the simulation arena.\n\n    The Arena defines the interface for querying odor concentrations, checking for obstacles,\n    and updating the odor field.\n    \"\"\"\n\n    @abstractmethod\n    def get_odor(self, x: float, y: float) -&gt; float:\n        \"\"\"\n        Return the odor concentration at a specific location.\n\n        Args:\n            x (float): The x-coordinate in world units (mm).\n            y (float): The y-coordinate in world units (mm).\n\n        Returns:\n            float: The odor concentration at (x, y).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_free(self, x: float, y: float) -&gt; bool:\n        \"\"\"\n        Check if a location is free of obstacles.\n\n        Args:\n            x (float): The x-coordinate in world units (mm).\n            y (float): The y-coordinate in world units (mm).\n\n        Returns:\n            bool: True if the location is free, False if it is blocked (e.g., by a wall).\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_odor(self, x: float, y: float, odor: float) -&gt; None:\n        \"\"\"\n        Deposit odor at a specific location.\n\n        This method adds odor to the environment, typically used when an agent releases odor.\n\n        Args:\n            x (float): The x-coordinate in world units (mm).\n            y (float): The y-coordinate in world units (mm).\n            odor (float): The amount of odor to deposit.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_odor_field(\n        self, dt: float = 1.0, method: str = \"gaussian_filter\"\n    ) -&gt; None:\n        \"\"\"\n        Update the odor field dynamics (diffusion and decay).\n\n        Args:\n            dt (float): Time step for the update. Default is 1.0.\n            method (str): The method to use for diffusion ('gaussian_filter', 'fftconvolve', etc.).\n                          Default is 'gaussian_filter'.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.Arena.get_odor","title":"<code>get_odor(x, y)</code>  <code>abstractmethod</code>","text":"<p>Return the odor concentration at a specific location.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate in world units (mm).</p> required <code>y</code> <code>float</code> <p>The y-coordinate in world units (mm).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The odor concentration at (x, y).</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@abstractmethod\ndef get_odor(self, x: float, y: float) -&gt; float:\n    \"\"\"\n    Return the odor concentration at a specific location.\n\n    Args:\n        x (float): The x-coordinate in world units (mm).\n        y (float): The y-coordinate in world units (mm).\n\n    Returns:\n        float: The odor concentration at (x, y).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.Arena.is_free","title":"<code>is_free(x, y)</code>  <code>abstractmethod</code>","text":"<p>Check if a location is free of obstacles.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate in world units (mm).</p> required <code>y</code> <code>float</code> <p>The y-coordinate in world units (mm).</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the location is free, False if it is blocked (e.g., by a wall).</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@abstractmethod\ndef is_free(self, x: float, y: float) -&gt; bool:\n    \"\"\"\n    Check if a location is free of obstacles.\n\n    Args:\n        x (float): The x-coordinate in world units (mm).\n        y (float): The y-coordinate in world units (mm).\n\n    Returns:\n        bool: True if the location is free, False if it is blocked (e.g., by a wall).\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.Arena.update_odor","title":"<code>update_odor(x, y, odor)</code>  <code>abstractmethod</code>","text":"<p>Deposit odor at a specific location.</p> <p>This method adds odor to the environment, typically used when an agent releases odor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate in world units (mm).</p> required <code>y</code> <code>float</code> <p>The y-coordinate in world units (mm).</p> required <code>odor</code> <code>float</code> <p>The amount of odor to deposit.</p> required Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@abstractmethod\ndef update_odor(self, x: float, y: float, odor: float) -&gt; None:\n    \"\"\"\n    Deposit odor at a specific location.\n\n    This method adds odor to the environment, typically used when an agent releases odor.\n\n    Args:\n        x (float): The x-coordinate in world units (mm).\n        y (float): The y-coordinate in world units (mm).\n        odor (float): The amount of odor to deposit.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.Arena.update_odor_field","title":"<code>update_odor_field(dt=1.0, method='gaussian_filter')</code>  <code>abstractmethod</code>","text":"<p>Update the odor field dynamics (diffusion and decay).</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Time step for the update. Default is 1.0.</p> <code>1.0</code> <code>method</code> <code>str</code> <p>The method to use for diffusion ('gaussian_filter', 'fftconvolve', etc.).           Default is 'gaussian_filter'.</p> <code>'gaussian_filter'</code> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@abstractmethod\ndef update_odor_field(\n    self, dt: float = 1.0, method: str = \"gaussian_filter\"\n) -&gt; None:\n    \"\"\"\n    Update the odor field dynamics (diffusion and decay).\n\n    Args:\n        dt (float): Time step for the update. Default is 1.0.\n        method (str): The method to use for diffusion ('gaussian_filter', 'fftconvolve', etc.).\n                      Default is 'gaussian_filter'.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena","title":"<code>GridArena</code>","text":"<p>               Bases: <code>Arena</code></p> <p>A concrete implementation of Arena using a 2D grid.</p> <p>The GridArena discretizes the world into a grid of cells. It supports odor diffusion, decay, and wall obstacles defined by a mask.</p> <p>Attributes:</p> Name Type Description <code>x_min</code> <code>float</code> <p>Minimum x-coordinate of the arena.</p> <code>x_max</code> <code>float</code> <p>Maximum x-coordinate of the arena.</p> <code>y_min</code> <code>float</code> <p>Minimum y-coordinate of the arena.</p> <code>y_max</code> <code>float</code> <p>Maximum y-coordinate of the arena.</p> <code>resolution</code> <code>float</code> <p>Size of each grid cell in world units (mm).</p> <code>nx</code> <code>int</code> <p>Number of grid cells in the x-direction.</p> <code>ny</code> <code>int</code> <p>Number of grid cells in the y-direction.</p> <code>odor_grid</code> <code>ndarray</code> <p>2D array storing odor concentrations.</p> <code>wall_mask</code> <code>ndarray</code> <p>2D boolean array where True indicates a wall/obstacle.</p> <code>diffusion_coefficient</code> <code>float</code> <p>Diffusion coefficient for odor dynamics.</p> <code>odor_decay_rate</code> <code>float</code> <p>Rate at which odor decays per time step.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>class GridArena(Arena):\n    \"\"\"\n    A concrete implementation of Arena using a 2D grid.\n\n    The GridArena discretizes the world into a grid of cells. It supports odor diffusion,\n    decay, and wall obstacles defined by a mask.\n\n    Attributes:\n        x_min (float): Minimum x-coordinate of the arena.\n        x_max (float): Maximum x-coordinate of the arena.\n        y_min (float): Minimum y-coordinate of the arena.\n        y_max (float): Maximum y-coordinate of the arena.\n        resolution (float): Size of each grid cell in world units (mm).\n        nx (int): Number of grid cells in the x-direction.\n        ny (int): Number of grid cells in the y-direction.\n        odor_grid (np.ndarray): 2D array storing odor concentrations.\n        wall_mask (np.ndarray): 2D boolean array where True indicates a wall/obstacle.\n        diffusion_coefficient (float): Diffusion coefficient for odor dynamics.\n        odor_decay_rate (float): Rate at which odor decays per time step.\n    \"\"\"\n\n    def __init__(\n        self,\n        x_min: float,\n        x_max: float,\n        y_min: float,\n        y_max: float,\n        resolution: float,\n        wall_mask: Optional[np.ndarray] = None,\n        config: Optional[SimulationConfig] = None,\n    ):\n        \"\"\"\n        Initialize the GridArena.\n\n        Args:\n            x_min (float): Minimum x-coordinate.\n            x_max (float): Maximum x-coordinate.\n            y_min (float): Minimum y-coordinate.\n            y_max (float): Maximum y-coordinate.\n            resolution (float): Grid resolution (mm/cell).\n            wall_mask (Optional[np.ndarray]): Boolean mask for walls. If None, no walls are present.\n            config (Optional[SimulationConfig]): Simulation configuration object to pull parameters from.\n        \"\"\"\n        self.x_min = x_min\n        self.x_max = x_max\n        self.y_min = y_min\n        self.y_max = y_max\n        self.resolution = resolution\n        self.nx = int(np.ceil((x_max - x_min) / resolution)) + 1\n        self.ny = int(np.ceil((y_max - y_min) / resolution)) + 1\n        self.odor_grid = np.zeros((self.ny, self.nx))\n        if wall_mask is None:\n            self.wall_mask = np.zeros((self.ny, self.nx), dtype=bool)\n        else:\n            if wall_mask.shape != (self.ny, self.nx):\n                raise ValueError(\"Wall mask dimensions do not match grid.\")\n            self.wall_mask = wall_mask\n        if config is not None:\n            self.diffusion_coefficient = config.diffusion_coefficient\n            self.odor_decay_rate = config.odor_decay_rate\n        else:\n            self.diffusion_coefficient = 0.1\n            self.odor_decay_rate = 0.001\n\n    def _world_to_grid(self, x: float, y: float) -&gt; Tuple[int, int, float, float]:\n        \"\"\"\n        Convert world coordinates to grid indices and fractional offsets.\n\n        Args:\n            x (float): World x-coordinate.\n            y (float): World y-coordinate.\n\n        Returns:\n            Tuple[int, int, float, float]: (i, j, fi, fj) where:\n                i (int): Grid row index.\n                j (int): Grid column index.\n                fi (float): Fractional offset in x (0 to 1).\n                fj (float): Fractional offset in y (0 to 1).\n        \"\"\"\n        gx = (x - self.x_min) / self.resolution\n        gy = (y - self.y_min) / self.resolution\n        j = int(np.floor(gx))\n        i = int(np.floor(gy))\n        fi = gx - j\n        fj = gy - i\n        return i, j, fi, fj\n\n    def world_to_grid_vectorized(\n        self, x: np.ndarray, y: np.ndarray\n    ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Convert arrays of world coordinates to grid indices and fractional parts.\n\n        Args:\n            x (np.ndarray): NumPy array of x coordinates.\n            y (np.ndarray): NumPy array of y coordinates.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: A tuple (i, j, fi, fj) where:\n                i (np.ndarray): Integer grid row indices.\n                j (np.ndarray): Integer grid column indices.\n                fi (np.ndarray): Fractional parts in x.\n                fj (np.ndarray): Fractional parts in y.\n        \"\"\"\n        return world_to_grid_vectorized_numba(\n            x, y, self.x_min, self.y_min, self.resolution, self.nx, self.ny\n        )\n\n    def get_odor(self, x: float, y: float) -&gt; float:\n        \"\"\"\n        Get the odor concentration at a specific world location using bilinear interpolation.\n\n        Args:\n            x (float): World x-coordinate.\n            y (float): World y-coordinate.\n\n        Returns:\n            float: Interpolated odor concentration. Returns 0.0 if outside the arena.\n        \"\"\"\n        if x &lt; self.x_min or x &gt; self.x_max or y &lt; self.y_min or y &gt; self.y_max:\n            return 0.0\n        i, j, fi, fj = self._world_to_grid(x, y)\n        i1 = min(i, self.ny - 2)\n        j1 = min(j, self.nx - 2)\n        Q11 = self.odor_grid[i1, j1]\n        Q21 = self.odor_grid[i1, j1 + 1]\n        Q12 = self.odor_grid[i1 + 1, j1]\n        Q22 = self.odor_grid[i1 + 1, j1 + 1]\n        return (\n            Q11 * (1 - fi) * (1 - fj)\n            + Q21 * fi * (1 - fj)\n            + Q12 * (1 - fi) * fj\n            + Q22 * fi * fj\n        )\n\n    def get_odor_vectorized(self, xs: np.ndarray, ys: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Vectorized version of get_odor using bilinear interpolation.\n\n        Args:\n            xs (np.ndarray): NumPy array of x coordinates.\n            ys (np.ndarray): NumPy array of y coordinates.\n\n        Returns:\n            np.ndarray: Array of odor concentrations corresponding to the input coordinates.\n        \"\"\"\n        return get_odor_vectorized_numba(\n            xs,\n            ys,\n            self.odor_grid,\n            self.x_min,\n            self.y_min,\n            self.resolution,\n            self.nx,\n            self.ny,\n        )\n\n    def is_free(self, x: float, y: float) -&gt; bool:\n        if x &lt; self.x_min or x &gt; self.x_max or y &lt; self.y_min or y &gt; self.y_max:\n            return False\n        i, j, _, _ = self._world_to_grid(x, y)\n        i = np.clip(i, 0, self.ny - 1)\n        j = np.clip(j, 0, self.nx - 1)\n        return not self.wall_mask[i, j]\n\n    def is_free_vectorized(self, xs: np.ndarray, ys: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Vectorized check if locations are free of obstacles.\n\n        Args:\n            xs (np.ndarray): NumPy array of x coordinates.\n            ys (np.ndarray): NumPy array of y coordinates.\n\n        Returns:\n            np.ndarray: Boolean NumPy array indicating free (True) or blocked (False) for each coordinate.\n        \"\"\"\n        return is_free_vectorized_numba(\n            xs,\n            ys,\n            self.wall_mask,\n            self.x_min,\n            self.y_min,\n            self.resolution,\n            self.nx,\n            self.ny,\n        )\n\n    def update_odor(self, x: float, y: float, odor: float) -&gt; None:\n        \"\"\"\n        Deposit odor at a specific location.\n\n        Args:\n            x (float): The x-coordinate in world units (mm).\n            y (float): The y-coordinate in world units (mm).\n            odor (float): The amount of odor to deposit.\n        \"\"\"\n        if x &lt; self.x_min or x &gt; self.x_max or y &lt; self.y_min or y &gt; self.y_max:\n            return\n        i, j, _, _ = self._world_to_grid(x, y)\n        i = np.clip(i, 0, self.ny - 1)\n        j = np.clip(j, 0, self.nx - 1)\n        self.odor_grid[i, j] += odor\n\n    def update_odor_vectorized(\n        self, xs: np.ndarray, ys: np.ndarray, odors: np.ndarray\n    ) -&gt; None:\n        \"\"\"\n        Vectorized update: deposit odor values at multiple positions.\n\n        Args:\n            xs (np.ndarray): 1D NumPy array of x coordinates.\n            ys (np.ndarray): 1D NumPy array of y coordinates.\n            odors (np.ndarray): 1D NumPy array of odor values.\n        \"\"\"\n        self.odor_grid = update_odor_vectorized_numba(\n            self.odor_grid,\n            xs,\n            ys,\n            odors,\n            self.x_min,\n            self.y_min,\n            self.resolution,\n            self.nx,\n            self.ny,\n        )\n\n    def deposit_odor_kernel(self, x: float, y: float, kernel: np.ndarray) -&gt; None:\n        \"\"\"\n        Deposit a single kernel (2D array) onto the odor grid at a given position.\n\n        Args:\n            x (float): The x-coordinate of the deposit center.\n            y (float): The y-coordinate of the deposit center.\n            kernel (np.ndarray): 2D array representing the odor distribution to add.\n                                 Assumed to be square with odd dimensions.\n        \"\"\"\n        ksize = kernel.shape[0]  # assume square kernel with odd dimensions\n        half_size = ksize // 2\n        i_center, j_center, _, _ = self._world_to_grid(x, y)\n        i0 = max(i_center - half_size, 0)\n        i1 = min(i_center + half_size + 1, self.ny)\n        j0 = max(j_center - half_size, 0)\n        j1 = min(j_center + half_size + 1, self.nx)\n        ki0 = half_size - (i_center - i0)\n        kj0 = half_size - (j_center - j0)\n        ki1 = ki0 + (i1 - i0)\n        kj1 = kj0 + (j1 - j0)\n        self.odor_grid[i0:i1, j0:j1] += kernel[ki0:ki1, kj0:kj1]\n\n    def deposit_odor_kernels_vectorized(\n        self, xs: np.ndarray, ys: np.ndarray, kernel: np.ndarray\n    ) -&gt; None:\n        \"\"\"\n        Vectorized deposition: deposit the same kernel at multiple positions.\n\n        This method uses a vectorized world-to-grid conversion and then loops over the deposit positions.\n        Note: Further vectorization would require advanced indexing and careful boundary handling.\n\n        Args:\n            xs (np.ndarray): 1D NumPy array of x coordinates for deposit centers.\n            ys (np.ndarray): 1D NumPy array of y coordinates for deposit centers.\n            kernel (np.ndarray): 2D NumPy array representing the kernel (assumed square, odd dimensions).\n        \"\"\"\n        # get world to grid indices\n        i, j, _, _ = self.world_to_grid_vectorized(xs, ys)\n        self.odor_grid = deposit_odor_kernels_vectorized_numba(\n            self.odor_grid, i, j, kernel, self.ny, self.nx\n        )\n\n    def _compute_diffusion_kernel(self, dt: float) -&gt; Tuple[float, np.ndarray]:\n        \"\"\"\n        Compute the Gaussian diffusion kernel for a given time step.\n\n        Args:\n            dt (float): Time step in seconds.\n\n        Returns:\n            Tuple[float, np.ndarray]: A tuple containing:\n                - sigma_grid (float): The standard deviation in grid units.\n                - kernel (np.ndarray): The computed 2D Gaussian kernel.\n        \"\"\"\n        var = self.diffusion_coefficient * dt\n        diffusion_sigma_mm = np.sqrt(var)\n        sigma_grid = diffusion_sigma_mm / self.resolution\n        kernel_size = int(2 * np.ceil(3 * sigma_grid)) + 1\n        ax = np.linspace(-kernel_size // 2, kernel_size // 2, kernel_size)\n        ay = np.linspace(-kernel_size // 2, kernel_size // 2, kernel_size)\n        X, Y = np.meshgrid(ax, ay)\n        kernel = np.exp(-(X**2 + Y**2) / (2 * sigma_grid**2))\n        kernel /= np.sum(kernel)\n        return sigma_grid, kernel\n\n    def update_odor_field(self, dt: float = 1.0, method: str = \"box_blur\") -&gt; None:\n        \"\"\"\n        Update the odor field dynamics (diffusion and decay).\n\n        Args:\n            dt (float): Time step for the update. Default is 1.0.\n            method (str): The method to use for diffusion. Options are:\n                          - 'fft': FFT-based convolution (fast for large kernels).\n                          - 'convolve2d': Scipy's convolve2d.\n                          - 'gaussian_filter': Scipy's gaussian_filter.\n                          - 'box_blur': Approximate Gaussian blur using multiple box filters (fastest).\n                          Default is 'box_blur'.\n\n        Raises:\n            ValueError: If an unknown diffusion method is specified.\n        \"\"\"\n        if self.diffusion_coefficient == 0:\n            self.odor_grid *= 1 - self.odor_decay_rate\n            if hasattr(self, \"base_odor\"):\n                self.odor_grid = np.maximum(self.odor_grid, self.base_odor)\n            return\n\n        if not hasattr(self, \"_diffusion_dt\"):\n            self._diffusion_dt = dt\n\n        if not hasattr(self, \"_diffusion_kernel\") or self._diffusion_dt != dt:\n            sigma_grid, kernel = self._compute_diffusion_kernel(dt)\n            self._diffusion_sigma = sigma_grid\n            self._diffusion_kernel = kernel\n            self._diffusion_dt = dt\n            logger.info(f\"Computed and cached diffusion kernel for dt={dt}\")\n\n        if method == \"fft\":\n            # FFT-based convolution\n            if not hasattr(self, \"_diffusion_kernel_fft\"):\n                self._diffusion_kernel_fft = np.fft.rfftn(\n                    self._diffusion_kernel, s=self.odor_grid.shape\n                )\n                logger.info(\"Computed and cached FFT of diffusion kernel.\")\n            odor_fft = np.fft.rfftn(self.odor_grid)\n            convolved = np.fft.irfftn(\n                odor_fft * self._diffusion_kernel_fft, s=self.odor_grid.shape\n            )\n            self.odor_grid = convolved\n        elif method == \"convolve2d\":\n            self.odor_grid = convolve2d(\n                self.odor_grid,\n                self._diffusion_kernel,\n                mode=\"same\",\n                boundary=\"fill\",\n                fillvalue=0,\n            )\n        elif method == \"gaussian_filter\":\n            self.odor_grid = gaussian_filter(\n                self.odor_grid, sigma=self._diffusion_sigma, mode=\"constant\", cval=0\n            )\n        elif method == \"box_blur\":\n            # Use uniform_filter to approximate Gaussian blur by applying it three times.\n            # For a 1D box filter of width w, the variance is (w^2 - 1) / 12.\n            # Here we set the box filter width such that its variance approximates that of our Gaussian.\n            # A common heuristic is r = ceil(sigma * sqrt(3)), so kernel size = 2*r+1.\n            r = int(np.ceil(self._diffusion_sigma * np.sqrt(3)))\n            size = 2 * r + 1\n            # Apply the box filter three times for a better approximation.\n            self.odor_grid = uniform_filter(\n                self.odor_grid, size=size, mode=\"constant\", cval=0\n            )\n            self.odor_grid = uniform_filter(\n                self.odor_grid, size=size, mode=\"constant\", cval=0\n            )\n            self.odor_grid = uniform_filter(\n                self.odor_grid, size=size, mode=\"constant\", cval=0\n            )\n        else:\n            raise ValueError(\n                \"Unknown diffusion method: choose 'fft', 'convolve2d', 'gaussian_filter', or 'box_blur'.\"\n            )\n\n        # Finally, apply odor decay.\n        self.odor_grid *= 1 - self.odor_decay_rate\n\n        # Optionally clamp the odor grid if needed.\n        if hasattr(self, \"base_odor\"):\n            self.odor_grid = np.maximum(self.odor_grid, self.base_odor)\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.__init__","title":"<code>__init__(x_min, x_max, y_min, y_max, resolution, wall_mask=None, config=None)</code>","text":"<p>Initialize the GridArena.</p> <p>Parameters:</p> Name Type Description Default <code>x_min</code> <code>float</code> <p>Minimum x-coordinate.</p> required <code>x_max</code> <code>float</code> <p>Maximum x-coordinate.</p> required <code>y_min</code> <code>float</code> <p>Minimum y-coordinate.</p> required <code>y_max</code> <code>float</code> <p>Maximum y-coordinate.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution (mm/cell).</p> required <code>wall_mask</code> <code>Optional[ndarray]</code> <p>Boolean mask for walls. If None, no walls are present.</p> <code>None</code> <code>config</code> <code>Optional[SimulationConfig]</code> <p>Simulation configuration object to pull parameters from.</p> <code>None</code> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def __init__(\n    self,\n    x_min: float,\n    x_max: float,\n    y_min: float,\n    y_max: float,\n    resolution: float,\n    wall_mask: Optional[np.ndarray] = None,\n    config: Optional[SimulationConfig] = None,\n):\n    \"\"\"\n    Initialize the GridArena.\n\n    Args:\n        x_min (float): Minimum x-coordinate.\n        x_max (float): Maximum x-coordinate.\n        y_min (float): Minimum y-coordinate.\n        y_max (float): Maximum y-coordinate.\n        resolution (float): Grid resolution (mm/cell).\n        wall_mask (Optional[np.ndarray]): Boolean mask for walls. If None, no walls are present.\n        config (Optional[SimulationConfig]): Simulation configuration object to pull parameters from.\n    \"\"\"\n    self.x_min = x_min\n    self.x_max = x_max\n    self.y_min = y_min\n    self.y_max = y_max\n    self.resolution = resolution\n    self.nx = int(np.ceil((x_max - x_min) / resolution)) + 1\n    self.ny = int(np.ceil((y_max - y_min) / resolution)) + 1\n    self.odor_grid = np.zeros((self.ny, self.nx))\n    if wall_mask is None:\n        self.wall_mask = np.zeros((self.ny, self.nx), dtype=bool)\n    else:\n        if wall_mask.shape != (self.ny, self.nx):\n            raise ValueError(\"Wall mask dimensions do not match grid.\")\n        self.wall_mask = wall_mask\n    if config is not None:\n        self.diffusion_coefficient = config.diffusion_coefficient\n        self.odor_decay_rate = config.odor_decay_rate\n    else:\n        self.diffusion_coefficient = 0.1\n        self.odor_decay_rate = 0.001\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.deposit_odor_kernel","title":"<code>deposit_odor_kernel(x, y, kernel)</code>","text":"<p>Deposit a single kernel (2D array) onto the odor grid at a given position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate of the deposit center.</p> required <code>y</code> <code>float</code> <p>The y-coordinate of the deposit center.</p> required <code>kernel</code> <code>ndarray</code> <p>2D array representing the odor distribution to add.                  Assumed to be square with odd dimensions.</p> required Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def deposit_odor_kernel(self, x: float, y: float, kernel: np.ndarray) -&gt; None:\n    \"\"\"\n    Deposit a single kernel (2D array) onto the odor grid at a given position.\n\n    Args:\n        x (float): The x-coordinate of the deposit center.\n        y (float): The y-coordinate of the deposit center.\n        kernel (np.ndarray): 2D array representing the odor distribution to add.\n                             Assumed to be square with odd dimensions.\n    \"\"\"\n    ksize = kernel.shape[0]  # assume square kernel with odd dimensions\n    half_size = ksize // 2\n    i_center, j_center, _, _ = self._world_to_grid(x, y)\n    i0 = max(i_center - half_size, 0)\n    i1 = min(i_center + half_size + 1, self.ny)\n    j0 = max(j_center - half_size, 0)\n    j1 = min(j_center + half_size + 1, self.nx)\n    ki0 = half_size - (i_center - i0)\n    kj0 = half_size - (j_center - j0)\n    ki1 = ki0 + (i1 - i0)\n    kj1 = kj0 + (j1 - j0)\n    self.odor_grid[i0:i1, j0:j1] += kernel[ki0:ki1, kj0:kj1]\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.deposit_odor_kernels_vectorized","title":"<code>deposit_odor_kernels_vectorized(xs, ys, kernel)</code>","text":"<p>Vectorized deposition: deposit the same kernel at multiple positions.</p> <p>This method uses a vectorized world-to-grid conversion and then loops over the deposit positions. Note: Further vectorization would require advanced indexing and careful boundary handling.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D NumPy array of x coordinates for deposit centers.</p> required <code>ys</code> <code>ndarray</code> <p>1D NumPy array of y coordinates for deposit centers.</p> required <code>kernel</code> <code>ndarray</code> <p>2D NumPy array representing the kernel (assumed square, odd dimensions).</p> required Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def deposit_odor_kernels_vectorized(\n    self, xs: np.ndarray, ys: np.ndarray, kernel: np.ndarray\n) -&gt; None:\n    \"\"\"\n    Vectorized deposition: deposit the same kernel at multiple positions.\n\n    This method uses a vectorized world-to-grid conversion and then loops over the deposit positions.\n    Note: Further vectorization would require advanced indexing and careful boundary handling.\n\n    Args:\n        xs (np.ndarray): 1D NumPy array of x coordinates for deposit centers.\n        ys (np.ndarray): 1D NumPy array of y coordinates for deposit centers.\n        kernel (np.ndarray): 2D NumPy array representing the kernel (assumed square, odd dimensions).\n    \"\"\"\n    # get world to grid indices\n    i, j, _, _ = self.world_to_grid_vectorized(xs, ys)\n    self.odor_grid = deposit_odor_kernels_vectorized_numba(\n        self.odor_grid, i, j, kernel, self.ny, self.nx\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.get_odor","title":"<code>get_odor(x, y)</code>","text":"<p>Get the odor concentration at a specific world location using bilinear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>World x-coordinate.</p> required <code>y</code> <code>float</code> <p>World y-coordinate.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Interpolated odor concentration. Returns 0.0 if outside the arena.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def get_odor(self, x: float, y: float) -&gt; float:\n    \"\"\"\n    Get the odor concentration at a specific world location using bilinear interpolation.\n\n    Args:\n        x (float): World x-coordinate.\n        y (float): World y-coordinate.\n\n    Returns:\n        float: Interpolated odor concentration. Returns 0.0 if outside the arena.\n    \"\"\"\n    if x &lt; self.x_min or x &gt; self.x_max or y &lt; self.y_min or y &gt; self.y_max:\n        return 0.0\n    i, j, fi, fj = self._world_to_grid(x, y)\n    i1 = min(i, self.ny - 2)\n    j1 = min(j, self.nx - 2)\n    Q11 = self.odor_grid[i1, j1]\n    Q21 = self.odor_grid[i1, j1 + 1]\n    Q12 = self.odor_grid[i1 + 1, j1]\n    Q22 = self.odor_grid[i1 + 1, j1 + 1]\n    return (\n        Q11 * (1 - fi) * (1 - fj)\n        + Q21 * fi * (1 - fj)\n        + Q12 * (1 - fi) * fj\n        + Q22 * fi * fj\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.get_odor_vectorized","title":"<code>get_odor_vectorized(xs, ys)</code>","text":"<p>Vectorized version of get_odor using bilinear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>NumPy array of y coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of odor concentrations corresponding to the input coordinates.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def get_odor_vectorized(self, xs: np.ndarray, ys: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized version of get_odor using bilinear interpolation.\n\n    Args:\n        xs (np.ndarray): NumPy array of x coordinates.\n        ys (np.ndarray): NumPy array of y coordinates.\n\n    Returns:\n        np.ndarray: Array of odor concentrations corresponding to the input coordinates.\n    \"\"\"\n    return get_odor_vectorized_numba(\n        xs,\n        ys,\n        self.odor_grid,\n        self.x_min,\n        self.y_min,\n        self.resolution,\n        self.nx,\n        self.ny,\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.is_free_vectorized","title":"<code>is_free_vectorized(xs, ys)</code>","text":"<p>Vectorized check if locations are free of obstacles.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>NumPy array of y coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Boolean NumPy array indicating free (True) or blocked (False) for each coordinate.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def is_free_vectorized(self, xs: np.ndarray, ys: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized check if locations are free of obstacles.\n\n    Args:\n        xs (np.ndarray): NumPy array of x coordinates.\n        ys (np.ndarray): NumPy array of y coordinates.\n\n    Returns:\n        np.ndarray: Boolean NumPy array indicating free (True) or blocked (False) for each coordinate.\n    \"\"\"\n    return is_free_vectorized_numba(\n        xs,\n        ys,\n        self.wall_mask,\n        self.x_min,\n        self.y_min,\n        self.resolution,\n        self.nx,\n        self.ny,\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.update_odor","title":"<code>update_odor(x, y, odor)</code>","text":"<p>Deposit odor at a specific location.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x-coordinate in world units (mm).</p> required <code>y</code> <code>float</code> <p>The y-coordinate in world units (mm).</p> required <code>odor</code> <code>float</code> <p>The amount of odor to deposit.</p> required Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def update_odor(self, x: float, y: float, odor: float) -&gt; None:\n    \"\"\"\n    Deposit odor at a specific location.\n\n    Args:\n        x (float): The x-coordinate in world units (mm).\n        y (float): The y-coordinate in world units (mm).\n        odor (float): The amount of odor to deposit.\n    \"\"\"\n    if x &lt; self.x_min or x &gt; self.x_max or y &lt; self.y_min or y &gt; self.y_max:\n        return\n    i, j, _, _ = self._world_to_grid(x, y)\n    i = np.clip(i, 0, self.ny - 1)\n    j = np.clip(j, 0, self.nx - 1)\n    self.odor_grid[i, j] += odor\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.update_odor_field","title":"<code>update_odor_field(dt=1.0, method='box_blur')</code>","text":"<p>Update the odor field dynamics (diffusion and decay).</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Time step for the update. Default is 1.0.</p> <code>1.0</code> <code>method</code> <code>str</code> <p>The method to use for diffusion. Options are:           - 'fft': FFT-based convolution (fast for large kernels).           - 'convolve2d': Scipy's convolve2d.           - 'gaussian_filter': Scipy's gaussian_filter.           - 'box_blur': Approximate Gaussian blur using multiple box filters (fastest).           Default is 'box_blur'.</p> <code>'box_blur'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unknown diffusion method is specified.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def update_odor_field(self, dt: float = 1.0, method: str = \"box_blur\") -&gt; None:\n    \"\"\"\n    Update the odor field dynamics (diffusion and decay).\n\n    Args:\n        dt (float): Time step for the update. Default is 1.0.\n        method (str): The method to use for diffusion. Options are:\n                      - 'fft': FFT-based convolution (fast for large kernels).\n                      - 'convolve2d': Scipy's convolve2d.\n                      - 'gaussian_filter': Scipy's gaussian_filter.\n                      - 'box_blur': Approximate Gaussian blur using multiple box filters (fastest).\n                      Default is 'box_blur'.\n\n    Raises:\n        ValueError: If an unknown diffusion method is specified.\n    \"\"\"\n    if self.diffusion_coefficient == 0:\n        self.odor_grid *= 1 - self.odor_decay_rate\n        if hasattr(self, \"base_odor\"):\n            self.odor_grid = np.maximum(self.odor_grid, self.base_odor)\n        return\n\n    if not hasattr(self, \"_diffusion_dt\"):\n        self._diffusion_dt = dt\n\n    if not hasattr(self, \"_diffusion_kernel\") or self._diffusion_dt != dt:\n        sigma_grid, kernel = self._compute_diffusion_kernel(dt)\n        self._diffusion_sigma = sigma_grid\n        self._diffusion_kernel = kernel\n        self._diffusion_dt = dt\n        logger.info(f\"Computed and cached diffusion kernel for dt={dt}\")\n\n    if method == \"fft\":\n        # FFT-based convolution\n        if not hasattr(self, \"_diffusion_kernel_fft\"):\n            self._diffusion_kernel_fft = np.fft.rfftn(\n                self._diffusion_kernel, s=self.odor_grid.shape\n            )\n            logger.info(\"Computed and cached FFT of diffusion kernel.\")\n        odor_fft = np.fft.rfftn(self.odor_grid)\n        convolved = np.fft.irfftn(\n            odor_fft * self._diffusion_kernel_fft, s=self.odor_grid.shape\n        )\n        self.odor_grid = convolved\n    elif method == \"convolve2d\":\n        self.odor_grid = convolve2d(\n            self.odor_grid,\n            self._diffusion_kernel,\n            mode=\"same\",\n            boundary=\"fill\",\n            fillvalue=0,\n        )\n    elif method == \"gaussian_filter\":\n        self.odor_grid = gaussian_filter(\n            self.odor_grid, sigma=self._diffusion_sigma, mode=\"constant\", cval=0\n        )\n    elif method == \"box_blur\":\n        # Use uniform_filter to approximate Gaussian blur by applying it three times.\n        # For a 1D box filter of width w, the variance is (w^2 - 1) / 12.\n        # Here we set the box filter width such that its variance approximates that of our Gaussian.\n        # A common heuristic is r = ceil(sigma * sqrt(3)), so kernel size = 2*r+1.\n        r = int(np.ceil(self._diffusion_sigma * np.sqrt(3)))\n        size = 2 * r + 1\n        # Apply the box filter three times for a better approximation.\n        self.odor_grid = uniform_filter(\n            self.odor_grid, size=size, mode=\"constant\", cval=0\n        )\n        self.odor_grid = uniform_filter(\n            self.odor_grid, size=size, mode=\"constant\", cval=0\n        )\n        self.odor_grid = uniform_filter(\n            self.odor_grid, size=size, mode=\"constant\", cval=0\n        )\n    else:\n        raise ValueError(\n            \"Unknown diffusion method: choose 'fft', 'convolve2d', 'gaussian_filter', or 'box_blur'.\"\n        )\n\n    # Finally, apply odor decay.\n    self.odor_grid *= 1 - self.odor_decay_rate\n\n    # Optionally clamp the odor grid if needed.\n    if hasattr(self, \"base_odor\"):\n        self.odor_grid = np.maximum(self.odor_grid, self.base_odor)\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.update_odor_vectorized","title":"<code>update_odor_vectorized(xs, ys, odors)</code>","text":"<p>Vectorized update: deposit odor values at multiple positions.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>1D NumPy array of y coordinates.</p> required <code>odors</code> <code>ndarray</code> <p>1D NumPy array of odor values.</p> required Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def update_odor_vectorized(\n    self, xs: np.ndarray, ys: np.ndarray, odors: np.ndarray\n) -&gt; None:\n    \"\"\"\n    Vectorized update: deposit odor values at multiple positions.\n\n    Args:\n        xs (np.ndarray): 1D NumPy array of x coordinates.\n        ys (np.ndarray): 1D NumPy array of y coordinates.\n        odors (np.ndarray): 1D NumPy array of odor values.\n    \"\"\"\n    self.odor_grid = update_odor_vectorized_numba(\n        self.odor_grid,\n        xs,\n        ys,\n        odors,\n        self.x_min,\n        self.y_min,\n        self.resolution,\n        self.nx,\n        self.ny,\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.GridArena.world_to_grid_vectorized","title":"<code>world_to_grid_vectorized(x, y)</code>","text":"<p>Convert arrays of world coordinates to grid indices and fractional parts.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>NumPy array of x coordinates.</p> required <code>y</code> <code>ndarray</code> <p>NumPy array of y coordinates.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: A tuple (i, j, fi, fj) where: i (np.ndarray): Integer grid row indices. j (np.ndarray): Integer grid column indices. fi (np.ndarray): Fractional parts in x. fj (np.ndarray): Fractional parts in y.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def world_to_grid_vectorized(\n    self, x: np.ndarray, y: np.ndarray\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Convert arrays of world coordinates to grid indices and fractional parts.\n\n    Args:\n        x (np.ndarray): NumPy array of x coordinates.\n        y (np.ndarray): NumPy array of y coordinates.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: A tuple (i, j, fi, fj) where:\n            i (np.ndarray): Integer grid row indices.\n            j (np.ndarray): Integer grid column indices.\n            fi (np.ndarray): Fractional parts in x.\n            fj (np.ndarray): Fractional parts in y.\n    \"\"\"\n    return world_to_grid_vectorized_numba(\n        x, y, self.x_min, self.y_min, self.resolution, self.nx, self.ny\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.PeriodicSquareArena","title":"<code>PeriodicSquareArena</code>","text":"<p>               Bases: <code>GridArena</code></p> <p>A square arena with periodic (toroidal) boundary conditions.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>class PeriodicSquareArena(GridArena):\n    \"\"\"\n    A square arena with periodic (toroidal) boundary conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        x_min: float,\n        x_max: float,\n        y_min: float,\n        y_max: float,\n        resolution: float,\n        config: Optional[SimulationConfig] = None,\n    ):\n        super().__init__(\n            x_min,\n            x_max,\n            y_min,\n            y_max,\n            resolution,\n            wall_mask=np.zeros(\n                (\n                    int(np.ceil((y_max - y_min) / resolution)) + 1,\n                    int(np.ceil((x_max - x_min) / resolution)) + 1,\n                ),\n                dtype=bool,\n            ),\n            config=config,\n        )\n\n    def _world_to_grid(self, x: float, y: float) -&gt; Tuple[int, int, float, float]:\n        gx = (x - self.x_min) / self.resolution\n        gy = (y - self.y_min) / self.resolution\n        j = int(np.floor(gx)) % self.nx\n        i = int(np.floor(gy)) % self.ny\n        fi = gx - np.floor(gx)\n        fj = gy - np.floor(gy)\n        return i, j, fi, fj\n\n    def world_to_grid_vectorized(\n        self, x: np.ndarray, y: np.ndarray\n    ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"\n        Convert arrays of world coordinates to grid indices and fractional parts.\n\n        Args:\n            x (np.ndarray): NumPy array of x coordinates.\n            y (np.ndarray): NumPy array of y coordinates.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Tuple of arrays\n                (i, j, fi, fj) where i and j are integer grid indices, and fi and fj\n                are the fractional parts.\n        \"\"\"\n        return world_to_grid_periodic_vectorized_numba(\n            x, y, self.x_min, self.y_min, self.resolution, self.nx, self.ny\n        )\n\n    def get_odor(self, x: float, y: float) -&gt; float:\n        i, j, fi, fj = self._world_to_grid(x, y)\n        i1 = (i + 1) % self.ny\n        j1 = (j + 1) % self.nx\n        Q11 = self.odor_grid[i, j]\n        Q21 = self.odor_grid[i, j1]\n        Q12 = self.odor_grid[i1, j]\n        Q22 = self.odor_grid[i1, j1]\n        return (\n            Q11 * (1 - fi) * (1 - fj)\n            + Q21 * fi * (1 - fj)\n            + Q12 * (1 - fi) * fj\n            + Q22 * fi * fj\n        )\n\n    def get_odor_vectorized(self, xs: np.ndarray, ys: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Vectorized version of get_odor using bilinear interpolation.\n\n        Args:\n            xs (np.ndarray): NumPy array of x coordinates.\n            ys (np.ndarray): NumPy array of y coordinates.\n\n        Returns:\n            np.ndarray: NumPy array of interpolated odor values.\n        \"\"\"\n        return get_odor_periodic_vectorized_numba(\n            xs,\n            ys,\n            self.odor_grid,\n            self.x_min,\n            self.y_min,\n            self.resolution,\n            self.nx,\n            self.ny,\n        )\n\n    def is_free(self, x: float, y: float) -&gt; bool:\n        i, j, _, _ = self._world_to_grid(x, y)\n        return not self.wall_mask[i, j]\n\n    def is_free_vectorized(self, xs: np.ndarray, ys: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Vectorized version of is_free.\n\n        Args:\n            xs (np.ndarray): NumPy array of x coordinates.\n            ys (np.ndarray): NumPy array of y coordinates.\n\n        Returns:\n            np.ndarray: Boolean NumPy array indicating free (True) or blocked (False)\n                for each coordinate.\n        \"\"\"\n        return is_free_periodic_vectorized_numba(\n            xs,\n            ys,\n            self.wall_mask,\n            self.x_min,\n            self.y_min,\n            self.resolution,\n            self.nx,\n            self.ny,\n        )\n\n    def update_odor(self, x: float, y: float, odor: float) -&gt; None:\n        i, j, _, _ = self._world_to_grid(x, y)\n        self.odor_grid[i, j] += odor\n\n    def update_odor_vectorized(\n        self, xs: np.ndarray, ys: np.ndarray, odors: np.ndarray\n    ) -&gt; None:\n        \"\"\"\n        Vectorized update: deposit odor values at multiple positions.\n\n        Args:\n            xs (np.ndarray): 1D NumPy array of x coordinates.\n            ys (np.ndarray): 1D NumPy array of y coordinates.\n            odors (np.ndarray): 1D NumPy array of odor values.\n        \"\"\"\n        self.odor_grid = update_odor_periodic_vectorized_numba(\n            self.odor_grid,\n            xs,\n            ys,\n            odors,\n            self.x_min,\n            self.y_min,\n            self.resolution,\n            self.nx,\n            self.ny,\n        )\n\n    def deposit_odor_kernel(self, x: float, y: float, kernel: np.ndarray) -&gt; None:\n        ksize = kernel.shape[0]\n        half_size = ksize // 2\n        i_center, j_center, _, _ = self._world_to_grid(x, y)\n        ny, nx = self.odor_grid.shape\n        for di in range(ksize):\n            for dj in range(ksize):\n                # Compute target indices with periodic wrapping\n                i = (i_center - half_size + di) % ny\n                j = (j_center - half_size + dj) % nx\n                self.odor_grid[i, j] += kernel[di, dj]\n\n    def deposit_odor_kernels_vectorized(\n        self, xs: np.ndarray, ys: np.ndarray, kernel: np.ndarray\n    ) -&gt; None:\n        \"\"\"\n        Vectorized deposition: deposit the same kernel at multiple positions.\n\n        This method uses a vectorized world-to-grid conversion and then loops over\n        the deposit positions. Note: Further vectorization would require advanced\n        indexing and careful boundary handling.\n\n        Args:\n            xs (np.ndarray): 1D NumPy array of x coordinates for deposit centers.\n            ys (np.ndarray): 1D NumPy array of y coordinates for deposit centers.\n            kernel (np.ndarray): 2D NumPy array representing the kernel (assumed\n                square, odd dimensions).\n        \"\"\"\n        i, j, _, _ = self.world_to_grid_vectorized(xs, ys)\n        self.odor_grid = deposit_odor_kernels_periodic_vectorized_numba(\n            self.odor_grid, i, j, kernel, self.ny, self.nx\n        )\n\n    def update_odor_field(self, dt: float = 1.0, method: str = \"box_blur\") -&gt; None:\n        if self.diffusion_coefficient == 0:\n            self.odor_grid *= 1 - self.odor_decay_rate\n            if hasattr(self, \"base_odor\"):\n                self.odor_grid = np.maximum(self.odor_grid, self.base_odor)\n            return\n\n        if not hasattr(self, \"_diffusion_dt\"):\n            self._diffusion_dt = dt\n\n        if not hasattr(self, \"_diffusion_kernel\") or self._diffusion_dt != dt:\n            sigma, kernel = self._compute_diffusion_kernel(dt)\n            self._diffusion_sigma = sigma\n            self._diffusion_kernel = kernel\n            self._diffusion_dt = dt\n            logger.info(f\"(Periodic) Computed and cached diffusion kernel for dt={dt}\")\n\n        if method == \"fft\":\n            if not hasattr(self, \"_diffusion_kernel_fft\"):\n                self._diffusion_kernel_fft = np.fft.rfftn(\n                    self._diffusion_kernel, s=self.odor_grid.shape\n                )\n                logger.info(\n                    f\"(Periodic) Computed and cached FFT of diffusion kernel for dt={dt}\"\n                )\n            odor_fft = np.fft.rfftn(self.odor_grid)\n            convolved = np.fft.irfftn(\n                odor_fft * self._diffusion_kernel_fft, s=self.odor_grid.shape\n            )\n            self.odor_grid = convolved\n        elif method == \"convolve2d\":\n            self.odor_grid = convolve2d(\n                self.odor_grid, self._diffusion_kernel, mode=\"same\", boundary=\"wrap\"\n            )\n        elif method == \"gaussian_filter\":\n            self.odor_grid = gaussian_filter(\n                self.odor_grid, sigma=self._diffusion_sigma, mode=\"wrap\"\n            )\n        elif method == \"box_blur\":\n            r = int(np.ceil(self._diffusion_sigma * np.sqrt(3)))\n            size = 2 * r + 1\n            self.odor_grid = uniform_filter(self.odor_grid, size=size, mode=\"wrap\")\n            self.odor_grid = uniform_filter(self.odor_grid, size=size, mode=\"wrap\")\n            self.odor_grid = uniform_filter(self.odor_grid, size=size, mode=\"wrap\")\n        else:\n            raise ValueError(\n                \"Unknown diffusion method: choose 'fft', 'convolve2d', 'gaussian_filter', or 'box_blur'.\"\n            )\n        self.odor_grid *= 1 - self.odor_decay_rate\n        if hasattr(self, \"base_odor\"):\n            self.odor_grid = np.maximum(self.odor_grid, self.base_odor)\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.PeriodicSquareArena.deposit_odor_kernels_vectorized","title":"<code>deposit_odor_kernels_vectorized(xs, ys, kernel)</code>","text":"<p>Vectorized deposition: deposit the same kernel at multiple positions.</p> <p>This method uses a vectorized world-to-grid conversion and then loops over the deposit positions. Note: Further vectorization would require advanced indexing and careful boundary handling.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D NumPy array of x coordinates for deposit centers.</p> required <code>ys</code> <code>ndarray</code> <p>1D NumPy array of y coordinates for deposit centers.</p> required <code>kernel</code> <code>ndarray</code> <p>2D NumPy array representing the kernel (assumed square, odd dimensions).</p> required Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def deposit_odor_kernels_vectorized(\n    self, xs: np.ndarray, ys: np.ndarray, kernel: np.ndarray\n) -&gt; None:\n    \"\"\"\n    Vectorized deposition: deposit the same kernel at multiple positions.\n\n    This method uses a vectorized world-to-grid conversion and then loops over\n    the deposit positions. Note: Further vectorization would require advanced\n    indexing and careful boundary handling.\n\n    Args:\n        xs (np.ndarray): 1D NumPy array of x coordinates for deposit centers.\n        ys (np.ndarray): 1D NumPy array of y coordinates for deposit centers.\n        kernel (np.ndarray): 2D NumPy array representing the kernel (assumed\n            square, odd dimensions).\n    \"\"\"\n    i, j, _, _ = self.world_to_grid_vectorized(xs, ys)\n    self.odor_grid = deposit_odor_kernels_periodic_vectorized_numba(\n        self.odor_grid, i, j, kernel, self.ny, self.nx\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.PeriodicSquareArena.get_odor_vectorized","title":"<code>get_odor_vectorized(xs, ys)</code>","text":"<p>Vectorized version of get_odor using bilinear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>NumPy array of y coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: NumPy array of interpolated odor values.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def get_odor_vectorized(self, xs: np.ndarray, ys: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized version of get_odor using bilinear interpolation.\n\n    Args:\n        xs (np.ndarray): NumPy array of x coordinates.\n        ys (np.ndarray): NumPy array of y coordinates.\n\n    Returns:\n        np.ndarray: NumPy array of interpolated odor values.\n    \"\"\"\n    return get_odor_periodic_vectorized_numba(\n        xs,\n        ys,\n        self.odor_grid,\n        self.x_min,\n        self.y_min,\n        self.resolution,\n        self.nx,\n        self.ny,\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.PeriodicSquareArena.is_free_vectorized","title":"<code>is_free_vectorized(xs, ys)</code>","text":"<p>Vectorized version of is_free.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>NumPy array of y coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Boolean NumPy array indicating free (True) or blocked (False) for each coordinate.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def is_free_vectorized(self, xs: np.ndarray, ys: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized version of is_free.\n\n    Args:\n        xs (np.ndarray): NumPy array of x coordinates.\n        ys (np.ndarray): NumPy array of y coordinates.\n\n    Returns:\n        np.ndarray: Boolean NumPy array indicating free (True) or blocked (False)\n            for each coordinate.\n    \"\"\"\n    return is_free_periodic_vectorized_numba(\n        xs,\n        ys,\n        self.wall_mask,\n        self.x_min,\n        self.y_min,\n        self.resolution,\n        self.nx,\n        self.ny,\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.PeriodicSquareArena.update_odor_vectorized","title":"<code>update_odor_vectorized(xs, ys, odors)</code>","text":"<p>Vectorized update: deposit odor values at multiple positions.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>1D NumPy array of y coordinates.</p> required <code>odors</code> <code>ndarray</code> <p>1D NumPy array of odor values.</p> required Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def update_odor_vectorized(\n    self, xs: np.ndarray, ys: np.ndarray, odors: np.ndarray\n) -&gt; None:\n    \"\"\"\n    Vectorized update: deposit odor values at multiple positions.\n\n    Args:\n        xs (np.ndarray): 1D NumPy array of x coordinates.\n        ys (np.ndarray): 1D NumPy array of y coordinates.\n        odors (np.ndarray): 1D NumPy array of odor values.\n    \"\"\"\n    self.odor_grid = update_odor_periodic_vectorized_numba(\n        self.odor_grid,\n        xs,\n        ys,\n        odors,\n        self.x_min,\n        self.y_min,\n        self.resolution,\n        self.nx,\n        self.ny,\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.PeriodicSquareArena.world_to_grid_vectorized","title":"<code>world_to_grid_vectorized(x, y)</code>","text":"<p>Convert arrays of world coordinates to grid indices and fractional parts.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>NumPy array of x coordinates.</p> required <code>y</code> <code>ndarray</code> <p>NumPy array of y coordinates.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Tuple of arrays (i, j, fi, fj) where i and j are integer grid indices, and fi and fj are the fractional parts.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def world_to_grid_vectorized(\n    self, x: np.ndarray, y: np.ndarray\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Convert arrays of world coordinates to grid indices and fractional parts.\n\n    Args:\n        x (np.ndarray): NumPy array of x coordinates.\n        y (np.ndarray): NumPy array of y coordinates.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Tuple of arrays\n            (i, j, fi, fj) where i and j are integer grid indices, and fi and fj\n            are the fractional parts.\n    \"\"\"\n    return world_to_grid_periodic_vectorized_numba(\n        x, y, self.x_min, self.y_min, self.resolution, self.nx, self.ny\n    )\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.create_circular_arena_with_annular_trail","title":"<code>create_circular_arena_with_annular_trail(config, arena_radius=75.0, trail_radius=50.0, trail_width=3.0, trail_odor=1.0)</code>","text":"<p>Helper to create a circular arena with an annular trail preset in the odor grid.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def create_circular_arena_with_annular_trail(\n    config: SimulationConfig,\n    arena_radius: float = 75.0,\n    trail_radius: float = 50.0,\n    trail_width: float = 3.0,\n    trail_odor: float = 1.0,\n) -&gt; GridArena:\n    \"\"\"Helper to create a circular arena with an annular trail preset in the odor grid.\"\"\"\n    arena = GridArena(\n        config.grid_x_min,\n        config.grid_x_max,\n        config.grid_y_min,\n        config.grid_y_max,\n        config.grid_resolution,\n    )\n    # Create coordinate grids.\n    y_coords = np.linspace(config.grid_y_min, config.grid_y_max, arena.ny)\n    x_coords = np.linspace(config.grid_x_min, config.grid_x_max, arena.nx)\n    X, Y = np.meshgrid(x_coords, y_coords)\n    distances = np.sqrt(X**2 + Y**2)\n    # Set cells outside the circular arena as walls.\n    arena.wall_mask = distances &gt; arena_radius\n    inner_bound = trail_radius - trail_width / 2\n    outer_bound = trail_radius + trail_width / 2\n    annulus_mask = (\n        (distances &gt;= inner_bound) &amp; (distances &lt;= outer_bound) &amp; (~arena.wall_mask)\n    )\n    arena.odor_grid[annulus_mask] = trail_odor\n    return arena\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.create_pbc_arena_with_line","title":"<code>create_pbc_arena_with_line(config, line_width=5.0, line_odor=1.0)</code>","text":"<p>Helper to create a periodic square arena with a line preset in the odor grid.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>def create_pbc_arena_with_line(\n    config: SimulationConfig, line_width: float = 5.0, line_odor: float = 1.0\n) -&gt; PeriodicSquareArena:\n    \"\"\"Helper to create a periodic square arena with a line preset in the odor grid.\"\"\"\n    arena = PeriodicSquareArena(\n        config.grid_x_min,\n        config.grid_x_max,\n        config.grid_y_min,\n        config.grid_y_max,\n        config.grid_resolution,\n        config,\n    )\n    # Create coordinate grids.\n    y_coords = np.linspace(config.grid_y_min, config.grid_y_max, arena.ny)\n    x_coords = np.linspace(config.grid_x_min, config.grid_x_max, arena.nx)\n    X, Y = np.meshgrid(x_coords, y_coords)\n    # Set cells along the line as odor.\n    line_mask = np.abs(X) &lt;= line_width / 2\n    arena.odor_grid[line_mask] = line_odor\n    return arena\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.deposit_odor_kernel_numba","title":"<code>deposit_odor_kernel_numba(odor_grid, i_center, j_center, kernel, ny, nx)</code>","text":"<p>Numba-accelerated deposition of a single kernel at a grid index with periodic wrapping.</p> <p>Parameters:</p> Name Type Description Default <code>odor_grid</code> <code>ndarray</code> <p>2D array of the odor grid.</p> required <code>i_center</code> <code>int</code> <p>Center row index for deposit.</p> required <code>j_center</code> <code>int</code> <p>Center column index for deposit.</p> required <code>kernel</code> <code>ndarray</code> <p>2D array representing the deposition kernel.</p> required <code>ny</code> <code>int</code> <p>Number of rows in odor_grid.</p> required <code>nx</code> <code>int</code> <p>Number of columns in odor_grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated odor_grid.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef deposit_odor_kernel_numba(\n    odor_grid: np.ndarray,\n    i_center: int,\n    j_center: int,\n    kernel: np.ndarray,\n    ny: int,\n    nx: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated deposition of a single kernel at a grid index with periodic wrapping.\n\n    Args:\n        odor_grid (np.ndarray): 2D array of the odor grid.\n        i_center (int): Center row index for deposit.\n        j_center (int): Center column index for deposit.\n        kernel (np.ndarray): 2D array representing the deposition kernel.\n        ny (int): Number of rows in odor_grid.\n        nx (int): Number of columns in odor_grid.\n\n    Returns:\n        np.ndarray: Updated odor_grid.\n    \"\"\"\n    ksize = kernel.shape[0]\n    half_size = ksize // 2\n\n    # Compute deposition boundaries on the grid.\n    i0 = max(i_center - half_size, 0)\n    i1 = min(i_center + half_size + 1, ny)\n    j0 = max(j_center - half_size, 0)\n    j1 = min(j_center + half_size + 1, nx)\n\n    # Compute corresponding kernel indices.\n    ki0 = half_size - (i_center - i0)\n    kj0 = half_size - (j_center - j0)\n    ki1 = ki0 + (i1 - i0)\n    kj1 = kj0 + (j1 - j0)\n\n    # Deposit the kernel on the grid.\n    odor_grid[i0:i1, j0:j1] += kernel[ki0:ki1, kj0:kj1]\n    return odor_grid\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.deposit_odor_kernel_periodic_direct","title":"<code>deposit_odor_kernel_periodic_direct(odor_grid, i_center, j_center, kernel, ny, nx)</code>","text":"<p>Numba-accelerated deposition of a single kernel at a grid index with periodic wrapping.</p> <p>Parameters:</p> Name Type Description Default <code>odor_grid</code> <code>ndarray</code> <p>2D array of the odor grid.</p> required <code>i_center</code> <code>int</code> <p>Center row index for deposit.</p> required <code>j_center</code> <code>int</code> <p>Center column index for deposit.</p> required <code>kernel</code> <code>ndarray</code> <p>2D array representing the deposition kernel.</p> required <code>ny</code> <code>int</code> <p>Number of rows in odor_grid.</p> required <code>nx</code> <code>int</code> <p>Number of columns in odor_grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated odor_grid.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef deposit_odor_kernel_periodic_direct(\n    odor_grid: np.ndarray,\n    i_center: int,\n    j_center: int,\n    kernel: np.ndarray,\n    ny: int,\n    nx: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated deposition of a single kernel at a grid index with periodic wrapping.\n\n    Args:\n        odor_grid (np.ndarray): 2D array of the odor grid.\n        i_center (int): Center row index for deposit.\n        j_center (int): Center column index for deposit.\n        kernel (np.ndarray): 2D array representing the deposition kernel.\n        ny (int): Number of rows in odor_grid.\n        nx (int): Number of columns in odor_grid.\n\n    Returns:\n        np.ndarray: Updated odor_grid.\n    \"\"\"\n    ksize = kernel.shape[0]\n    half_size = ksize // 2\n    for di in range(ksize):\n        for dj in range(ksize):\n            # Compute target indices with periodic wrapping\n            i = (i_center - half_size + di) % ny\n            j = (j_center - half_size + dj) % nx\n            odor_grid[i, j] += kernel[di, dj]\n    return odor_grid\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.deposit_odor_kernels_periodic_vectorized_numba","title":"<code>deposit_odor_kernels_periodic_vectorized_numba(odor_grid, i_centers, j_centers, kernel, ny, nx)</code>","text":"<p>Numba-accelerated vectorized deposition of the same kernel at multiple grid indices.</p> <p>Parameters:</p> Name Type Description Default <code>odor_grid</code> <code>ndarray</code> <p>2D array representing the odor grid.</p> required <code>i_centers</code> <code>ndarray</code> <p>1D array of center row indices.</p> required <code>j_centers</code> <code>ndarray</code> <p>1D array of center column indices.</p> required <code>kernel</code> <code>ndarray</code> <p>2D array representing the kernel.</p> required <code>ny</code> <code>int</code> <p>Number of rows in odor_grid.</p> required <code>nx</code> <code>int</code> <p>Number of columns in odor_grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated odor_grid.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef deposit_odor_kernels_periodic_vectorized_numba(\n    odor_grid: np.ndarray,\n    i_centers: np.ndarray,\n    j_centers: np.ndarray,\n    kernel: np.ndarray,\n    ny: int,\n    nx: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated vectorized deposition of the same kernel at multiple grid indices.\n\n    Args:\n        odor_grid (np.ndarray): 2D array representing the odor grid.\n        i_centers (np.ndarray): 1D array of center row indices.\n        j_centers (np.ndarray): 1D array of center column indices.\n        kernel (np.ndarray): 2D array representing the kernel.\n        ny (int): Number of rows in odor_grid.\n        nx (int): Number of columns in odor_grid.\n\n    Returns:\n        np.ndarray: Updated odor_grid.\n    \"\"\"\n    for idx in range(i_centers.size):\n        odor_grid = deposit_odor_kernel_periodic_direct(\n            odor_grid, i_centers[idx], j_centers[idx], kernel, ny, nx\n        )\n    return odor_grid\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.deposit_odor_kernels_vectorized_numba","title":"<code>deposit_odor_kernels_vectorized_numba(odor_grid, i_centers, j_centers, kernel, ny, nx)</code>","text":"<p>Numba-accelerated vectorized deposition of the same kernel at multiple grid indices.</p> <p>Parameters:</p> Name Type Description Default <code>odor_grid</code> <code>ndarray</code> <p>2D array representing the odor grid.</p> required <code>i_centers</code> <code>ndarray</code> <p>1D array of center row indices (ints).</p> required <code>j_centers</code> <code>ndarray</code> <p>1D array of center column indices (ints).</p> required <code>kernel</code> <code>ndarray</code> <p>2D kernel array (assumed square, odd dimensions).</p> required <code>ny</code> <code>int</code> <p>Number of rows in grid.</p> required <code>nx</code> <code>int</code> <p>Number of columns in grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated odor_grid.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef deposit_odor_kernels_vectorized_numba(\n    odor_grid: np.ndarray,\n    i_centers: np.ndarray,\n    j_centers: np.ndarray,\n    kernel: np.ndarray,\n    ny: int,\n    nx: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated vectorized deposition of the same kernel at multiple grid indices.\n\n    Args:\n        odor_grid (np.ndarray): 2D array representing the odor grid.\n        i_centers (np.ndarray): 1D array of center row indices (ints).\n        j_centers (np.ndarray): 1D array of center column indices (ints).\n        kernel (np.ndarray): 2D kernel array (assumed square, odd dimensions).\n        ny (int): Number of rows in grid.\n        nx (int): Number of columns in grid.\n\n    Returns:\n        np.ndarray: Updated odor_grid.\n    \"\"\"\n    for idx in range(i_centers.size):\n        odor_grid = deposit_odor_kernel_numba(\n            odor_grid, i_centers[idx], j_centers[idx], kernel, ny, nx\n        )\n    return odor_grid\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.get_odor_periodic_vectorized_numba","title":"<code>get_odor_periodic_vectorized_numba(xs, ys, odor_grid, x_min, y_min, resolution, nx, ny)</code>","text":"<p>Numba-accelerated bilinear interpolation for odor values with periodic boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>1D NumPy array of y coordinates.</p> required <code>odor_grid</code> <code>ndarray</code> <p>2D NumPy array representing the odor grid.</p> required <code>x_min</code> <code>float</code> <p>Minimum x of the grid.</p> required <code>y_min</code> <code>float</code> <p>Minimum y of the grid.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution.</p> required <code>nx</code> <code>int</code> <p>Number of columns in grid.</p> required <code>ny</code> <code>int</code> <p>Number of rows in grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 1D NumPy array of interpolated odor values.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef get_odor_periodic_vectorized_numba(\n    xs: np.ndarray,\n    ys: np.ndarray,\n    odor_grid: np.ndarray,\n    x_min: float,\n    y_min: float,\n    resolution: float,\n    nx: int,\n    ny: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated bilinear interpolation for odor values with periodic boundaries.\n\n    Args:\n        xs (np.ndarray): 1D NumPy array of x coordinates.\n        ys (np.ndarray): 1D NumPy array of y coordinates.\n        odor_grid (np.ndarray): 2D NumPy array representing the odor grid.\n        x_min (float): Minimum x of the grid.\n        y_min (float): Minimum y of the grid.\n        resolution (float): Grid resolution.\n        nx (int): Number of columns in grid.\n        ny (int): Number of rows in grid.\n\n    Returns:\n        np.ndarray: 1D NumPy array of interpolated odor values.\n    \"\"\"\n    gx = (xs - x_min) / resolution\n    gy = (ys - y_min) / resolution\n    j = (np.floor(gx) % nx).astype(np.int32)\n    i = (np.floor(gy) % ny).astype(np.int32)\n    fi = gx - np.floor(gx)\n    fj = gy - np.floor(gy)\n    result = np.empty(xs.shape, dtype=odor_grid.dtype)\n    for idx in range(xs.size):\n        i1 = (i[idx] + 1) % ny\n        j1 = (j[idx] + 1) % nx\n        Q11 = odor_grid[i[idx], j[idx]]\n        Q21 = odor_grid[i[idx], j1]\n        Q12 = odor_grid[i1, j[idx]]\n        Q22 = odor_grid[i1, j1]\n        result[idx] = (\n            Q11 * (1 - fi[idx]) * (1 - fj[idx])\n            + Q21 * fi[idx] * (1 - fj[idx])\n            + Q12 * (1 - fi[idx]) * fj[idx]\n            + Q22 * fi[idx] * fj[idx]\n        )\n    return result\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.get_odor_vectorized_numba","title":"<code>get_odor_vectorized_numba(xs, ys, odor_grid, x_min, y_min, resolution, nx, ny)</code>","text":"<p>Numba-accelerated bilinear interpolation for odor values.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>1D NumPy array of y coordinates.</p> required <code>odor_grid</code> <code>ndarray</code> <p>2D NumPy array representing the odor grid.</p> required <code>x_min</code> <code>float</code> <p>Minimum x of the grid.</p> required <code>y_min</code> <code>float</code> <p>Minimum y of the grid.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution.</p> required <code>nx</code> <code>int</code> <p>Number of columns in grid.</p> required <code>ny</code> <code>int</code> <p>Number of rows in grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 1D NumPy array of interpolated odor values.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef get_odor_vectorized_numba(\n    xs: np.ndarray,\n    ys: np.ndarray,\n    odor_grid: np.ndarray,\n    x_min: float,\n    y_min: float,\n    resolution: float,\n    nx: int,\n    ny: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated bilinear interpolation for odor values.\n\n    Args:\n        xs (np.ndarray): 1D NumPy array of x coordinates.\n        ys (np.ndarray): 1D NumPy array of y coordinates.\n        odor_grid (np.ndarray): 2D NumPy array representing the odor grid.\n        x_min (float): Minimum x of the grid.\n        y_min (float): Minimum y of the grid.\n        resolution (float): Grid resolution.\n        nx (int): Number of columns in grid.\n        ny (int): Number of rows in grid.\n\n    Returns:\n        np.ndarray: 1D NumPy array of interpolated odor values.\n    \"\"\"\n    gx = (xs - x_min) / resolution\n    gy = (ys - y_min) / resolution\n    j = np.floor(gx).astype(np.int32)\n    i = np.floor(gy).astype(np.int32)\n    fi = gx - j\n    fj = gy - np.floor(gy)\n    # Clip indices for valid interpolation (assume grid has at least 2 cells in each dimension)\n    i = np.clip(i, 0, ny - 2)\n    j = np.clip(j, 0, nx - 2)\n    result = np.empty(xs.shape, dtype=odor_grid.dtype)\n    for idx in range(xs.size):\n        Q11 = odor_grid[i[idx], j[idx]]\n        Q21 = odor_grid[i[idx], j[idx] + 1]\n        Q12 = odor_grid[i[idx] + 1, j[idx]]\n        Q22 = odor_grid[i[idx] + 1, j[idx] + 1]\n        result[idx] = (\n            Q11 * (1 - fi[idx]) * (1 - fj[idx])\n            + Q21 * fi[idx] * (1 - fj[idx])\n            + Q12 * (1 - fi[idx]) * fj[idx]\n            + Q22 * fi[idx] * fj[idx]\n        )\n    return result\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.is_free_periodic_vectorized_numba","title":"<code>is_free_periodic_vectorized_numba(xs, ys, wall_mask, x_min, y_min, resolution, nx, ny)</code>","text":"<p>Numba-accelerated check of free space for multiple positions with periodic boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>1D array of y coordinates.</p> required <code>wall_mask</code> <code>ndarray</code> <p>2D boolean array indicating blocked cells.</p> required <code>x_min</code> <code>float</code> <p>Minimum x of the grid.</p> required <code>y_min</code> <code>float</code> <p>Minimum y of the grid.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution.</p> required <code>nx</code> <code>int</code> <p>Number of columns.</p> required <code>ny</code> <code>int</code> <p>Number of rows.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Boolean array (True if free).</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef is_free_periodic_vectorized_numba(\n    xs: np.ndarray,\n    ys: np.ndarray,\n    wall_mask: np.ndarray,\n    x_min: float,\n    y_min: float,\n    resolution: float,\n    nx: int,\n    ny: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated check of free space for multiple positions with periodic boundaries.\n\n    Args:\n        xs (np.ndarray): 1D array of x coordinates.\n        ys (np.ndarray): 1D array of y coordinates.\n        wall_mask (np.ndarray): 2D boolean array indicating blocked cells.\n        x_min (float): Minimum x of the grid.\n        y_min (float): Minimum y of the grid.\n        resolution (float): Grid resolution.\n        nx (int): Number of columns.\n        ny (int): Number of rows.\n\n    Returns:\n        np.ndarray: Boolean array (True if free).\n    \"\"\"\n    gx = (xs - x_min) / resolution\n    gy = (ys - y_min) / resolution\n    j = (np.floor(gx) % nx).astype(np.int32)\n    i = (np.floor(gy) % ny).astype(np.int32)\n    result = np.empty(xs.shape, dtype=np.bool_)\n    for idx in range(xs.size):\n        result[idx] = not wall_mask[i[idx], j[idx]]\n    return result\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.is_free_vectorized_numba","title":"<code>is_free_vectorized_numba(xs, ys, wall_mask, x_min, y_min, resolution, nx, ny)</code>","text":"<p>Numba-accelerated check of free space for multiple positions.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>1D array of y coordinates.</p> required <code>wall_mask</code> <code>ndarray</code> <p>2D boolean array indicating blocked cells.</p> required <code>x_min</code> <code>float</code> <p>Minimum x of the grid.</p> required <code>y_min</code> <code>float</code> <p>Minimum y of the grid.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution.</p> required <code>nx</code> <code>int</code> <p>Number of columns.</p> required <code>ny</code> <code>int</code> <p>Number of rows.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Boolean array (True if free).</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef is_free_vectorized_numba(\n    xs: np.ndarray,\n    ys: np.ndarray,\n    wall_mask: np.ndarray,\n    x_min: float,\n    y_min: float,\n    resolution: float,\n    nx: int,\n    ny: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated check of free space for multiple positions.\n\n    Args:\n        xs (np.ndarray): 1D array of x coordinates.\n        ys (np.ndarray): 1D array of y coordinates.\n        wall_mask (np.ndarray): 2D boolean array indicating blocked cells.\n        x_min (float): Minimum x of the grid.\n        y_min (float): Minimum y of the grid.\n        resolution (float): Grid resolution.\n        nx (int): Number of columns.\n        ny (int): Number of rows.\n\n    Returns:\n        np.ndarray: Boolean array (True if free).\n    \"\"\"\n    gx = (xs - x_min) / resolution\n    gy = (ys - y_min) / resolution\n    j = np.floor(gx).astype(np.int32)\n    i = np.floor(gy).astype(np.int32)\n    i = np.clip(i, 0, ny - 1)\n    j = np.clip(j, 0, nx - 1)\n    result = np.empty(xs.shape, dtype=np.bool_)\n    for idx in range(xs.size):\n        result[idx] = not wall_mask[i[idx], j[idx]]\n    return result\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.update_odor_periodic_vectorized_numba","title":"<code>update_odor_periodic_vectorized_numba(odor_grid, xs, ys, odors, x_min, y_min, resolution, nx, ny)</code>","text":"<p>Numba-accelerated update of the odor grid with periodic boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>odor_grid</code> <code>ndarray</code> <p>2D array representing the odor grid.</p> required <code>xs</code> <code>ndarray</code> <p>1D array of x deposit positions.</p> required <code>ys</code> <code>ndarray</code> <p>1D array of y deposit positions.</p> required <code>odors</code> <code>ndarray</code> <p>1D array of odor values to add.</p> required <code>x_min</code> <code>float</code> <p>Minimum x of the grid.</p> required <code>y_min</code> <code>float</code> <p>Minimum y of the grid.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution.</p> required <code>nx</code> <code>int</code> <p>Number of columns.</p> required <code>ny</code> <code>int</code> <p>Number of rows.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The updated odor grid.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef update_odor_periodic_vectorized_numba(\n    odor_grid: np.ndarray,\n    xs: np.ndarray,\n    ys: np.ndarray,\n    odors: np.ndarray,\n    x_min: float,\n    y_min: float,\n    resolution: float,\n    nx: int,\n    ny: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated update of the odor grid with periodic boundaries.\n\n    Args:\n        odor_grid (np.ndarray): 2D array representing the odor grid.\n        xs (np.ndarray): 1D array of x deposit positions.\n        ys (np.ndarray): 1D array of y deposit positions.\n        odors (np.ndarray): 1D array of odor values to add.\n        x_min (float): Minimum x of the grid.\n        y_min (float): Minimum y of the grid.\n        resolution (float): Grid resolution.\n        nx (int): Number of columns.\n        ny (int): Number of rows.\n\n    Returns:\n        np.ndarray: The updated odor grid.\n    \"\"\"\n    gx = (xs - x_min) / resolution\n    gy = (ys - y_min) / resolution\n    j = (np.floor(gx) % nx).astype(np.int32)\n    i = (np.floor(gy) % ny).astype(np.int32)\n    for idx in range(xs.size):\n        odor_grid[i[idx], j[idx]] += odors[idx]\n    return odor_grid\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.update_odor_vectorized_numba","title":"<code>update_odor_vectorized_numba(odor_grid, xs, ys, odors, x_min, y_min, resolution, nx, ny)</code>","text":"<p>Numba-accelerated update of the odor grid given multiple deposit positions.</p> <p>This function uses np.add.at to handle repeated indices.</p> <p>Parameters:</p> Name Type Description Default <code>odor_grid</code> <code>ndarray</code> <p>2D array representing the odor grid.</p> required <code>xs</code> <code>ndarray</code> <p>1D array of x deposit positions.</p> required <code>ys</code> <code>ndarray</code> <p>1D array of y deposit positions.</p> required <code>odors</code> <code>ndarray</code> <p>1D array of odor values to add.</p> required <code>x_min</code> <code>float</code> <p>Minimum x of the grid.</p> required <code>y_min</code> <code>float</code> <p>Minimum y of the grid.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution.</p> required <code>nx</code> <code>int</code> <p>Number of columns.</p> required <code>ny</code> <code>int</code> <p>Number of rows.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The updated odor grid.</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef update_odor_vectorized_numba(\n    odor_grid: np.ndarray,\n    xs: np.ndarray,\n    ys: np.ndarray,\n    odors: np.ndarray,\n    x_min: float,\n    y_min: float,\n    resolution: float,\n    nx: int,\n    ny: int,\n) -&gt; np.ndarray:\n    \"\"\"\n    Numba-accelerated update of the odor grid given multiple deposit positions.\n\n    This function uses np.add.at to handle repeated indices.\n\n    Args:\n        odor_grid (np.ndarray): 2D array representing the odor grid.\n        xs (np.ndarray): 1D array of x deposit positions.\n        ys (np.ndarray): 1D array of y deposit positions.\n        odors (np.ndarray): 1D array of odor values to add.\n        x_min (float): Minimum x of the grid.\n        y_min (float): Minimum y of the grid.\n        resolution (float): Grid resolution.\n        nx (int): Number of columns.\n        ny (int): Number of rows.\n\n    Returns:\n        np.ndarray: The updated odor grid.\n    \"\"\"\n    gx = (xs - x_min) / resolution\n    gy = (ys - y_min) / resolution\n    j = np.floor(gx).astype(np.int32)\n    i = np.floor(gy).astype(np.int32)\n    i = np.clip(i, 0, ny - 1)\n    j = np.clip(j, 0, nx - 1)\n\n    # Flatten indices for add.at\n    flat_indices = i * nx + j\n    odor_flat = odor_grid.ravel()\n    # Numba doesn't support np.add.at directly in nopython mode efficiently for this case usually,\n    # but let's check if we can use a loop.\n    # Actually, for a simple loop:\n    for idx in range(xs.size):\n        odor_grid[i[idx], j[idx]] += odors[idx]\n\n    return odor_grid\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.world_to_grid_periodic_vectorized_numba","title":"<code>world_to_grid_periodic_vectorized_numba(xs, ys, x_min, y_min, resolution, nx, ny)</code>","text":"<p>Numba-accelerated conversion of world coordinates to grid indices and fractional parts.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>1D NumPy array of y coordinates.</p> required <code>x_min</code> <code>float</code> <p>Minimum x of the grid.</p> required <code>y_min</code> <code>float</code> <p>Minimum y of the grid.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution.</p> required <code>nx</code> <code>int</code> <p>Number of columns in grid.</p> required <code>ny</code> <code>int</code> <p>Number of rows in grid.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Tuple of 1D NumPy arrays (i, j, fi, fj).</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef world_to_grid_periodic_vectorized_numba(\n    xs: np.ndarray,\n    ys: np.ndarray,\n    x_min: float,\n    y_min: float,\n    resolution: float,\n    nx: int,\n    ny: int,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Numba-accelerated conversion of world coordinates to grid indices and fractional parts.\n\n    Args:\n        xs (np.ndarray): 1D NumPy array of x coordinates.\n        ys (np.ndarray): 1D NumPy array of y coordinates.\n        x_min (float): Minimum x of the grid.\n        y_min (float): Minimum y of the grid.\n        resolution (float): Grid resolution.\n        nx (int): Number of columns in grid.\n        ny (int): Number of rows in grid.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Tuple of 1D NumPy\n            arrays (i, j, fi, fj).\n    \"\"\"\n    gx = (xs - x_min) / resolution\n    gy = (ys - y_min) / resolution\n    j = (np.floor(gx) % nx).astype(np.int32)\n    i = (np.floor(gy) % ny).astype(np.int32)\n    fi = gx - np.floor(gx)\n    fj = gy - np.floor(gy)\n    return i, j, fi, fj\n</code></pre>"},{"location":"api/sim/arena/#arthroscape.sim.arena.world_to_grid_vectorized_numba","title":"<code>world_to_grid_vectorized_numba(xs, ys, x_min, y_min, resolution, nx, ny)</code>","text":"<p>Numba-accelerated conversion of world coordinates to grid indices and fractional parts.</p> <p>Parameters:</p> Name Type Description Default <code>xs</code> <code>ndarray</code> <p>1D NumPy array of x coordinates.</p> required <code>ys</code> <code>ndarray</code> <p>1D NumPy array of y coordinates.</p> required <code>x_min</code> <code>float</code> <p>Minimum x of the grid.</p> required <code>y_min</code> <code>float</code> <p>Minimum y of the grid.</p> required <code>resolution</code> <code>float</code> <p>Grid resolution.</p> required <code>nx</code> <code>int</code> <p>Number of columns in grid.</p> required <code>ny</code> <code>int</code> <p>Number of rows in grid.</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray, ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Tuple of 1D NumPy arrays (i, j, fi, fj).</p> Source code in <code>arthroscape/sim/arena.py</code> <pre><code>@njit\ndef world_to_grid_vectorized_numba(\n    xs: np.ndarray,\n    ys: np.ndarray,\n    x_min: float,\n    y_min: float,\n    resolution: float,\n    nx: int,\n    ny: int,\n) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Numba-accelerated conversion of world coordinates to grid indices and fractional parts.\n\n    Args:\n        xs (np.ndarray): 1D NumPy array of x coordinates.\n        ys (np.ndarray): 1D NumPy array of y coordinates.\n        x_min (float): Minimum x of the grid.\n        y_min (float): Minimum y of the grid.\n        resolution (float): Grid resolution.\n        nx (int): Number of columns in grid.\n        ny (int): Number of rows in grid.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]: Tuple of 1D NumPy arrays (i, j, fi, fj).\n    \"\"\"\n    gx = (xs - x_min) / resolution\n    gy = (ys - y_min) / resolution\n    j = np.floor(gx).astype(np.int32)\n    i = np.floor(gy).astype(np.int32)\n    fi = gx - j\n    fj = gy - np.floor(gy)\n    return i, j, fi, fj\n</code></pre>"},{"location":"api/sim/behavior/","title":"Behavior","text":""},{"location":"api/sim/behavior/#arthroscape.sim.behavior","title":"<code>arthroscape.sim.behavior</code>","text":"<p>Behavior module for the ArthroScape simulation.</p> <p>This module defines the <code>BehaviorAlgorithm</code> abstract base class and its concrete implementation <code>DefaultBehavior</code>. These classes determine how agents update their state (stop/walk) and heading based on sensory inputs (odor) and internal parameters.</p>"},{"location":"api/sim/behavior/#arthroscape.sim.behavior.BehaviorAlgorithm","title":"<code>BehaviorAlgorithm</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for behavioral algorithms.</p> <p>A behavior algorithm defines how an agent transitions between states (e.g., stop vs. walk) and how it updates its heading based on sensory input and environmental context.</p> Source code in <code>arthroscape/sim/behavior.py</code> <pre><code>class BehaviorAlgorithm(ABC):\n    \"\"\"\n    Abstract base class for behavioral algorithms.\n\n    A behavior algorithm defines how an agent transitions between states (e.g., stop vs. walk)\n    and how it updates its heading based on sensory input and environmental context.\n    \"\"\"\n\n    @abstractmethod\n    def update_state(\n        self, prev_state: int, config: SimulationConfig, rng: np.random.Generator\n    ) -&gt; int:\n        \"\"\"\n        Update the agent's state (e.g., 0 for stop, 1 for walk).\n\n        Args:\n            prev_state (int): The current state of the agent.\n            config (SimulationConfig): The simulation configuration.\n            rng (np.random.Generator): Random number generator.\n\n        Returns:\n            int: The new state of the agent.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update_heading(\n        self,\n        prev_heading: float,\n        odor_left: float,\n        odor_right: float,\n        at_wall: bool,\n        config: SimulationConfig,\n        rng: np.random.Generator,\n    ) -&gt; float:\n        \"\"\"\n        Update the agent's heading.\n\n        Args:\n            prev_heading (float): The current heading in radians.\n            odor_left (float): Perceived odor concentration on the left antenna.\n            odor_right (float): Perceived odor concentration on the right antenna.\n            at_wall (bool): True if the agent is currently at a wall/obstacle.\n            config (SimulationConfig): The simulation configuration.\n            rng (np.random.Generator): Random number generator.\n\n        Returns:\n            float: The new heading in radians.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sim/behavior/#arthroscape.sim.behavior.BehaviorAlgorithm.update_heading","title":"<code>update_heading(prev_heading, odor_left, odor_right, at_wall, config, rng)</code>  <code>abstractmethod</code>","text":"<p>Update the agent's heading.</p> <p>Parameters:</p> Name Type Description Default <code>prev_heading</code> <code>float</code> <p>The current heading in radians.</p> required <code>odor_left</code> <code>float</code> <p>Perceived odor concentration on the left antenna.</p> required <code>odor_right</code> <code>float</code> <p>Perceived odor concentration on the right antenna.</p> required <code>at_wall</code> <code>bool</code> <p>True if the agent is currently at a wall/obstacle.</p> required <code>config</code> <code>SimulationConfig</code> <p>The simulation configuration.</p> required <code>rng</code> <code>Generator</code> <p>Random number generator.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The new heading in radians.</p> Source code in <code>arthroscape/sim/behavior.py</code> <pre><code>@abstractmethod\ndef update_heading(\n    self,\n    prev_heading: float,\n    odor_left: float,\n    odor_right: float,\n    at_wall: bool,\n    config: SimulationConfig,\n    rng: np.random.Generator,\n) -&gt; float:\n    \"\"\"\n    Update the agent's heading.\n\n    Args:\n        prev_heading (float): The current heading in radians.\n        odor_left (float): Perceived odor concentration on the left antenna.\n        odor_right (float): Perceived odor concentration on the right antenna.\n        at_wall (bool): True if the agent is currently at a wall/obstacle.\n        config (SimulationConfig): The simulation configuration.\n        rng (np.random.Generator): Random number generator.\n\n    Returns:\n        float: The new heading in radians.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/behavior/#arthroscape.sim.behavior.BehaviorAlgorithm.update_state","title":"<code>update_state(prev_state, config, rng)</code>  <code>abstractmethod</code>","text":"<p>Update the agent's state (e.g., 0 for stop, 1 for walk).</p> <p>Parameters:</p> Name Type Description Default <code>prev_state</code> <code>int</code> <p>The current state of the agent.</p> required <code>config</code> <code>SimulationConfig</code> <p>The simulation configuration.</p> required <code>rng</code> <code>Generator</code> <p>Random number generator.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The new state of the agent.</p> Source code in <code>arthroscape/sim/behavior.py</code> <pre><code>@abstractmethod\ndef update_state(\n    self, prev_state: int, config: SimulationConfig, rng: np.random.Generator\n) -&gt; int:\n    \"\"\"\n    Update the agent's state (e.g., 0 for stop, 1 for walk).\n\n    Args:\n        prev_state (int): The current state of the agent.\n        config (SimulationConfig): The simulation configuration.\n        rng (np.random.Generator): Random number generator.\n\n    Returns:\n        int: The new state of the agent.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/behavior/#arthroscape.sim.behavior.DefaultBehavior","title":"<code>DefaultBehavior</code>","text":"<p>               Bases: <code>BehaviorAlgorithm</code></p> <p>Default implementation of the behavioral algorithm.</p> <p>This behavior models: 1.  Stochastic transitions between stop (0) and walk (1) states. 2.  Heading updates driven by odor asymmetry (chemotaxis), random diffusion, and wall avoidance. 3.  Directional persistence to smooth out turns.</p> Source code in <code>arthroscape/sim/behavior.py</code> <pre><code>class DefaultBehavior(BehaviorAlgorithm):\n    \"\"\"\n    Default implementation of the behavioral algorithm.\n\n    This behavior models:\n    1.  Stochastic transitions between stop (0) and walk (1) states.\n    2.  Heading updates driven by odor asymmetry (chemotaxis), random diffusion, and wall avoidance.\n    3.  Directional persistence to smooth out turns.\n    \"\"\"\n\n    def update_state(\n        self, prev_state: int, config: SimulationConfig, rng: np.random.Generator\n    ) -&gt; int:\n        \"\"\"\n        Update the agent's state based on transition probabilities defined in the config.\n\n        Args:\n            prev_state (int): The current state (0: stop, 1: walk).\n            config (SimulationConfig): Simulation configuration containing transition rates.\n            rng (np.random.Generator): Random number generator.\n\n        Returns:\n            int: The new state (0 or 1).\n        \"\"\"\n        if prev_state == 0:\n            return 1 if rng.random() &lt; config.rate_stop_to_walk_per_frame else 0\n        else:\n            return 0 if rng.random() &lt; config.rate_walk_to_stop_per_frame else 1\n\n    def update_heading(\n        self,\n        prev_heading: float,\n        odor_left: float,\n        odor_right: float,\n        at_wall: bool,\n        config: SimulationConfig,\n        rng: np.random.Generator,\n    ) -&gt; float:\n        \"\"\"\n        Update the agent's heading based on odor gradients and random fluctuations.\n\n        The logic includes:\n        - Determining turn direction based on odor gradient (left vs. right).\n        - Applying an error rate to occasionally turn against the gradient.\n        - Turning if at a wall.\n        - Turning probabilistically based on base turn rate and odor asymmetry.\n        - Adding rotational diffusion (noise).\n        - Applying directional persistence.\n\n        Args:\n            prev_heading (float): Current heading in radians.\n            odor_left (float): Odor concentration at left sensor.\n            odor_right (float): Odor concentration at right sensor.\n            at_wall (bool): Whether the agent is colliding with a wall.\n            config (SimulationConfig): Simulation configuration.\n            rng (np.random.Generator): Random number generator.\n\n        Returns:\n            float: The updated heading in radians.\n        \"\"\"\n        # if odor is close to zero, set it to zero\n        if abs(odor_left) &lt; 1e-6:\n            odor_left = 0\n        if abs(odor_right) &lt; 1e-6:\n            odor_right = 0\n        turn_direction = (\n            1\n            if odor_left &gt; odor_right\n            else (-1 if odor_left &lt; odor_right else rng.choice([-1, 1]))\n        )\n        # flip based on error rate\n        if rng.random() &lt; config.error_rate_per_frame:\n            turn_direction *= -1\n        if at_wall:\n            turn_angle = config.turn_angle_sampler()\n            new_heading = (\n                prev_heading\n                + turn_direction * turn_angle\n                + rng.normal(0, config.rotation_diffusion)\n            )\n        elif rng.random() &lt; (\n            config.turn_rate_per_frame\n            + abs(odor_left - odor_right) * config.asymmetry_factor_per_frame\n        ):\n            turn_angle = config.turn_angle_sampler() * (\n                1 + config.odor_driven_turn_scaler * (odor_left + odor_right) / 2\n            )\n            new_heading = (\n                prev_heading\n                + turn_direction * turn_angle\n                + rng.normal(0, config.rotation_diffusion)\n            )\n        else:\n            new_heading = prev_heading + rng.normal(0, config.rotation_diffusion)\n\n        # Now adjust the heading using the persistence strategy.\n        adjusted_heading = config.directional_persistence_strategy.adjust_heading(\n            prev_heading, new_heading, odor_left, odor_right, config, rng\n        )\n        return adjusted_heading\n</code></pre>"},{"location":"api/sim/behavior/#arthroscape.sim.behavior.DefaultBehavior.update_heading","title":"<code>update_heading(prev_heading, odor_left, odor_right, at_wall, config, rng)</code>","text":"<p>Update the agent's heading based on odor gradients and random fluctuations.</p> <p>The logic includes: - Determining turn direction based on odor gradient (left vs. right). - Applying an error rate to occasionally turn against the gradient. - Turning if at a wall. - Turning probabilistically based on base turn rate and odor asymmetry. - Adding rotational diffusion (noise). - Applying directional persistence.</p> <p>Parameters:</p> Name Type Description Default <code>prev_heading</code> <code>float</code> <p>Current heading in radians.</p> required <code>odor_left</code> <code>float</code> <p>Odor concentration at left sensor.</p> required <code>odor_right</code> <code>float</code> <p>Odor concentration at right sensor.</p> required <code>at_wall</code> <code>bool</code> <p>Whether the agent is colliding with a wall.</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <code>rng</code> <code>Generator</code> <p>Random number generator.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The updated heading in radians.</p> Source code in <code>arthroscape/sim/behavior.py</code> <pre><code>def update_heading(\n    self,\n    prev_heading: float,\n    odor_left: float,\n    odor_right: float,\n    at_wall: bool,\n    config: SimulationConfig,\n    rng: np.random.Generator,\n) -&gt; float:\n    \"\"\"\n    Update the agent's heading based on odor gradients and random fluctuations.\n\n    The logic includes:\n    - Determining turn direction based on odor gradient (left vs. right).\n    - Applying an error rate to occasionally turn against the gradient.\n    - Turning if at a wall.\n    - Turning probabilistically based on base turn rate and odor asymmetry.\n    - Adding rotational diffusion (noise).\n    - Applying directional persistence.\n\n    Args:\n        prev_heading (float): Current heading in radians.\n        odor_left (float): Odor concentration at left sensor.\n        odor_right (float): Odor concentration at right sensor.\n        at_wall (bool): Whether the agent is colliding with a wall.\n        config (SimulationConfig): Simulation configuration.\n        rng (np.random.Generator): Random number generator.\n\n    Returns:\n        float: The updated heading in radians.\n    \"\"\"\n    # if odor is close to zero, set it to zero\n    if abs(odor_left) &lt; 1e-6:\n        odor_left = 0\n    if abs(odor_right) &lt; 1e-6:\n        odor_right = 0\n    turn_direction = (\n        1\n        if odor_left &gt; odor_right\n        else (-1 if odor_left &lt; odor_right else rng.choice([-1, 1]))\n    )\n    # flip based on error rate\n    if rng.random() &lt; config.error_rate_per_frame:\n        turn_direction *= -1\n    if at_wall:\n        turn_angle = config.turn_angle_sampler()\n        new_heading = (\n            prev_heading\n            + turn_direction * turn_angle\n            + rng.normal(0, config.rotation_diffusion)\n        )\n    elif rng.random() &lt; (\n        config.turn_rate_per_frame\n        + abs(odor_left - odor_right) * config.asymmetry_factor_per_frame\n    ):\n        turn_angle = config.turn_angle_sampler() * (\n            1 + config.odor_driven_turn_scaler * (odor_left + odor_right) / 2\n        )\n        new_heading = (\n            prev_heading\n            + turn_direction * turn_angle\n            + rng.normal(0, config.rotation_diffusion)\n        )\n    else:\n        new_heading = prev_heading + rng.normal(0, config.rotation_diffusion)\n\n    # Now adjust the heading using the persistence strategy.\n    adjusted_heading = config.directional_persistence_strategy.adjust_heading(\n        prev_heading, new_heading, odor_left, odor_right, config, rng\n    )\n    return adjusted_heading\n</code></pre>"},{"location":"api/sim/behavior/#arthroscape.sim.behavior.DefaultBehavior.update_state","title":"<code>update_state(prev_state, config, rng)</code>","text":"<p>Update the agent's state based on transition probabilities defined in the config.</p> <p>Parameters:</p> Name Type Description Default <code>prev_state</code> <code>int</code> <p>The current state (0: stop, 1: walk).</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration containing transition rates.</p> required <code>rng</code> <code>Generator</code> <p>Random number generator.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The new state (0 or 1).</p> Source code in <code>arthroscape/sim/behavior.py</code> <pre><code>def update_state(\n    self, prev_state: int, config: SimulationConfig, rng: np.random.Generator\n) -&gt; int:\n    \"\"\"\n    Update the agent's state based on transition probabilities defined in the config.\n\n    Args:\n        prev_state (int): The current state (0: stop, 1: walk).\n        config (SimulationConfig): Simulation configuration containing transition rates.\n        rng (np.random.Generator): Random number generator.\n\n    Returns:\n        int: The new state (0 or 1).\n    \"\"\"\n    if prev_state == 0:\n        return 1 if rng.random() &lt; config.rate_stop_to_walk_per_frame else 0\n    else:\n        return 0 if rng.random() &lt; config.rate_walk_to_stop_per_frame else 1\n</code></pre>"},{"location":"api/sim/config/","title":"Configuration","text":""},{"location":"api/sim/config/#arthroscape.sim.config","title":"<code>arthroscape.sim.config</code>","text":"<p>Configuration module for the ArthroScape simulation.</p> <p>This module defines the <code>SimulationConfig</code> dataclass, which holds all parameters controlling the simulation environment, agent behavior, odor dynamics, and more. It also provides helper functions for sampling initial conditions and movement parameters.</p>"},{"location":"api/sim/config/#arthroscape.sim.config.SimulationConfig","title":"<code>SimulationConfig</code>  <code>dataclass</code>","text":"<p>Configuration class for the ArthroScape simulation.</p> <p>This dataclass contains all the parameters required to set up and run a simulation, including time settings, agent motion parameters, behavioral rules, odor perception settings, and arena properties.</p> <p>Attributes:</p> Name Type Description <code>T</code> <code>float</code> <p>Total simulation time in seconds. Default is 900 (15 minutes).</p> <code>fps</code> <code>float</code> <p>Frames per second for the simulation. Default is 60.</p> <code>walking_speed</code> <code>float</code> <p>Walking speed of the agent in mm/s. Default is 15.</p> <code>rotation_diffusion</code> <code>float</code> <p>Rotational diffusion (random noise in heading) in radians per frame. Default is ~0.22 degrees.</p> <code>walking_speed_sampler</code> <code>Callable[[], float]</code> <p>Optional callable that returns a walking speed at each step.</p> <code>turn_rate</code> <code>float</code> <p>Base turning rate in Hz (turns per second). Default is 1.0.</p> <code>asymmetry_factor</code> <code>float</code> <p>Factor that increases turn rate based on odor asymmetry. Default is 10.</p> <code>error_rate</code> <code>float</code> <p>Probability (per second) of turning in the wrong direction (against the gradient). Default is 0.</p> <code>odor_driven_turn_scaler</code> <code>float</code> <p>Factor that scales the turn angle based on odor asymmetry. Default is 0.0.</p> <code>turn_magnitude_range</code> <code>Tuple[float, float]</code> <p>Range (min, max) of turn angles in radians. Default is (8 deg, 30 deg).</p> <code>turn_angle_sampler</code> <code>Callable[[], float]</code> <p>Optional callable that returns a turn angle.</p> <code>rate_stop_to_walk</code> <code>float</code> <p>Rate (Hz) of transition from stop to walk state. Default is 0.5.</p> <code>rate_walk_to_stop</code> <code>float</code> <p>Rate (Hz) of transition from walk to stop state. Default is 0.05.</p> <code>antenna_left_offset</code> <code>Tuple[float, float]</code> <p>Position of the left antenna relative to body center (dx, dy) in mm.</p> <code>antenna_right_offset</code> <code>Tuple[float, float]</code> <p>Position of the right antenna relative to body center (dx, dy) in mm.</p> <code>odor_perception_factory</code> <code>Callable[[], AgentOdorPerception]</code> <p>Factory function to create odor perception objects.</p> <code>deposit_sigma</code> <code>float</code> <p>Standard deviation (mm) for the Gaussian odor deposit. Default is 1.0.</p> <code>deposit_kernel_factor</code> <code>float</code> <p>Number of sigmas to cover in the deposit kernel. Default is 3.0.</p> <code>deposit_kernel_size</code> <code>int</code> <p>Size of the deposit kernel (computed automatically).</p> <code>odor_deposit_offsets</code> <code>Sequence[Tuple[float, float]]</code> <p>List of offsets (dx, dy) for odor deposition relative to body center.</p> <code>clamp_odor_mask</code> <code>bool</code> <p>If True, wall/odor mask cells are clamped. Default is False.</p> <code>diffusion_coefficient</code> <code>float</code> <p>Diffusion coefficient for odor in mm^2/s. Default is 0.0.</p> <code>odor_decay_tau</code> <code>float</code> <p>Time constant for odor decay in seconds. Default is infinity (no decay).</p> <code>odor_decay_rate</code> <code>float</code> <p>Decay rate per frame (computed automatically).</p> <code>grid_x_min</code> <code>float</code> <p>Minimum x-coordinate of the arena grid. Default is -80.0.</p> <code>grid_x_max</code> <code>float</code> <p>Maximum x-coordinate of the arena grid. Default is 80.0.</p> <code>grid_y_min</code> <code>float</code> <p>Minimum y-coordinate of the arena grid. Default is -80.0.</p> <code>grid_y_max</code> <code>float</code> <p>Maximum y-coordinate of the arena grid. Default is 80.0.</p> <code>grid_resolution</code> <code>float</code> <p>Resolution of the grid in mm per cell. Default is 0.1.</p> <code>record_odor_history</code> <code>bool</code> <p>If True, records the history of the odor grid. Default is False.</p> <code>odor_history_time_interval</code> <code>int</code> <p>Interval in seconds between odor history snapshots. Default is 1.</p> <code>odor_history_interval_frames</code> <code>int</code> <p>Interval in frames between odor history snapshots (computed automatically).</p> <code>number_of_animals</code> <code>int</code> <p>Number of agents in the simulation. Default is 1.</p> <code>initial_position_sampler</code> <code>Callable[[], Tuple[float, float]]</code> <p>Callable to sample initial positions.</p> <code>initial_heading_sampler</code> <code>Callable[[], float]</code> <p>Callable to sample initial headings.</p> <code>directional_persistence_strategy</code> <code>DirectionalPersistenceStrategy</code> <p>Strategy for directional persistence.</p> <code>turn_rate_per_frame</code> <code>float</code> <p>Turn probability per frame (computed).</p> <code>asymmetry_factor_per_frame</code> <code>float</code> <p>Asymmetry factor per frame (computed).</p> <code>rate_stop_to_walk_per_frame</code> <code>float</code> <p>Stop-to-walk probability per frame (computed).</p> <code>rate_walk_to_stop_per_frame</code> <code>float</code> <p>Walk-to-stop probability per frame (computed).</p> <code>total_frames</code> <code>int</code> <p>Total number of simulation frames (computed).</p> Source code in <code>arthroscape/sim/config.py</code> <pre><code>@dataclass\nclass SimulationConfig:\n    \"\"\"\n    Configuration class for the ArthroScape simulation.\n\n    This dataclass contains all the parameters required to set up and run a simulation,\n    including time settings, agent motion parameters, behavioral rules, odor perception\n    settings, and arena properties.\n\n    Attributes:\n        T (float): Total simulation time in seconds. Default is 900 (15 minutes).\n        fps (float): Frames per second for the simulation. Default is 60.\n        walking_speed (float): Walking speed of the agent in mm/s. Default is 15.\n        rotation_diffusion (float): Rotational diffusion (random noise in heading) in radians per frame. Default is ~0.22 degrees.\n        walking_speed_sampler (Callable[[], float]): Optional callable that returns a walking speed at each step.\n        turn_rate (float): Base turning rate in Hz (turns per second). Default is 1.0.\n        asymmetry_factor (float): Factor that increases turn rate based on odor asymmetry. Default is 10.\n        error_rate (float): Probability (per second) of turning in the wrong direction (against the gradient). Default is 0.\n        odor_driven_turn_scaler (float): Factor that scales the turn angle based on odor asymmetry. Default is 0.0.\n        turn_magnitude_range (Tuple[float, float]): Range (min, max) of turn angles in radians. Default is (8 deg, 30 deg).\n        turn_angle_sampler (Callable[[], float]): Optional callable that returns a turn angle.\n        rate_stop_to_walk (float): Rate (Hz) of transition from stop to walk state. Default is 0.5.\n        rate_walk_to_stop (float): Rate (Hz) of transition from walk to stop state. Default is 0.05.\n        antenna_left_offset (Tuple[float, float]): Position of the left antenna relative to body center (dx, dy) in mm.\n        antenna_right_offset (Tuple[float, float]): Position of the right antenna relative to body center (dx, dy) in mm.\n        odor_perception_factory (Callable[[], AgentOdorPerception]): Factory function to create odor perception objects.\n        deposit_sigma (float): Standard deviation (mm) for the Gaussian odor deposit. Default is 1.0.\n        deposit_kernel_factor (float): Number of sigmas to cover in the deposit kernel. Default is 3.0.\n        deposit_kernel_size (int): Size of the deposit kernel (computed automatically).\n        odor_deposit_offsets (Sequence[Tuple[float, float]]): List of offsets (dx, dy) for odor deposition relative to body center.\n        clamp_odor_mask (bool): If True, wall/odor mask cells are clamped. Default is False.\n        diffusion_coefficient (float): Diffusion coefficient for odor in mm^2/s. Default is 0.0.\n        odor_decay_tau (float): Time constant for odor decay in seconds. Default is infinity (no decay).\n        odor_decay_rate (float): Decay rate per frame (computed automatically).\n        grid_x_min (float): Minimum x-coordinate of the arena grid. Default is -80.0.\n        grid_x_max (float): Maximum x-coordinate of the arena grid. Default is 80.0.\n        grid_y_min (float): Minimum y-coordinate of the arena grid. Default is -80.0.\n        grid_y_max (float): Maximum y-coordinate of the arena grid. Default is 80.0.\n        grid_resolution (float): Resolution of the grid in mm per cell. Default is 0.1.\n        record_odor_history (bool): If True, records the history of the odor grid. Default is False.\n        odor_history_time_interval (int): Interval in seconds between odor history snapshots. Default is 1.\n        odor_history_interval_frames (int): Interval in frames between odor history snapshots (computed automatically).\n        number_of_animals (int): Number of agents in the simulation. Default is 1.\n        initial_position_sampler (Callable[[], Tuple[float, float]]): Callable to sample initial positions.\n        initial_heading_sampler (Callable[[], float]): Callable to sample initial headings.\n        directional_persistence_strategy (DirectionalPersistenceStrategy): Strategy for directional persistence.\n        turn_rate_per_frame (float): Turn probability per frame (computed).\n        asymmetry_factor_per_frame (float): Asymmetry factor per frame (computed).\n        rate_stop_to_walk_per_frame (float): Stop-to-walk probability per frame (computed).\n        rate_walk_to_stop_per_frame (float): Walk-to-stop probability per frame (computed).\n        total_frames (int): Total number of simulation frames (computed).\n    \"\"\"\n\n    # Simulation parameters\n    T: float = 60 * 15  # Total simulation time in seconds\n    fps: float = 60  # Frames per second\n\n    # Motion parameters\n    walking_speed: float = 15  # mm/s when walking\n    rotation_diffusion: float = np.deg2rad(0.22)  # radians per frame\n    # Optional sampler for walking speed; if provided, this callable returns a speed at each step.\n    walking_speed_sampler: Callable[[], float] = None\n\n    # Behavioral algorithm parameters (per second)\n    turn_rate: float = 1.0  # Hz, base turning rate\n    asymmetry_factor: float = 250  # Increases turn rate when odor asymmetry is high\n    error_rate: float = 0  # Hz, Probability of turning in the wrong direction\n    odor_driven_turn_scaler: float = (\n        0.0  # Increases the turn angle based on odor asymmetry\n    )\n    turn_magnitude_range: Tuple[float, float] = (\n        np.deg2rad(8),\n        np.deg2rad(30),\n    )  # radians\n    # Optional sampler for turn angle (if desired)\n    turn_angle_sampler: Callable[[], float] = None\n\n    # State transition rates (per second)\n    rate_stop_to_walk: float = 0.5  # Hz, from stop to walking\n    rate_walk_to_stop: float = 0.05  # Hz, from walking to stop\n\n    # Odor sensing parameters\n    # Antenna offsets in the fly's body frame (dx, dy) in mm.\n    antenna_left_offset: Tuple[float, float] = (1.5, 0.125)  # shifted forward &amp; left\n    antenna_right_offset: Tuple[float, float] = (1.5, -0.125)  # shifted forward &amp; right\n\n    # Odor perception parameters\n    odor_perception_factory: Callable[[], AgentOdorPerception] = field(\n        default_factory=lambda: NoAdaptationPerception\n        # default_factory=lambda: functools.partial(LowPassPerception, tau=0.05)  # 50 ms\n        # default_factory=lambda: functools.partial(LeakAdaptationPerception, odor_integration_tau=0.02, adaptation_tau=0.1, adaptation_magnitude=2.0)\n        # default_factory=lambda: functools.partial(AblatedLeakAdaptationPerception, odor_integration_tau=0.02, adaptation_tau=0.1, adaptation_magnitude=2.0, direction='left')\n        # default_factory=lambda: functools.partial(AblatedPerception, direction='left')\n    )\n\n    # Odor deposition kernel parameters\n    deposit_sigma: float = 1.0  # Standard deviation (in mm) for the Gaussian deposit\n    deposit_kernel_factor: float = 3.0  # How many sigma to cover on each side\n    deposit_kernel_size: int = field(init=False)  # Computed automatically\n\n    # Odor deposition offsets (relative to the fly's centroid)\n    odor_deposit_offsets: Sequence[Tuple[float, float]] = (\n        (-1.5, 0),\n    )  # e.g. deposit behind the fly\n\n    # Odor mask clamping parameters.\n    clamp_odor_mask: bool = False  # If True, wall/odor mask cells are clamped.\n\n    # Dynamic odor field parameters\n    diffusion_coefficient: float = 0.0  # Diffusion coefficient (in mm^2/s)\n    odor_decay_tau: float = np.inf  # Decay time constant in seconds\n    odor_decay_rate: float = field(init=False)  # per frame\n\n    # Grid arena parameters\n    grid_x_min: float = -80.0\n    grid_x_max: float = 80.0\n    grid_y_min: float = -80.0\n    grid_y_max: float = 80.0\n    grid_resolution: float = 0.1  # mm per grid cell\n\n    # Odor history recording parameters\n    record_odor_history: bool = False  # Set True to record odor grid history\n    odor_history_time_interval: int = 1  # seconds between history snapshots\n    odor_history_interval_frames: int = field(init=False)  # Computed automatically\n\n    # Number of animals\n    number_of_animals: int = 1\n\n    # Initial position sampler.\n    # A callable that returns a tuple (x, y). If None, defaults to a normal distribution. with mean at (0, 0) and std grid_width/5\n    initial_position_sampler: Callable[[], Tuple[float, float]] = None\n\n    # Initial heading sampler.\n    # A callable that returns a heading angle in radians. If None, defaults to a uniform sampler.\n    initial_heading_sampler: Callable[[], float] = None\n\n    # New: Directional persistence strategy (if None, default fixed blend is used).\n    directional_persistence_strategy: DirectionalPersistenceStrategy = None\n\n    # Derived parameters\n    turn_rate_per_frame: float = field(init=False)  # probability per frame\n    asymmetry_factor_per_frame: float = field(init=False)  # probability per frame\n    rate_stop_to_walk_per_frame: float = field(init=False)  # probability per frame\n    rate_walk_to_stop_per_frame: float = field(init=False)  # probability per frame\n    total_frames: int = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"\n        Post-initialization processing.\n\n        This method initializes samplers if they are not provided and computes\n        derived parameters such as per-frame rates and kernel sizes.\n        \"\"\"\n        if self.walking_speed_sampler is None:\n            self.walking_speed_sampler = get_walking_speed_sampler(self.walking_speed)\n        if self.turn_angle_sampler is None:\n            low, high = self.turn_magnitude_range\n            self.turn_angle_sampler = get_turn_angle_sampler(low, high)\n        if self.initial_position_sampler is None:\n            self.initial_position_sampler = get_initial_position_sampler(\n                self.grid_x_min, self.grid_x_max, self.grid_y_min, self.grid_y_max\n            )\n        if self.initial_heading_sampler is None:\n            self.initial_heading_sampler = get_initial_heading_sampler()\n\n        # Compute derived parameters\n        self.odor_history_interval_frames = int(\n            self.odor_history_time_interval * self.fps\n        )\n\n        self.turn_rate_per_frame = self.turn_rate / self.fps\n        self.asymmetry_factor_per_frame = self.asymmetry_factor / self.fps\n        self.rate_stop_to_walk_per_frame = self.rate_stop_to_walk / self.fps\n        self.rate_walk_to_stop_per_frame = self.rate_walk_to_stop / self.fps\n        self.total_frames = int(self.T * self.fps)\n\n        self.error_rate_per_frame = self.error_rate / self.fps\n\n        # Compute kernel size from sigma and deposit_kernel_factor (round up to an odd integer)\n        size = (\n            int(\n                2\n                * np.ceil(\n                    self.deposit_kernel_factor\n                    * self.deposit_sigma\n                    / self.grid_resolution\n                )\n            )\n            + 1\n        )\n        self.deposit_kernel_size = size\n\n        # Compute odor decay rate per frame from the time constant\n        if self.odor_decay_tau == np.inf:\n            self.odor_decay_rate = 0.0\n        else:\n            self.odor_decay_rate = 1 - np.exp(-1.0 / self.fps / self.odor_decay_tau)\n\n        if self.directional_persistence_strategy is None:\n            # Default to a fixed blend with 50% persistence.\n            from .directional_persistence import FixedBlendPersistence\n\n            self.directional_persistence_strategy = FixedBlendPersistence(alpha=0.0)\n</code></pre>"},{"location":"api/sim/config/#arthroscape.sim.config.SimulationConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization processing.</p> <p>This method initializes samplers if they are not provided and computes derived parameters such as per-frame rates and kernel sizes.</p> Source code in <code>arthroscape/sim/config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Post-initialization processing.\n\n    This method initializes samplers if they are not provided and computes\n    derived parameters such as per-frame rates and kernel sizes.\n    \"\"\"\n    if self.walking_speed_sampler is None:\n        self.walking_speed_sampler = get_walking_speed_sampler(self.walking_speed)\n    if self.turn_angle_sampler is None:\n        low, high = self.turn_magnitude_range\n        self.turn_angle_sampler = get_turn_angle_sampler(low, high)\n    if self.initial_position_sampler is None:\n        self.initial_position_sampler = get_initial_position_sampler(\n            self.grid_x_min, self.grid_x_max, self.grid_y_min, self.grid_y_max\n        )\n    if self.initial_heading_sampler is None:\n        self.initial_heading_sampler = get_initial_heading_sampler()\n\n    # Compute derived parameters\n    self.odor_history_interval_frames = int(\n        self.odor_history_time_interval * self.fps\n    )\n\n    self.turn_rate_per_frame = self.turn_rate / self.fps\n    self.asymmetry_factor_per_frame = self.asymmetry_factor / self.fps\n    self.rate_stop_to_walk_per_frame = self.rate_stop_to_walk / self.fps\n    self.rate_walk_to_stop_per_frame = self.rate_walk_to_stop / self.fps\n    self.total_frames = int(self.T * self.fps)\n\n    self.error_rate_per_frame = self.error_rate / self.fps\n\n    # Compute kernel size from sigma and deposit_kernel_factor (round up to an odd integer)\n    size = (\n        int(\n            2\n            * np.ceil(\n                self.deposit_kernel_factor\n                * self.deposit_sigma\n                / self.grid_resolution\n            )\n        )\n        + 1\n    )\n    self.deposit_kernel_size = size\n\n    # Compute odor decay rate per frame from the time constant\n    if self.odor_decay_tau == np.inf:\n        self.odor_decay_rate = 0.0\n    else:\n        self.odor_decay_rate = 1 - np.exp(-1.0 / self.fps / self.odor_decay_tau)\n\n    if self.directional_persistence_strategy is None:\n        # Default to a fixed blend with 50% persistence.\n        from .directional_persistence import FixedBlendPersistence\n\n        self.directional_persistence_strategy = FixedBlendPersistence(alpha=0.0)\n</code></pre>"},{"location":"api/sim/config/#arthroscape.sim.config.get_initial_heading_sampler","title":"<code>get_initial_heading_sampler()</code>","text":"<p>Returns a callable that samples an initial heading.</p> <p>The heading is sampled uniformly from [-pi, pi].</p> <p>Returns:</p> Type Description <code>Callable[[], float]</code> <p>Callable[[], float]: A function that returns a sampled heading in radians.</p> Source code in <code>arthroscape/sim/config.py</code> <pre><code>def get_initial_heading_sampler() -&gt; Callable[[], float]:\n    \"\"\"\n    Returns a callable that samples an initial heading.\n\n    The heading is sampled uniformly from [-pi, pi].\n\n    Returns:\n        Callable[[], float]: A function that returns a sampled heading in radians.\n    \"\"\"\n    return _sample_initial_heading\n</code></pre>"},{"location":"api/sim/config/#arthroscape.sim.config.get_initial_position_sampler","title":"<code>get_initial_position_sampler(grid_x_min, grid_x_max, grid_y_min, grid_y_max)</code>","text":"<p>Returns a callable that samples an initial position.</p> <p>The position is sampled from a normal distribution centered at (0, 0) with standard deviation equal to 1/10th of the grid dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>grid_x_min</code> <code>float</code> <p>Minimum x-coordinate of the grid.</p> required <code>grid_x_max</code> <code>float</code> <p>Maximum x-coordinate of the grid.</p> required <code>grid_y_min</code> <code>float</code> <p>Minimum y-coordinate of the grid.</p> required <code>grid_y_max</code> <code>float</code> <p>Maximum y-coordinate of the grid.</p> required <p>Returns:</p> Type Description <code>Callable[[], Tuple[float, float]]</code> <p>Callable[[], Tuple[float, float]]: A function that returns a tuple (x, y).</p> Source code in <code>arthroscape/sim/config.py</code> <pre><code>def get_initial_position_sampler(\n    grid_x_min: float, grid_x_max: float, grid_y_min: float, grid_y_max: float\n) -&gt; Callable[[], Tuple[float, float]]:\n    \"\"\"\n    Returns a callable that samples an initial position.\n\n    The position is sampled from a normal distribution centered at (0, 0) with\n    standard deviation equal to 1/10th of the grid dimensions.\n\n    Args:\n        grid_x_min (float): Minimum x-coordinate of the grid.\n        grid_x_max (float): Maximum x-coordinate of the grid.\n        grid_y_min (float): Minimum y-coordinate of the grid.\n        grid_y_max (float): Maximum y-coordinate of the grid.\n\n    Returns:\n        Callable[[], Tuple[float, float]]: A function that returns a tuple (x, y).\n    \"\"\"\n    return functools.partial(\n        _sample_initial_position, grid_x_min, grid_x_max, grid_y_min, grid_y_max\n    )\n</code></pre>"},{"location":"api/sim/config/#arthroscape.sim.config.get_turn_angle_sampler","title":"<code>get_turn_angle_sampler(low, high)</code>","text":"<p>Returns a callable that samples a turn angle from a uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>low</code> <code>float</code> <p>The lower bound of the distribution (radians).</p> required <code>high</code> <code>float</code> <p>The upper bound of the distribution (radians).</p> required <p>Returns:</p> Type Description <code>Callable[[], float]</code> <p>Callable[[], float]: A function that returns a sampled turn angle.</p> Source code in <code>arthroscape/sim/config.py</code> <pre><code>def get_turn_angle_sampler(low: float, high: float) -&gt; Callable[[], float]:\n    \"\"\"\n    Returns a callable that samples a turn angle from a uniform distribution.\n\n    Args:\n        low (float): The lower bound of the distribution (radians).\n        high (float): The upper bound of the distribution (radians).\n\n    Returns:\n        Callable[[], float]: A function that returns a sampled turn angle.\n    \"\"\"\n    return functools.partial(_sample_turn_angle, low, high)\n</code></pre>"},{"location":"api/sim/config/#arthroscape.sim.config.get_walking_speed_sampler","title":"<code>get_walking_speed_sampler(walking_speed)</code>","text":"<p>Returns a callable that returns a constant walking speed.</p> <p>Parameters:</p> Name Type Description Default <code>walking_speed</code> <code>float</code> <p>The walking speed to return.</p> required <p>Returns:</p> Type Description <code>Callable[[], float]</code> <p>Callable[[], float]: A function that returns the walking speed.</p> Source code in <code>arthroscape/sim/config.py</code> <pre><code>def get_walking_speed_sampler(walking_speed: float) -&gt; Callable[[], float]:\n    \"\"\"\n    Returns a callable that returns a constant walking speed.\n\n    Args:\n        walking_speed (float): The walking speed to return.\n\n    Returns:\n        Callable[[], float]: A function that returns the walking speed.\n    \"\"\"\n    return functools.partial(_return_walking_speed, walking_speed)\n</code></pre>"},{"location":"api/sim/directional_persistence/","title":"Directional Persistence","text":""},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence","title":"<code>arthroscape.sim.directional_persistence</code>","text":"<p>Directional persistence module for the ArthroScape simulation.</p> <p>This module defines strategies for directional persistence, which allows agents to maintain their heading over time, smoothing out instantaneous turns. This is crucial for modeling realistic movement where inertia or behavioral persistence plays a role.</p>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.AvgOdorWeightedPersistence","title":"<code>AvgOdorWeightedPersistence</code>","text":"<p>               Bases: <code>DirectionalPersistenceStrategy</code></p> <p>Persistence strategy weighted by average odor concentration.</p> <p>This strategy increases persistence when the overall odor concentration is high.</p> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>class AvgOdorWeightedPersistence(DirectionalPersistenceStrategy):\n    \"\"\"\n    Persistence strategy weighted by average odor concentration.\n\n    This strategy increases persistence when the overall odor concentration is high.\n    \"\"\"\n\n    def __init__(self, alpha_min: float = 0.3, alpha_max: float = 0.7):\n        \"\"\"\n        Initialize the AvgOdorWeightedPersistence strategy.\n\n        Args:\n            alpha_min (float): Minimum persistence weight (used when odor is low).\n            alpha_max (float): Maximum persistence weight (used when odor is high).\n        \"\"\"\n        self.alpha_min = alpha_min\n        self.alpha_max = alpha_max\n\n    def adjust_heading(\n        self,\n        prev_heading: float,\n        computed_heading: float,\n        odor_left: float,\n        odor_right: float,\n        config: \"SimulationConfig\",\n        rng: np.random.Generator,\n    ) -&gt; float:\n        \"\"\"\n        Adjust heading with persistence proportional to average odor.\n\n        Args:\n            prev_heading (float): Previous heading.\n            computed_heading (float): Proposed heading.\n            odor_left (float): Left odor.\n            odor_right (float): Right odor.\n            config (SimulationConfig): Config.\n            rng (np.random.Generator): RNG.\n\n        Returns:\n            float: The adjusted heading.\n        \"\"\"\n        # Example: When the average odor is high, use more persistence.\n        avg_odor = 0.5 * (odor_left + odor_right)\n        # Normalize avg_odor to a value between 0 and 1; adjust scaling as needed.\n        persistence_factor = np.clip(avg_odor, 0, 1)\n        # Optionally mix with a baseline alpha.\n        alpha = self.alpha_min + persistence_factor * (self.alpha_max - self.alpha_min)\n        new_heading = (1 - alpha) * computed_heading + alpha * prev_heading\n        return new_heading\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.AvgOdorWeightedPersistence.__init__","title":"<code>__init__(alpha_min=0.3, alpha_max=0.7)</code>","text":"<p>Initialize the AvgOdorWeightedPersistence strategy.</p> <p>Parameters:</p> Name Type Description Default <code>alpha_min</code> <code>float</code> <p>Minimum persistence weight (used when odor is low).</p> <code>0.3</code> <code>alpha_max</code> <code>float</code> <p>Maximum persistence weight (used when odor is high).</p> <code>0.7</code> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>def __init__(self, alpha_min: float = 0.3, alpha_max: float = 0.7):\n    \"\"\"\n    Initialize the AvgOdorWeightedPersistence strategy.\n\n    Args:\n        alpha_min (float): Minimum persistence weight (used when odor is low).\n        alpha_max (float): Maximum persistence weight (used when odor is high).\n    \"\"\"\n    self.alpha_min = alpha_min\n    self.alpha_max = alpha_max\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.AvgOdorWeightedPersistence.adjust_heading","title":"<code>adjust_heading(prev_heading, computed_heading, odor_left, odor_right, config, rng)</code>","text":"<p>Adjust heading with persistence proportional to average odor.</p> <p>Parameters:</p> Name Type Description Default <code>prev_heading</code> <code>float</code> <p>Previous heading.</p> required <code>computed_heading</code> <code>float</code> <p>Proposed heading.</p> required <code>odor_left</code> <code>float</code> <p>Left odor.</p> required <code>odor_right</code> <code>float</code> <p>Right odor.</p> required <code>config</code> <code>SimulationConfig</code> <p>Config.</p> required <code>rng</code> <code>Generator</code> <p>RNG.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The adjusted heading.</p> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>def adjust_heading(\n    self,\n    prev_heading: float,\n    computed_heading: float,\n    odor_left: float,\n    odor_right: float,\n    config: \"SimulationConfig\",\n    rng: np.random.Generator,\n) -&gt; float:\n    \"\"\"\n    Adjust heading with persistence proportional to average odor.\n\n    Args:\n        prev_heading (float): Previous heading.\n        computed_heading (float): Proposed heading.\n        odor_left (float): Left odor.\n        odor_right (float): Right odor.\n        config (SimulationConfig): Config.\n        rng (np.random.Generator): RNG.\n\n    Returns:\n        float: The adjusted heading.\n    \"\"\"\n    # Example: When the average odor is high, use more persistence.\n    avg_odor = 0.5 * (odor_left + odor_right)\n    # Normalize avg_odor to a value between 0 and 1; adjust scaling as needed.\n    persistence_factor = np.clip(avg_odor, 0, 1)\n    # Optionally mix with a baseline alpha.\n    alpha = self.alpha_min + persistence_factor * (self.alpha_max - self.alpha_min)\n    new_heading = (1 - alpha) * computed_heading + alpha * prev_heading\n    return new_heading\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.DirectionalPersistenceStrategy","title":"<code>DirectionalPersistenceStrategy</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for directional persistence strategies.</p> <p>A persistence strategy modifies the computed heading (based on immediate sensory input) by blending it with the previous heading or applying other persistence logic.</p> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>class DirectionalPersistenceStrategy(ABC):\n    \"\"\"\n    Abstract base class for directional persistence strategies.\n\n    A persistence strategy modifies the computed heading (based on immediate sensory input)\n    by blending it with the previous heading or applying other persistence logic.\n    \"\"\"\n\n    @abstractmethod\n    def adjust_heading(\n        self,\n        prev_heading: float,\n        computed_heading: float,\n        odor_left: float,\n        odor_right: float,\n        config: \"SimulationConfig\",\n        rng: np.random.Generator,\n    ) -&gt; float:\n        \"\"\"\n        Adjust the heading based on persistence logic.\n\n        Args:\n            prev_heading (float): The agent's heading in the previous frame.\n            computed_heading (float): The proposed new heading based on current sensory input.\n            odor_left (float): Odor concentration at the left sensor.\n            odor_right (float): Odor concentration at the right sensor.\n            config (SimulationConfig): The simulation configuration.\n            rng (np.random.Generator): Random number generator.\n\n        Returns:\n            float: The adjusted heading.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.DirectionalPersistenceStrategy.adjust_heading","title":"<code>adjust_heading(prev_heading, computed_heading, odor_left, odor_right, config, rng)</code>  <code>abstractmethod</code>","text":"<p>Adjust the heading based on persistence logic.</p> <p>Parameters:</p> Name Type Description Default <code>prev_heading</code> <code>float</code> <p>The agent's heading in the previous frame.</p> required <code>computed_heading</code> <code>float</code> <p>The proposed new heading based on current sensory input.</p> required <code>odor_left</code> <code>float</code> <p>Odor concentration at the left sensor.</p> required <code>odor_right</code> <code>float</code> <p>Odor concentration at the right sensor.</p> required <code>config</code> <code>SimulationConfig</code> <p>The simulation configuration.</p> required <code>rng</code> <code>Generator</code> <p>Random number generator.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The adjusted heading.</p> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>@abstractmethod\ndef adjust_heading(\n    self,\n    prev_heading: float,\n    computed_heading: float,\n    odor_left: float,\n    odor_right: float,\n    config: \"SimulationConfig\",\n    rng: np.random.Generator,\n) -&gt; float:\n    \"\"\"\n    Adjust the heading based on persistence logic.\n\n    Args:\n        prev_heading (float): The agent's heading in the previous frame.\n        computed_heading (float): The proposed new heading based on current sensory input.\n        odor_left (float): Odor concentration at the left sensor.\n        odor_right (float): Odor concentration at the right sensor.\n        config (SimulationConfig): The simulation configuration.\n        rng (np.random.Generator): Random number generator.\n\n    Returns:\n        float: The adjusted heading.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.FixedBlendPersistence","title":"<code>FixedBlendPersistence</code>","text":"<p>               Bases: <code>DirectionalPersistenceStrategy</code></p> <p>A simple persistence strategy that linearly blends the previous and computed headings.</p> <p>The new heading is a weighted average: new_heading = (1 - alpha) * computed_heading + alpha * prev_heading</p> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>class FixedBlendPersistence(DirectionalPersistenceStrategy):\n    \"\"\"\n    A simple persistence strategy that linearly blends the previous and computed headings.\n\n    The new heading is a weighted average:\n    new_heading = (1 - alpha) * computed_heading + alpha * prev_heading\n    \"\"\"\n\n    def __init__(self, alpha: float = 0.5):\n        \"\"\"\n        Initialize the FixedBlendPersistence strategy.\n\n        Args:\n            alpha (float): The persistence weight (0.0 to 1.0).\n                           0.0 means no persistence (fully reactive).\n                           1.0 means full persistence (no turning).\n        \"\"\"\n        self.alpha = alpha\n\n    def adjust_heading(\n        self,\n        prev_heading: float,\n        computed_heading: float,\n        odor_left: float,\n        odor_right: float,\n        config: \"SimulationConfig\",\n        rng: np.random.Generator,\n    ) -&gt; float:\n        \"\"\"\n        Apply fixed blending to the heading.\n\n        Args:\n            prev_heading (float): Previous heading.\n            computed_heading (float): Proposed heading.\n            odor_left (float): Left odor.\n            odor_right (float): Right odor.\n            config (SimulationConfig): Config.\n            rng (np.random.Generator): RNG.\n\n        Returns:\n            float: The blended heading.\n        \"\"\"\n        if self.alpha == 0.0:\n            return computed_heading\n        elif self.alpha == 1.0:\n            return prev_heading\n        # Simple fixed blending.\n        new_heading = (1 - self.alpha) * computed_heading + self.alpha * prev_heading\n        return new_heading\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.FixedBlendPersistence.__init__","title":"<code>__init__(alpha=0.5)</code>","text":"<p>Initialize the FixedBlendPersistence strategy.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>The persistence weight (0.0 to 1.0).            0.0 means no persistence (fully reactive).            1.0 means full persistence (no turning).</p> <code>0.5</code> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>def __init__(self, alpha: float = 0.5):\n    \"\"\"\n    Initialize the FixedBlendPersistence strategy.\n\n    Args:\n        alpha (float): The persistence weight (0.0 to 1.0).\n                       0.0 means no persistence (fully reactive).\n                       1.0 means full persistence (no turning).\n    \"\"\"\n    self.alpha = alpha\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.FixedBlendPersistence.adjust_heading","title":"<code>adjust_heading(prev_heading, computed_heading, odor_left, odor_right, config, rng)</code>","text":"<p>Apply fixed blending to the heading.</p> <p>Parameters:</p> Name Type Description Default <code>prev_heading</code> <code>float</code> <p>Previous heading.</p> required <code>computed_heading</code> <code>float</code> <p>Proposed heading.</p> required <code>odor_left</code> <code>float</code> <p>Left odor.</p> required <code>odor_right</code> <code>float</code> <p>Right odor.</p> required <code>config</code> <code>SimulationConfig</code> <p>Config.</p> required <code>rng</code> <code>Generator</code> <p>RNG.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The blended heading.</p> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>def adjust_heading(\n    self,\n    prev_heading: float,\n    computed_heading: float,\n    odor_left: float,\n    odor_right: float,\n    config: \"SimulationConfig\",\n    rng: np.random.Generator,\n) -&gt; float:\n    \"\"\"\n    Apply fixed blending to the heading.\n\n    Args:\n        prev_heading (float): Previous heading.\n        computed_heading (float): Proposed heading.\n        odor_left (float): Left odor.\n        odor_right (float): Right odor.\n        config (SimulationConfig): Config.\n        rng (np.random.Generator): RNG.\n\n    Returns:\n        float: The blended heading.\n    \"\"\"\n    if self.alpha == 0.0:\n        return computed_heading\n    elif self.alpha == 1.0:\n        return prev_heading\n    # Simple fixed blending.\n    new_heading = (1 - self.alpha) * computed_heading + self.alpha * prev_heading\n    return new_heading\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.OdorDifferenceWeightedPersistence","title":"<code>OdorDifferenceWeightedPersistence</code>","text":"<p>               Bases: <code>DirectionalPersistenceStrategy</code></p> <p>Persistence strategy weighted by odor difference.</p> <p>This strategy increases persistence when the odor signal is ambiguous (small difference), encouraging the agent to \"commit\" to a direction when signals are weak.</p> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>class OdorDifferenceWeightedPersistence(DirectionalPersistenceStrategy):\n    \"\"\"\n    Persistence strategy weighted by odor difference.\n\n    This strategy increases persistence when the odor signal is ambiguous (small difference),\n    encouraging the agent to \"commit\" to a direction when signals are weak.\n    \"\"\"\n\n    def __init__(self, alpha_min: float = 0.3, alpha_max: float = 0.7):\n        \"\"\"\n        Initialize the OdorDifferenceWeightedPersistence strategy.\n\n        Args:\n            alpha_min (float): Minimum persistence weight (used when odor difference is large).\n            alpha_max (float): Maximum persistence weight (used when odor difference is small).\n        \"\"\"\n        self.alpha_min = alpha_min\n        self.alpha_max = alpha_max\n\n    def adjust_heading(\n        self,\n        prev_heading: float,\n        computed_heading: float,\n        odor_left: float,\n        odor_right: float,\n        config: \"SimulationConfig\",\n        rng: np.random.Generator,\n    ) -&gt; float:\n        \"\"\"\n        Adjust heading with persistence inversely proportional to odor difference.\n\n        Args:\n            prev_heading (float): Previous heading.\n            computed_heading (float): Proposed heading.\n            odor_left (float): Left odor.\n            odor_right (float): Right odor.\n            config (SimulationConfig): Config.\n            rng (np.random.Generator): RNG.\n\n        Returns:\n            float: The adjusted heading.\n        \"\"\"\n        # Example: When the difference in odor is small (i.e. ambiguous), use more persistence.\n        odor_diff = abs(odor_left - odor_right)\n        # Normalize odor_diff to a value between 0 and 1; adjust scaling as needed.\n        persistence_factor = np.clip(\n            1 - odor_diff / (odor_left + odor_right + 1e-6), 0, 1\n        )\n        # Optionally mix with a baseline alpha.\n        alpha = self.alpha_min + persistence_factor * (self.alpha_max - self.alpha_min)\n        new_heading = (1 - alpha) * computed_heading + alpha * prev_heading\n        return new_heading\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.OdorDifferenceWeightedPersistence.__init__","title":"<code>__init__(alpha_min=0.3, alpha_max=0.7)</code>","text":"<p>Initialize the OdorDifferenceWeightedPersistence strategy.</p> <p>Parameters:</p> Name Type Description Default <code>alpha_min</code> <code>float</code> <p>Minimum persistence weight (used when odor difference is large).</p> <code>0.3</code> <code>alpha_max</code> <code>float</code> <p>Maximum persistence weight (used when odor difference is small).</p> <code>0.7</code> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>def __init__(self, alpha_min: float = 0.3, alpha_max: float = 0.7):\n    \"\"\"\n    Initialize the OdorDifferenceWeightedPersistence strategy.\n\n    Args:\n        alpha_min (float): Minimum persistence weight (used when odor difference is large).\n        alpha_max (float): Maximum persistence weight (used when odor difference is small).\n    \"\"\"\n    self.alpha_min = alpha_min\n    self.alpha_max = alpha_max\n</code></pre>"},{"location":"api/sim/directional_persistence/#arthroscape.sim.directional_persistence.OdorDifferenceWeightedPersistence.adjust_heading","title":"<code>adjust_heading(prev_heading, computed_heading, odor_left, odor_right, config, rng)</code>","text":"<p>Adjust heading with persistence inversely proportional to odor difference.</p> <p>Parameters:</p> Name Type Description Default <code>prev_heading</code> <code>float</code> <p>Previous heading.</p> required <code>computed_heading</code> <code>float</code> <p>Proposed heading.</p> required <code>odor_left</code> <code>float</code> <p>Left odor.</p> required <code>odor_right</code> <code>float</code> <p>Right odor.</p> required <code>config</code> <code>SimulationConfig</code> <p>Config.</p> required <code>rng</code> <code>Generator</code> <p>RNG.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The adjusted heading.</p> Source code in <code>arthroscape/sim/directional_persistence.py</code> <pre><code>def adjust_heading(\n    self,\n    prev_heading: float,\n    computed_heading: float,\n    odor_left: float,\n    odor_right: float,\n    config: \"SimulationConfig\",\n    rng: np.random.Generator,\n) -&gt; float:\n    \"\"\"\n    Adjust heading with persistence inversely proportional to odor difference.\n\n    Args:\n        prev_heading (float): Previous heading.\n        computed_heading (float): Proposed heading.\n        odor_left (float): Left odor.\n        odor_right (float): Right odor.\n        config (SimulationConfig): Config.\n        rng (np.random.Generator): RNG.\n\n    Returns:\n        float: The adjusted heading.\n    \"\"\"\n    # Example: When the difference in odor is small (i.e. ambiguous), use more persistence.\n    odor_diff = abs(odor_left - odor_right)\n    # Normalize odor_diff to a value between 0 and 1; adjust scaling as needed.\n    persistence_factor = np.clip(\n        1 - odor_diff / (odor_left + odor_right + 1e-6), 0, 1\n    )\n    # Optionally mix with a baseline alpha.\n    alpha = self.alpha_min + persistence_factor * (self.alpha_max - self.alpha_min)\n    new_heading = (1 - alpha) * computed_heading + alpha * prev_heading\n    return new_heading\n</code></pre>"},{"location":"api/sim/odor_perception/","title":"Odor Perception","text":""},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception","title":"<code>arthroscape.sim.odor_perception</code>","text":"<p>Odor perception module for the ArthroScape simulation.</p> <p>This module defines the <code>AgentOdorPerception</code> abstract base class and various concrete implementations. These classes model how an agent processes raw odor signals from its sensors (antennae). Implementations include simple pass-through, ablation (blocking one sensor), low-pass filtering, derivative sensing, and adaptation models.</p>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedDerivativePerception","title":"<code>AblatedDerivativePerception</code>","text":"<p>               Bases: <code>AgentOdorPerception</code></p> <p>A perception model combining derivative sensing with unilateral ablation.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class AblatedDerivativePerception(AgentOdorPerception):\n    \"\"\"\n    A perception model combining derivative sensing with unilateral ablation.\n    \"\"\"\n\n    def __init__(self, scale: float = 0.1, direction: str = \"random\") -&gt; None:\n        \"\"\"\n        Initialize the ablated derivative perception model.\n\n        Args:\n            scale (float): Scaling factor for the derivative.\n            direction (str): Side to ablate ('left', 'right', or 'random').\n        \"\"\"\n        self.scale = scale\n        self.direction = direction\n        if self.direction not in [\"left\", \"right\", \"random\"]:\n            raise ValueError(\"Direction must be 'left', 'right', or 'random'.\")\n        if self.direction == \"random\":\n            self.direction = np.random.choice([\"left\", \"right\"])\n        self.previous_left = 0.0\n        self.previous_right = 0.0\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset previous values to zero.\"\"\"\n        self.previous_left = 0.0\n        self.previous_right = 0.0\n\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Compute derivative and apply ablation.\n\n        Args:\n            raw_left (float): Raw left odor.\n            raw_right (float): Raw right odor.\n            dt (float): Time step.\n\n        Returns:\n            Tuple[float, float]: (derivative_left, derivative_right) with one side zeroed.\n        \"\"\"\n        # Compute the derivative of the raw values\n        derivative_left = self.scale * (raw_left - self.previous_left) / dt\n        derivative_right = self.scale * (raw_right - self.previous_right) / dt\n\n        # Update the previous values for the next step\n        self.previous_left = raw_left\n        self.previous_right = raw_right\n\n        # Return zero for the ablated side\n        if self.direction == \"left\":\n            return (0.0, derivative_right)\n        elif self.direction == \"right\":\n            return (derivative_left, 0.0)\n        else:\n            raise ValueError(\"Invalid direction for ablation.\")\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedDerivativePerception.__init__","title":"<code>__init__(scale=0.1, direction='random')</code>","text":"<p>Initialize the ablated derivative perception model.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Scaling factor for the derivative.</p> <code>0.1</code> <code>direction</code> <code>str</code> <p>Side to ablate ('left', 'right', or 'random').</p> <code>'random'</code> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def __init__(self, scale: float = 0.1, direction: str = \"random\") -&gt; None:\n    \"\"\"\n    Initialize the ablated derivative perception model.\n\n    Args:\n        scale (float): Scaling factor for the derivative.\n        direction (str): Side to ablate ('left', 'right', or 'random').\n    \"\"\"\n    self.scale = scale\n    self.direction = direction\n    if self.direction not in [\"left\", \"right\", \"random\"]:\n        raise ValueError(\"Direction must be 'left', 'right', or 'random'.\")\n    if self.direction == \"random\":\n        self.direction = np.random.choice([\"left\", \"right\"])\n    self.previous_left = 0.0\n    self.previous_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedDerivativePerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>","text":"<p>Compute derivative and apply ablation.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>Raw left odor.</p> required <code>raw_right</code> <code>float</code> <p>Raw right odor.</p> required <code>dt</code> <code>float</code> <p>Time step.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: (derivative_left, derivative_right) with one side zeroed.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Compute derivative and apply ablation.\n\n    Args:\n        raw_left (float): Raw left odor.\n        raw_right (float): Raw right odor.\n        dt (float): Time step.\n\n    Returns:\n        Tuple[float, float]: (derivative_left, derivative_right) with one side zeroed.\n    \"\"\"\n    # Compute the derivative of the raw values\n    derivative_left = self.scale * (raw_left - self.previous_left) / dt\n    derivative_right = self.scale * (raw_right - self.previous_right) / dt\n\n    # Update the previous values for the next step\n    self.previous_left = raw_left\n    self.previous_right = raw_right\n\n    # Return zero for the ablated side\n    if self.direction == \"left\":\n        return (0.0, derivative_right)\n    elif self.direction == \"right\":\n        return (derivative_left, 0.0)\n    else:\n        raise ValueError(\"Invalid direction for ablation.\")\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedDerivativePerception.reset","title":"<code>reset()</code>","text":"<p>Reset previous values to zero.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset previous values to zero.\"\"\"\n    self.previous_left = 0.0\n    self.previous_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedLeakAdaptationPerception","title":"<code>AblatedLeakAdaptationPerception</code>","text":"<p>               Bases: <code>AgentOdorPerception</code></p> <p>An ablated version of the LeakAdaptationPerception that zeros the integrated odor signal of one sensor. The ablated side is determined by the 'direction' parameter.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class AblatedLeakAdaptationPerception(AgentOdorPerception):\n    \"\"\"\n    An ablated version of the LeakAdaptationPerception that zeros the integrated odor signal\n    of one sensor. The ablated side is determined by the 'direction' parameter.\n    \"\"\"\n\n    def __init__(\n        self,\n        odor_integration_tau: float = 1.0,\n        adaptation_tau: float = 5.0,\n        adaptation_magnitude: float = 0.5,\n        direction: str = \"random\",\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ablated leak adaptation model.\n\n        Args:\n            odor_integration_tau (float): Time constant for odor integration (in seconds).\n            adaptation_tau (float): Time constant for adaptation recovery (in seconds).\n            adaptation_magnitude (float): Strength of the odor\u2019s influence on adaptation.\n            direction (str): The sensor to ablate: \"left\", \"right\", or \"random\".\n\n        Raises:\n            ValueError: If time constants are not positive or direction is invalid.\n        \"\"\"\n        if odor_integration_tau &lt;= 0:\n            raise ValueError(\"odor_integration_tau must be positive.\")\n        if adaptation_tau &lt;= 0:\n            raise ValueError(\"adaptation_tau must be positive.\")\n        if direction not in [\"left\", \"right\", \"random\"]:\n            raise ValueError(\"Direction must be 'left', 'right', or 'random'.\")\n        if direction == \"random\":\n            direction = np.random.choice([\"left\", \"right\"])\n        self.odor_integration_tau = odor_integration_tau\n        self.adaptation_tau = adaptation_tau\n        self.adaptation_magnitude = adaptation_magnitude\n        self.direction = direction\n\n        self.integrated_left = 0.0\n        self.integrated_right = 0.0\n        self.adapt_left = 0.0\n        self.adapt_right = 0.0\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the integrated odor and adaptation variables to initial values.\"\"\"\n        self.integrated_left = 0.0\n        self.integrated_right = 0.0\n        self.adapt_left = 0.0\n        self.adapt_right = 0.0\n\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Integrate odor signal, update adaptation, and apply ablation.\n\n        Args:\n            raw_left (float): Raw left odor.\n            raw_right (float): Raw right odor.\n            dt (float): Time step.\n\n        Returns:\n            Tuple[float, float]: (perceived_left, perceived_right) with one side zeroed.\n        \"\"\"\n        if dt &lt;= 0:\n            raise ValueError(\"dt must be positive.\")\n\n        d_integrated_left = (\n            -self.integrated_left + raw_left - self.adapt_left\n        ) / self.odor_integration_tau\n        d_integrated_right = (\n            -self.integrated_right + raw_right - self.adapt_right\n        ) / self.odor_integration_tau\n\n        self.integrated_left += d_integrated_left * dt\n        self.integrated_right += d_integrated_right * dt\n\n        d_adapt_left = (\n            -self.adapt_left + self.adaptation_magnitude * self.integrated_left\n        ) / self.adaptation_tau\n        d_adapt_right = (\n            -self.adapt_right + self.adaptation_magnitude * self.integrated_right\n        ) / self.adaptation_tau\n\n        self.adapt_left += d_adapt_left * dt\n        self.adapt_right += d_adapt_right * dt\n\n        if self.direction == \"left\":\n            return (0.0, self.integrated_right)\n        elif self.direction == \"right\":\n            return (self.integrated_left, 0.0)\n        else:\n            # Should not happen if init checks pass\n            raise ValueError(\"Invalid direction for ablation.\")\n\n        d_adapt_left = (\n            -self.adapt_left + self.adaptation_magnitude * self.integrated_left\n        ) / self.adaptation_tau\n        d_adapt_right = (\n            -self.adapt_right + self.adaptation_magnitude * self.integrated_right\n        ) / self.adaptation_tau\n\n        self.adapt_left += d_adapt_left * dt\n        self.adapt_right += d_adapt_right * dt\n\n        # Apply ablation by zeroing the integrated odor for the designated sensor.\n        if self.direction == \"left\":\n            perceived_left = 0.0\n            perceived_right = self.integrated_right\n        elif self.direction == \"right\":\n            perceived_left = self.integrated_left\n            perceived_right = 0.0\n        else:\n            raise ValueError(\"Invalid direction for ablation.\")\n\n        return perceived_left, perceived_right\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedLeakAdaptationPerception.__init__","title":"<code>__init__(odor_integration_tau=1.0, adaptation_tau=5.0, adaptation_magnitude=0.5, direction='random')</code>","text":"<p>Initialize the ablated leak adaptation model.</p> <p>Parameters:</p> Name Type Description Default <code>odor_integration_tau</code> <code>float</code> <p>Time constant for odor integration (in seconds).</p> <code>1.0</code> <code>adaptation_tau</code> <code>float</code> <p>Time constant for adaptation recovery (in seconds).</p> <code>5.0</code> <code>adaptation_magnitude</code> <code>float</code> <p>Strength of the odor\u2019s influence on adaptation.</p> <code>0.5</code> <code>direction</code> <code>str</code> <p>The sensor to ablate: \"left\", \"right\", or \"random\".</p> <code>'random'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If time constants are not positive or direction is invalid.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def __init__(\n    self,\n    odor_integration_tau: float = 1.0,\n    adaptation_tau: float = 5.0,\n    adaptation_magnitude: float = 0.5,\n    direction: str = \"random\",\n) -&gt; None:\n    \"\"\"\n    Initialize the ablated leak adaptation model.\n\n    Args:\n        odor_integration_tau (float): Time constant for odor integration (in seconds).\n        adaptation_tau (float): Time constant for adaptation recovery (in seconds).\n        adaptation_magnitude (float): Strength of the odor\u2019s influence on adaptation.\n        direction (str): The sensor to ablate: \"left\", \"right\", or \"random\".\n\n    Raises:\n        ValueError: If time constants are not positive or direction is invalid.\n    \"\"\"\n    if odor_integration_tau &lt;= 0:\n        raise ValueError(\"odor_integration_tau must be positive.\")\n    if adaptation_tau &lt;= 0:\n        raise ValueError(\"adaptation_tau must be positive.\")\n    if direction not in [\"left\", \"right\", \"random\"]:\n        raise ValueError(\"Direction must be 'left', 'right', or 'random'.\")\n    if direction == \"random\":\n        direction = np.random.choice([\"left\", \"right\"])\n    self.odor_integration_tau = odor_integration_tau\n    self.adaptation_tau = adaptation_tau\n    self.adaptation_magnitude = adaptation_magnitude\n    self.direction = direction\n\n    self.integrated_left = 0.0\n    self.integrated_right = 0.0\n    self.adapt_left = 0.0\n    self.adapt_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedLeakAdaptationPerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>","text":"<p>Integrate odor signal, update adaptation, and apply ablation.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>Raw left odor.</p> required <code>raw_right</code> <code>float</code> <p>Raw right odor.</p> required <code>dt</code> <code>float</code> <p>Time step.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: (perceived_left, perceived_right) with one side zeroed.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Integrate odor signal, update adaptation, and apply ablation.\n\n    Args:\n        raw_left (float): Raw left odor.\n        raw_right (float): Raw right odor.\n        dt (float): Time step.\n\n    Returns:\n        Tuple[float, float]: (perceived_left, perceived_right) with one side zeroed.\n    \"\"\"\n    if dt &lt;= 0:\n        raise ValueError(\"dt must be positive.\")\n\n    d_integrated_left = (\n        -self.integrated_left + raw_left - self.adapt_left\n    ) / self.odor_integration_tau\n    d_integrated_right = (\n        -self.integrated_right + raw_right - self.adapt_right\n    ) / self.odor_integration_tau\n\n    self.integrated_left += d_integrated_left * dt\n    self.integrated_right += d_integrated_right * dt\n\n    d_adapt_left = (\n        -self.adapt_left + self.adaptation_magnitude * self.integrated_left\n    ) / self.adaptation_tau\n    d_adapt_right = (\n        -self.adapt_right + self.adaptation_magnitude * self.integrated_right\n    ) / self.adaptation_tau\n\n    self.adapt_left += d_adapt_left * dt\n    self.adapt_right += d_adapt_right * dt\n\n    if self.direction == \"left\":\n        return (0.0, self.integrated_right)\n    elif self.direction == \"right\":\n        return (self.integrated_left, 0.0)\n    else:\n        # Should not happen if init checks pass\n        raise ValueError(\"Invalid direction for ablation.\")\n\n    d_adapt_left = (\n        -self.adapt_left + self.adaptation_magnitude * self.integrated_left\n    ) / self.adaptation_tau\n    d_adapt_right = (\n        -self.adapt_right + self.adaptation_magnitude * self.integrated_right\n    ) / self.adaptation_tau\n\n    self.adapt_left += d_adapt_left * dt\n    self.adapt_right += d_adapt_right * dt\n\n    # Apply ablation by zeroing the integrated odor for the designated sensor.\n    if self.direction == \"left\":\n        perceived_left = 0.0\n        perceived_right = self.integrated_right\n    elif self.direction == \"right\":\n        perceived_left = self.integrated_left\n        perceived_right = 0.0\n    else:\n        raise ValueError(\"Invalid direction for ablation.\")\n\n    return perceived_left, perceived_right\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedLeakAdaptationPerception.reset","title":"<code>reset()</code>","text":"<p>Reset the integrated odor and adaptation variables to initial values.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the integrated odor and adaptation variables to initial values.\"\"\"\n    self.integrated_left = 0.0\n    self.integrated_right = 0.0\n    self.adapt_left = 0.0\n    self.adapt_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedPerception","title":"<code>AblatedPerception</code>","text":"<p>               Bases: <code>AgentOdorPerception</code></p> <p>A perception model that simulates sensory ablation by zeroing out the signal from one side.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class AblatedPerception(AgentOdorPerception):\n    \"\"\"\n    A perception model that simulates sensory ablation by zeroing out the signal from one side.\n    \"\"\"\n\n    def __init__(self, direction: str = \"random\") -&gt; None:\n        \"\"\"\n        Initialize the ablated perception model.\n\n        Args:\n            direction (str): The side to ablate. Options are \"left\", \"right\", or \"random\".\n                             If \"random\", the side is chosen at initialization.\n\n        Raises:\n            ValueError: If direction is not 'left', 'right', or 'random'.\n        \"\"\"\n        self.direction = direction\n        if self.direction not in [\"left\", \"right\", \"random\"]:\n            raise ValueError(\"Direction must be 'left', 'right', or 'random'.\")\n        if self.direction == \"random\":\n            self.direction = np.random.choice([\"left\", \"right\"])\n\n    def reset(self) -&gt; None:\n        pass\n\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Return odor values with one side set to zero.\n\n        Args:\n            raw_left (float): Raw left odor.\n            raw_right (float): Raw right odor.\n            dt (float): Time step.\n\n        Returns:\n            Tuple[float, float]: (0.0, raw_right) if left is ablated, or (raw_left, 0.0) if right is ablated.\n        \"\"\"\n        # Return zero for the ablated side\n        if self.direction == \"left\":\n            return (0.0, raw_right)\n        elif self.direction == \"right\":\n            return (raw_left, 0.0)\n        else:\n            raise ValueError(\"Invalid direction for ablation.\")\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedPerception.__init__","title":"<code>__init__(direction='random')</code>","text":"<p>Initialize the ablated perception model.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>The side to ablate. Options are \"left\", \"right\", or \"random\".              If \"random\", the side is chosen at initialization.</p> <code>'random'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If direction is not 'left', 'right', or 'random'.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def __init__(self, direction: str = \"random\") -&gt; None:\n    \"\"\"\n    Initialize the ablated perception model.\n\n    Args:\n        direction (str): The side to ablate. Options are \"left\", \"right\", or \"random\".\n                         If \"random\", the side is chosen at initialization.\n\n    Raises:\n        ValueError: If direction is not 'left', 'right', or 'random'.\n    \"\"\"\n    self.direction = direction\n    if self.direction not in [\"left\", \"right\", \"random\"]:\n        raise ValueError(\"Direction must be 'left', 'right', or 'random'.\")\n    if self.direction == \"random\":\n        self.direction = np.random.choice([\"left\", \"right\"])\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AblatedPerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>","text":"<p>Return odor values with one side set to zero.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>Raw left odor.</p> required <code>raw_right</code> <code>float</code> <p>Raw right odor.</p> required <code>dt</code> <code>float</code> <p>Time step.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: (0.0, raw_right) if left is ablated, or (raw_left, 0.0) if right is ablated.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Return odor values with one side set to zero.\n\n    Args:\n        raw_left (float): Raw left odor.\n        raw_right (float): Raw right odor.\n        dt (float): Time step.\n\n    Returns:\n        Tuple[float, float]: (0.0, raw_right) if left is ablated, or (raw_left, 0.0) if right is ablated.\n    \"\"\"\n    # Return zero for the ablated side\n    if self.direction == \"left\":\n        return (0.0, raw_right)\n    elif self.direction == \"right\":\n        return (raw_left, 0.0)\n    else:\n        raise ValueError(\"Invalid direction for ablation.\")\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AgentOdorPerception","title":"<code>AgentOdorPerception</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for an agent's odor perception system.</p> <p>Each agent in the simulation holds its own instance of a perception class, allowing for individual state (e.g., for adaptation or filtering).</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class AgentOdorPerception(ABC):\n    \"\"\"\n    Abstract base class for an agent's odor perception system.\n\n    Each agent in the simulation holds its own instance of a perception class, allowing for\n    individual state (e.g., for adaptation or filtering).\n    \"\"\"\n\n    @abstractmethod\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the internal state of the perception system.\n\n        This should be called at the start of a new simulation run or trial.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Process raw odor inputs and return perceived values.\n\n        Args:\n            raw_left (float): The raw odor concentration at the left sensor.\n            raw_right (float): The raw odor concentration at the right sensor.\n            dt (float): The time step duration in seconds.\n\n        Returns:\n            Tuple[float, float]: A tuple (perceived_left, perceived_right) representing the\n                                 processed odor signals used for behavior.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AgentOdorPerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>  <code>abstractmethod</code>","text":"<p>Process raw odor inputs and return perceived values.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>The raw odor concentration at the left sensor.</p> required <code>raw_right</code> <code>float</code> <p>The raw odor concentration at the right sensor.</p> required <code>dt</code> <code>float</code> <p>The time step duration in seconds.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: A tuple (perceived_left, perceived_right) representing the                  processed odor signals used for behavior.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>@abstractmethod\ndef perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Process raw odor inputs and return perceived values.\n\n    Args:\n        raw_left (float): The raw odor concentration at the left sensor.\n        raw_right (float): The raw odor concentration at the right sensor.\n        dt (float): The time step duration in seconds.\n\n    Returns:\n        Tuple[float, float]: A tuple (perceived_left, perceived_right) representing the\n                             processed odor signals used for behavior.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.AgentOdorPerception.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Reset the internal state of the perception system.</p> <p>This should be called at the start of a new simulation run or trial.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>@abstractmethod\ndef reset(self) -&gt; None:\n    \"\"\"\n    Reset the internal state of the perception system.\n\n    This should be called at the start of a new simulation run or trial.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.DerivativePerception","title":"<code>DerivativePerception</code>","text":"<p>               Bases: <code>AgentOdorPerception</code></p> <p>A perception model that computes the temporal derivative of the odor signal.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class DerivativePerception(AgentOdorPerception):\n    \"\"\"\n    A perception model that computes the temporal derivative of the odor signal.\n    \"\"\"\n\n    def __init__(self, scale: float = 0.1):\n        \"\"\"\n        Initialize the derivative perception model.\n\n        Args:\n            scale (float): Scaling factor for the derivative.\n        \"\"\"\n        self.previous_left = 0.0\n        self.previous_right = 0.0\n        self.scale = scale\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset previous values to zero.\"\"\"\n        self.previous_left = 0.0\n        self.previous_right = 0.0\n\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Compute the derivative of the odor signal.\n\n        Args:\n            raw_left (float): Raw left odor.\n            raw_right (float): Raw right odor.\n            dt (float): Time step.\n\n        Returns:\n            Tuple[float, float]: (derivative_left, derivative_right).\n        \"\"\"\n        # Compute the derivative of the raw values\n        derivative_left = self.scale * (raw_left - self.previous_left) / dt\n        derivative_right = self.scale * (raw_right - self.previous_right) / dt\n\n        # Update the previous values for the next step\n        self.previous_left = raw_left\n        self.previous_right = raw_right\n\n        return (derivative_left, derivative_right)\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.DerivativePerception.__init__","title":"<code>__init__(scale=0.1)</code>","text":"<p>Initialize the derivative perception model.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Scaling factor for the derivative.</p> <code>0.1</code> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def __init__(self, scale: float = 0.1):\n    \"\"\"\n    Initialize the derivative perception model.\n\n    Args:\n        scale (float): Scaling factor for the derivative.\n    \"\"\"\n    self.previous_left = 0.0\n    self.previous_right = 0.0\n    self.scale = scale\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.DerivativePerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>","text":"<p>Compute the derivative of the odor signal.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>Raw left odor.</p> required <code>raw_right</code> <code>float</code> <p>Raw right odor.</p> required <code>dt</code> <code>float</code> <p>Time step.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: (derivative_left, derivative_right).</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Compute the derivative of the odor signal.\n\n    Args:\n        raw_left (float): Raw left odor.\n        raw_right (float): Raw right odor.\n        dt (float): Time step.\n\n    Returns:\n        Tuple[float, float]: (derivative_left, derivative_right).\n    \"\"\"\n    # Compute the derivative of the raw values\n    derivative_left = self.scale * (raw_left - self.previous_left) / dt\n    derivative_right = self.scale * (raw_right - self.previous_right) / dt\n\n    # Update the previous values for the next step\n    self.previous_left = raw_left\n    self.previous_right = raw_right\n\n    return (derivative_left, derivative_right)\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.DerivativePerception.reset","title":"<code>reset()</code>","text":"<p>Reset previous values to zero.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset previous values to zero.\"\"\"\n    self.previous_left = 0.0\n    self.previous_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.LeakAdaptationPerception","title":"<code>LeakAdaptationPerception</code>","text":"<p>               Bases: <code>AgentOdorPerception</code></p> <p>AdaptationPerception implements an odor integration and adaptation mechanism.</p> <p>The dynamics follow:</p> <pre><code>dO/dt = (-O + raw - A) / odor_integration_tau\ndA/dt = (-A + (adaptation_magnitude * O)) / adaptation_tau\n</code></pre> where <p>\u2022 O is the integrated odor signal. \u2022 A is the adaptation variable.</p> <p>The perceived odor at each sensor is simply given by the current integrated signal O.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class LeakAdaptationPerception(AgentOdorPerception):\n    \"\"\"\n    AdaptationPerception implements an odor integration and adaptation mechanism.\n\n    The dynamics follow:\n\n        dO/dt = (-O + raw - A) / odor_integration_tau\n        dA/dt = (-A + (adaptation_magnitude * O)) / adaptation_tau\n\n    where:\n      \u2022 O is the integrated odor signal.\n      \u2022 A is the adaptation variable.\n\n    The perceived odor at each sensor is simply given by the current integrated signal O.\n    \"\"\"\n\n    def __init__(\n        self,\n        odor_integration_tau: float = 1.0,\n        adaptation_tau: float = 5.0,\n        adaptation_magnitude: float = 0.5,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the leak adaptation model.\n\n        Args:\n            odor_integration_tau (float): Time constant for odor integration (in seconds).\n            adaptation_tau (float): Time constant for adaptation recovery (in seconds).\n            adaptation_magnitude (float): Strength of the odor\u2019s influence on adaptation.\n\n        Raises:\n            ValueError: If time constants are not positive.\n        \"\"\"\n        if odor_integration_tau &lt;= 0:\n            raise ValueError(\"odor_integration_tau must be positive.\")\n        if adaptation_tau &lt;= 0:\n            raise ValueError(\"adaptation_tau must be positive.\")\n\n        self.odor_integration_tau = odor_integration_tau\n        self.adaptation_tau = adaptation_tau\n        self.adaptation_magnitude = adaptation_magnitude\n\n        # Initialize state variables for each sensor.\n        self.integrated_left = 0.0\n        self.integrated_right = 0.0\n        self.adapt_left = 0.0\n        self.adapt_right = 0.0\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the integrated odor and adaptation variables to initial values.\"\"\"\n        self.integrated_left = 0.0\n        self.integrated_right = 0.0\n        self.adapt_left = 0.0\n        self.adapt_right = 0.0\n\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Integrate the odor signal and update adaptation variables using Euler integration.\n\n        Args:\n            raw_left (float): Raw odor intensity at the left sensor.\n            raw_right (float): Raw odor intensity at the right sensor.\n            dt (float): Time step in seconds (must be positive).\n\n        Returns:\n            Tuple[float, float]: The perceived odor intensities for the left and right sensors.\n        \"\"\"\n        if dt &lt;= 0:\n            raise ValueError(\"dt must be positive.\")\n\n        # Update the integrated odor signals using Euler's method.\n        d_integrated_left = (\n            -self.integrated_left + raw_left - self.adapt_left\n        ) / self.odor_integration_tau\n        d_integrated_right = (\n            -self.integrated_right + raw_right - self.adapt_right\n        ) / self.odor_integration_tau\n\n        self.integrated_left += d_integrated_left * dt\n        self.integrated_right += d_integrated_right * dt\n\n        # Update adaptation variables.\n        d_adapt_left = (\n            -self.adapt_left + self.adaptation_magnitude * self.integrated_left\n        ) / self.adaptation_tau\n        d_adapt_right = (\n            -self.adapt_right + self.adaptation_magnitude * self.integrated_right\n        ) / self.adaptation_tau\n\n        self.adapt_left += d_adapt_left * dt\n        self.adapt_right += d_adapt_right * dt\n\n        # Perceived odor is provided by the integrated (adapted) odor signal.\n        return self.integrated_left, self.integrated_right\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.LeakAdaptationPerception.__init__","title":"<code>__init__(odor_integration_tau=1.0, adaptation_tau=5.0, adaptation_magnitude=0.5)</code>","text":"<p>Initialize the leak adaptation model.</p> <p>Parameters:</p> Name Type Description Default <code>odor_integration_tau</code> <code>float</code> <p>Time constant for odor integration (in seconds).</p> <code>1.0</code> <code>adaptation_tau</code> <code>float</code> <p>Time constant for adaptation recovery (in seconds).</p> <code>5.0</code> <code>adaptation_magnitude</code> <code>float</code> <p>Strength of the odor\u2019s influence on adaptation.</p> <code>0.5</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If time constants are not positive.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def __init__(\n    self,\n    odor_integration_tau: float = 1.0,\n    adaptation_tau: float = 5.0,\n    adaptation_magnitude: float = 0.5,\n) -&gt; None:\n    \"\"\"\n    Initialize the leak adaptation model.\n\n    Args:\n        odor_integration_tau (float): Time constant for odor integration (in seconds).\n        adaptation_tau (float): Time constant for adaptation recovery (in seconds).\n        adaptation_magnitude (float): Strength of the odor\u2019s influence on adaptation.\n\n    Raises:\n        ValueError: If time constants are not positive.\n    \"\"\"\n    if odor_integration_tau &lt;= 0:\n        raise ValueError(\"odor_integration_tau must be positive.\")\n    if adaptation_tau &lt;= 0:\n        raise ValueError(\"adaptation_tau must be positive.\")\n\n    self.odor_integration_tau = odor_integration_tau\n    self.adaptation_tau = adaptation_tau\n    self.adaptation_magnitude = adaptation_magnitude\n\n    # Initialize state variables for each sensor.\n    self.integrated_left = 0.0\n    self.integrated_right = 0.0\n    self.adapt_left = 0.0\n    self.adapt_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.LeakAdaptationPerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>","text":"<p>Integrate the odor signal and update adaptation variables using Euler integration.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>Raw odor intensity at the left sensor.</p> required <code>raw_right</code> <code>float</code> <p>Raw odor intensity at the right sensor.</p> required <code>dt</code> <code>float</code> <p>Time step in seconds (must be positive).</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: The perceived odor intensities for the left and right sensors.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Integrate the odor signal and update adaptation variables using Euler integration.\n\n    Args:\n        raw_left (float): Raw odor intensity at the left sensor.\n        raw_right (float): Raw odor intensity at the right sensor.\n        dt (float): Time step in seconds (must be positive).\n\n    Returns:\n        Tuple[float, float]: The perceived odor intensities for the left and right sensors.\n    \"\"\"\n    if dt &lt;= 0:\n        raise ValueError(\"dt must be positive.\")\n\n    # Update the integrated odor signals using Euler's method.\n    d_integrated_left = (\n        -self.integrated_left + raw_left - self.adapt_left\n    ) / self.odor_integration_tau\n    d_integrated_right = (\n        -self.integrated_right + raw_right - self.adapt_right\n    ) / self.odor_integration_tau\n\n    self.integrated_left += d_integrated_left * dt\n    self.integrated_right += d_integrated_right * dt\n\n    # Update adaptation variables.\n    d_adapt_left = (\n        -self.adapt_left + self.adaptation_magnitude * self.integrated_left\n    ) / self.adaptation_tau\n    d_adapt_right = (\n        -self.adapt_right + self.adaptation_magnitude * self.integrated_right\n    ) / self.adaptation_tau\n\n    self.adapt_left += d_adapt_left * dt\n    self.adapt_right += d_adapt_right * dt\n\n    # Perceived odor is provided by the integrated (adapted) odor signal.\n    return self.integrated_left, self.integrated_right\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.LeakAdaptationPerception.reset","title":"<code>reset()</code>","text":"<p>Reset the integrated odor and adaptation variables to initial values.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the integrated odor and adaptation variables to initial values.\"\"\"\n    self.integrated_left = 0.0\n    self.integrated_right = 0.0\n    self.adapt_left = 0.0\n    self.adapt_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.LowPassPerception","title":"<code>LowPassPerception</code>","text":"<p>               Bases: <code>AgentOdorPerception</code></p> <p>A perception model that applies a first-order low-pass filter to the odor signals. This simulates the temporal integration properties of sensory neurons.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class LowPassPerception(AgentOdorPerception):\n    \"\"\"\n    A perception model that applies a first-order low-pass filter to the odor signals.\n    This simulates the temporal integration properties of sensory neurons.\n    \"\"\"\n\n    def __init__(self, tau: float = 0.1):\n        \"\"\"\n        Initialize the low-pass filter.\n\n        Args:\n            tau (float): The time constant of the filter in seconds.\n        \"\"\"\n        self.tau = tau\n        self.state_left = 0.0\n        self.state_right = 0.0\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset filter states to zero.\"\"\"\n        self.state_left = 0.0\n        self.state_right = 0.0\n\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Apply low-pass filtering.\n\n        Args:\n            raw_left (float): Raw left odor.\n            raw_right (float): Raw right odor.\n            dt (float): Time step.\n\n        Returns:\n            Tuple[float, float]: Filtered (left, right) odor values.\n        \"\"\"\n        # Apply low-pass filtering to the raw values\n        self.state_left += dt / self.tau * (raw_left - self.state_left)\n        self.state_right += dt / self.tau * (raw_right - self.state_right)\n        return (self.state_left, self.state_right)\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.LowPassPerception.__init__","title":"<code>__init__(tau=0.1)</code>","text":"<p>Initialize the low-pass filter.</p> <p>Parameters:</p> Name Type Description Default <code>tau</code> <code>float</code> <p>The time constant of the filter in seconds.</p> <code>0.1</code> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def __init__(self, tau: float = 0.1):\n    \"\"\"\n    Initialize the low-pass filter.\n\n    Args:\n        tau (float): The time constant of the filter in seconds.\n    \"\"\"\n    self.tau = tau\n    self.state_left = 0.0\n    self.state_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.LowPassPerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>","text":"<p>Apply low-pass filtering.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>Raw left odor.</p> required <code>raw_right</code> <code>float</code> <p>Raw right odor.</p> required <code>dt</code> <code>float</code> <p>Time step.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: Filtered (left, right) odor values.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Apply low-pass filtering.\n\n    Args:\n        raw_left (float): Raw left odor.\n        raw_right (float): Raw right odor.\n        dt (float): Time step.\n\n    Returns:\n        Tuple[float, float]: Filtered (left, right) odor values.\n    \"\"\"\n    # Apply low-pass filtering to the raw values\n    self.state_left += dt / self.tau * (raw_left - self.state_left)\n    self.state_right += dt / self.tau * (raw_right - self.state_right)\n    return (self.state_left, self.state_right)\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.LowPassPerception.reset","title":"<code>reset()</code>","text":"<p>Reset filter states to zero.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset filter states to zero.\"\"\"\n    self.state_left = 0.0\n    self.state_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.NoAdaptationPerception","title":"<code>NoAdaptationPerception</code>","text":"<p>               Bases: <code>AgentOdorPerception</code></p> <p>A simple perception model that passes raw odor values through without modification.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class NoAdaptationPerception(AgentOdorPerception):\n    \"\"\"\n    A simple perception model that passes raw odor values through without modification.\n    \"\"\"\n\n    def reset(self) -&gt; None:\n        pass\n\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Return raw odor values directly.\n\n        Args:\n            raw_left (float): Raw left odor.\n            raw_right (float): Raw right odor.\n            dt (float): Time step.\n\n        Returns:\n            Tuple[float, float]: (raw_left, raw_right).\n        \"\"\"\n        return (raw_left, raw_right)\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.NoAdaptationPerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>","text":"<p>Return raw odor values directly.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>Raw left odor.</p> required <code>raw_right</code> <code>float</code> <p>Raw right odor.</p> required <code>dt</code> <code>float</code> <p>Time step.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: (raw_left, raw_right).</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Return raw odor values directly.\n\n    Args:\n        raw_left (float): Raw left odor.\n        raw_right (float): Raw right odor.\n        dt (float): Time step.\n\n    Returns:\n        Tuple[float, float]: (raw_left, raw_right).\n    \"\"\"\n    return (raw_left, raw_right)\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.ScaleAdaptationPerception","title":"<code>ScaleAdaptationPerception</code>","text":"<p>               Bases: <code>AgentOdorPerception</code></p> <p>A perception model that implements gain control adaptation.</p> <p>The perceived intensity is scaled down based on an adaptation variable that tracks the recent history of the stimulus.</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>class ScaleAdaptationPerception(AgentOdorPerception):\n    \"\"\"\n    A perception model that implements gain control adaptation.\n\n    The perceived intensity is scaled down based on an adaptation variable that tracks\n    the recent history of the stimulus.\n    \"\"\"\n\n    def __init__(\n        self, tau_adapt: float = 0.5, tau_recovery: float = 2.0, beta: float = 1.0\n    ):\n        \"\"\"\n        Initialize the scale adaptation model.\n\n        Args:\n            tau_adapt (float): Time constant (in seconds) for adaptation build-up (fast dynamics).\n            tau_recovery (float): Time constant (in seconds) for recovery (slow dynamics).\n            beta (float): Scaling factor that controls how strongly the adaptation variable reduces the response.\n        \"\"\"\n        self.tau_adapt = tau_adapt\n        self.tau_recovery = tau_recovery\n        self.beta = beta\n        # Initialize adaptation variables for left and right sensors.\n        self.adapt_left = 0.0\n        self.adapt_right = 0.0\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the adaptation state (e.g., at the start of a simulation).\"\"\"\n        self.adapt_left = 0.0\n        self.adapt_right = 0.0\n\n    def perceive_odor(\n        self, raw_left: float, raw_right: float, dt: float\n    ) -&gt; Tuple[float, float]:\n        \"\"\"\n        Update the adaptation state and compute the perceived odor.\n\n        The adaptation variable for each sensor is updated with two processes:\n         - A fast adaptation term that causes the variable to move toward the raw stimulus.\n         - A slower recovery term that causes the adaptation variable to decay back toward 0.\n\n        The perceived odor is then computed as the raw odor divided by a factor (1 + beta * adaptation).\n        This results in reduced perceived odor when adaptation is high.\n\n        Args:\n            raw_left (float): Raw left odor.\n            raw_right (float): Raw right odor.\n            dt (float): Time step.\n\n        Returns:\n            Tuple[float, float]: (perceived_left, perceived_right).\n        \"\"\"\n        # Update adaptation state for left sensor:\n        dA_left = (\n            raw_left - self.adapt_left\n        ) / self.tau_adapt  # fast build-up toward current stimulus\n        recovery_left = -self.adapt_left / self.tau_recovery  # slow recovery (decay)\n        self.adapt_left += dt * (dA_left + recovery_left)\n        # Ensure adaptation stays nonnegative.\n        self.adapt_left = max(self.adapt_left, 0.0)\n\n        # Update adaptation state for right sensor:\n        dA_right = (raw_right - self.adapt_right) / self.tau_adapt\n        recovery_right = -self.adapt_right / self.tau_recovery\n        self.adapt_right += dt * (dA_right + recovery_right)\n        self.adapt_right = max(self.adapt_right, 0.0)\n\n        # Compute perceived odor. When adaptation is high, the effective gain decreases.\n        perceived_left = raw_left / (1 + self.beta * self.adapt_left)\n        perceived_right = raw_right / (1 + self.beta * self.adapt_right)\n        return (perceived_left, perceived_right)\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.ScaleAdaptationPerception.__init__","title":"<code>__init__(tau_adapt=0.5, tau_recovery=2.0, beta=1.0)</code>","text":"<p>Initialize the scale adaptation model.</p> <p>Parameters:</p> Name Type Description Default <code>tau_adapt</code> <code>float</code> <p>Time constant (in seconds) for adaptation build-up (fast dynamics).</p> <code>0.5</code> <code>tau_recovery</code> <code>float</code> <p>Time constant (in seconds) for recovery (slow dynamics).</p> <code>2.0</code> <code>beta</code> <code>float</code> <p>Scaling factor that controls how strongly the adaptation variable reduces the response.</p> <code>1.0</code> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def __init__(\n    self, tau_adapt: float = 0.5, tau_recovery: float = 2.0, beta: float = 1.0\n):\n    \"\"\"\n    Initialize the scale adaptation model.\n\n    Args:\n        tau_adapt (float): Time constant (in seconds) for adaptation build-up (fast dynamics).\n        tau_recovery (float): Time constant (in seconds) for recovery (slow dynamics).\n        beta (float): Scaling factor that controls how strongly the adaptation variable reduces the response.\n    \"\"\"\n    self.tau_adapt = tau_adapt\n    self.tau_recovery = tau_recovery\n    self.beta = beta\n    # Initialize adaptation variables for left and right sensors.\n    self.adapt_left = 0.0\n    self.adapt_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.ScaleAdaptationPerception.perceive_odor","title":"<code>perceive_odor(raw_left, raw_right, dt)</code>","text":"<p>Update the adaptation state and compute the perceived odor.</p> The adaptation variable for each sensor is updated with two processes <ul> <li>A fast adaptation term that causes the variable to move toward the raw stimulus.</li> <li>A slower recovery term that causes the adaptation variable to decay back toward 0.</li> </ul> <p>The perceived odor is then computed as the raw odor divided by a factor (1 + beta * adaptation). This results in reduced perceived odor when adaptation is high.</p> <p>Parameters:</p> Name Type Description Default <code>raw_left</code> <code>float</code> <p>Raw left odor.</p> required <code>raw_right</code> <code>float</code> <p>Raw right odor.</p> required <code>dt</code> <code>float</code> <p>Time step.</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: (perceived_left, perceived_right).</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def perceive_odor(\n    self, raw_left: float, raw_right: float, dt: float\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Update the adaptation state and compute the perceived odor.\n\n    The adaptation variable for each sensor is updated with two processes:\n     - A fast adaptation term that causes the variable to move toward the raw stimulus.\n     - A slower recovery term that causes the adaptation variable to decay back toward 0.\n\n    The perceived odor is then computed as the raw odor divided by a factor (1 + beta * adaptation).\n    This results in reduced perceived odor when adaptation is high.\n\n    Args:\n        raw_left (float): Raw left odor.\n        raw_right (float): Raw right odor.\n        dt (float): Time step.\n\n    Returns:\n        Tuple[float, float]: (perceived_left, perceived_right).\n    \"\"\"\n    # Update adaptation state for left sensor:\n    dA_left = (\n        raw_left - self.adapt_left\n    ) / self.tau_adapt  # fast build-up toward current stimulus\n    recovery_left = -self.adapt_left / self.tau_recovery  # slow recovery (decay)\n    self.adapt_left += dt * (dA_left + recovery_left)\n    # Ensure adaptation stays nonnegative.\n    self.adapt_left = max(self.adapt_left, 0.0)\n\n    # Update adaptation state for right sensor:\n    dA_right = (raw_right - self.adapt_right) / self.tau_adapt\n    recovery_right = -self.adapt_right / self.tau_recovery\n    self.adapt_right += dt * (dA_right + recovery_right)\n    self.adapt_right = max(self.adapt_right, 0.0)\n\n    # Compute perceived odor. When adaptation is high, the effective gain decreases.\n    perceived_left = raw_left / (1 + self.beta * self.adapt_left)\n    perceived_right = raw_right / (1 + self.beta * self.adapt_right)\n    return (perceived_left, perceived_right)\n</code></pre>"},{"location":"api/sim/odor_perception/#arthroscape.sim.odor_perception.ScaleAdaptationPerception.reset","title":"<code>reset()</code>","text":"<p>Reset the adaptation state (e.g., at the start of a simulation).</p> Source code in <code>arthroscape/sim/odor_perception.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the adaptation state (e.g., at the start of a simulation).\"\"\"\n    self.adapt_left = 0.0\n    self.adapt_right = 0.0\n</code></pre>"},{"location":"api/sim/odor_release/","title":"Odor Release","text":""},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release","title":"<code>arthroscape.sim.odor_release</code>","text":"<p>Odor release module for the ArthroScape simulation.</p> <p>This module defines strategies for how agents release odor into the environment. It includes the <code>OdorReleaseStrategy</code> abstract base class and implementations for constant release and no release. It also handles the generation of Gaussian kernels for odor deposition.</p>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.ConstantOdorRelease","title":"<code>ConstantOdorRelease</code>","text":"<p>               Bases: <code>OdorReleaseStrategy</code></p> <p>Deposits a constant amount of pheromone with a Gaussian spread at each step.</p> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>class ConstantOdorRelease(OdorReleaseStrategy):\n    \"\"\"\n    Deposits a constant amount of pheromone with a Gaussian spread at each step.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: SimulationConfig,\n        deposit_amount: float = 0.5,\n        sigma: float = None,\n        kernel_size: int = None,\n        deposit_offsets: Sequence[Tuple[float, float]] = None,\n    ):\n        \"\"\"\n        Initialize the constant odor release strategy.\n\n        Args:\n            config (SimulationConfig): Simulation configuration.\n            deposit_amount (float): Amount of odor to deposit per step.\n            sigma (float, optional): Standard deviation of the deposit Gaussian. Defaults to config value.\n            kernel_size (int, optional): Size of the deposit kernel. Defaults to config value.\n            deposit_offsets (Sequence[Tuple[float, float]], optional): List of offsets for deposition. Defaults to config value.\n        \"\"\"\n        self.deposit_amount = deposit_amount\n        self.sigma = sigma if sigma is not None else config.deposit_sigma\n        self.kernel_size = (\n            kernel_size if kernel_size is not None else config.deposit_kernel_size\n        )\n        self.deposit_offsets = (\n            deposit_offsets\n            if deposit_offsets is not None\n            else config.odor_deposit_offsets\n        )\n\n    def release_odor(\n        self,\n        state: int,\n        position: Tuple[float, float],\n        heading: float,\n        config: SimulationConfig,\n        rng,\n    ) -&gt; List[DepositInstruction]:\n        \"\"\"\n        Generate a list of DepositInstruction objects based on the provided offsets.\n\n        Args:\n            state (int): Current state of the animal.\n            position (Tuple[float, float]): Current position of the animal.\n            heading (float): Current heading of the animal.\n            config (SimulationConfig): Simulation configuration.\n            rng (np.random.Generator): Random number generator.\n\n        Returns:\n            List[DepositInstruction]: List of DepositInstruction objects.\n        \"\"\"\n        offsets = (\n            self.deposit_offsets\n            if self.deposit_offsets is not None\n            else config.odor_deposit_offsets\n        )\n        instructions = []\n        for offset in offsets:\n            instructions.append(\n                DepositInstruction(\n                    offset=offset,\n                    intensity=self.deposit_amount,\n                    sigma=self.sigma,\n                    kernel_size=self.kernel_size,\n                )\n            )\n        return instructions\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.ConstantOdorRelease.__init__","title":"<code>__init__(config, deposit_amount=0.5, sigma=None, kernel_size=None, deposit_offsets=None)</code>","text":"<p>Initialize the constant odor release strategy.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <code>deposit_amount</code> <code>float</code> <p>Amount of odor to deposit per step.</p> <code>0.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation of the deposit Gaussian. Defaults to config value.</p> <code>None</code> <code>kernel_size</code> <code>int</code> <p>Size of the deposit kernel. Defaults to config value.</p> <code>None</code> <code>deposit_offsets</code> <code>Sequence[Tuple[float, float]]</code> <p>List of offsets for deposition. Defaults to config value.</p> <code>None</code> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>def __init__(\n    self,\n    config: SimulationConfig,\n    deposit_amount: float = 0.5,\n    sigma: float = None,\n    kernel_size: int = None,\n    deposit_offsets: Sequence[Tuple[float, float]] = None,\n):\n    \"\"\"\n    Initialize the constant odor release strategy.\n\n    Args:\n        config (SimulationConfig): Simulation configuration.\n        deposit_amount (float): Amount of odor to deposit per step.\n        sigma (float, optional): Standard deviation of the deposit Gaussian. Defaults to config value.\n        kernel_size (int, optional): Size of the deposit kernel. Defaults to config value.\n        deposit_offsets (Sequence[Tuple[float, float]], optional): List of offsets for deposition. Defaults to config value.\n    \"\"\"\n    self.deposit_amount = deposit_amount\n    self.sigma = sigma if sigma is not None else config.deposit_sigma\n    self.kernel_size = (\n        kernel_size if kernel_size is not None else config.deposit_kernel_size\n    )\n    self.deposit_offsets = (\n        deposit_offsets\n        if deposit_offsets is not None\n        else config.odor_deposit_offsets\n    )\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.ConstantOdorRelease.release_odor","title":"<code>release_odor(state, position, heading, config, rng)</code>","text":"<p>Generate a list of DepositInstruction objects based on the provided offsets.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>Current state of the animal.</p> required <code>position</code> <code>Tuple[float, float]</code> <p>Current position of the animal.</p> required <code>heading</code> <code>float</code> <p>Current heading of the animal.</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <code>rng</code> <code>Generator</code> <p>Random number generator.</p> required <p>Returns:</p> Type Description <code>List[DepositInstruction]</code> <p>List[DepositInstruction]: List of DepositInstruction objects.</p> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>def release_odor(\n    self,\n    state: int,\n    position: Tuple[float, float],\n    heading: float,\n    config: SimulationConfig,\n    rng,\n) -&gt; List[DepositInstruction]:\n    \"\"\"\n    Generate a list of DepositInstruction objects based on the provided offsets.\n\n    Args:\n        state (int): Current state of the animal.\n        position (Tuple[float, float]): Current position of the animal.\n        heading (float): Current heading of the animal.\n        config (SimulationConfig): Simulation configuration.\n        rng (np.random.Generator): Random number generator.\n\n    Returns:\n        List[DepositInstruction]: List of DepositInstruction objects.\n    \"\"\"\n    offsets = (\n        self.deposit_offsets\n        if self.deposit_offsets is not None\n        else config.odor_deposit_offsets\n    )\n    instructions = []\n    for offset in offsets:\n        instructions.append(\n            DepositInstruction(\n                offset=offset,\n                intensity=self.deposit_amount,\n                sigma=self.sigma,\n                kernel_size=self.kernel_size,\n            )\n        )\n    return instructions\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.DefaultOdorRelease","title":"<code>DefaultOdorRelease</code>","text":"<p>               Bases: <code>OdorReleaseStrategy</code></p> <p>A default strategy that releases no odor.</p> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>class DefaultOdorRelease(OdorReleaseStrategy):\n    \"\"\"\n    A default strategy that releases no odor.\n    \"\"\"\n\n    def release_odor(\n        self,\n        state: int,\n        position: Tuple[float, float],\n        heading: float,\n        config: SimulationConfig,\n        rng,\n    ) -&gt; List[DepositInstruction]:\n        \"\"\"\n        Return an empty list (no odor release).\n        \"\"\"\n        return []\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.DefaultOdorRelease.release_odor","title":"<code>release_odor(state, position, heading, config, rng)</code>","text":"<p>Return an empty list (no odor release).</p> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>def release_odor(\n    self,\n    state: int,\n    position: Tuple[float, float],\n    heading: float,\n    config: SimulationConfig,\n    rng,\n) -&gt; List[DepositInstruction]:\n    \"\"\"\n    Return an empty list (no odor release).\n    \"\"\"\n    return []\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.DepositInstruction","title":"<code>DepositInstruction</code>","text":"<p>A data structure representing a request to deposit odor.</p> <p>It contains all necessary information to generate the deposition kernel and place it relative to the agent.</p> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>class DepositInstruction:\n    \"\"\"\n    A data structure representing a request to deposit odor.\n\n    It contains all necessary information to generate the deposition kernel and place it\n    relative to the agent.\n    \"\"\"\n\n    def __init__(\n        self,\n        offset: Tuple[float, float],\n        intensity: float,\n        sigma: float,\n        kernel_size: int = None,\n    ):\n        \"\"\"\n        Initialize a deposit instruction.\n\n        Args:\n            offset (Tuple[float, float]): (dx, dy) offset in the animal's local coordinate frame (mm).\n            intensity (float): Overall intensity multiplier (amount of odor).\n            sigma (float): Standard deviation for the Gaussian deposit (in mm).\n            kernel_size (int, optional): Kernel size (number of grid cells, assumed odd).\n                                         If None, will use config value.\n        \"\"\"\n        self.offset = offset\n        self.intensity = intensity\n        self.sigma = sigma\n        self.kernel_size = kernel_size\n\n    def generate_kernel(self, config: SimulationConfig) -&gt; np.ndarray:\n        \"\"\"\n        Generate the deposition kernel.\n\n        Retrieves a cached normalized kernel and scales it by the intensity.\n\n        Args:\n            config (SimulationConfig): Simulation configuration.\n\n        Returns:\n            np.ndarray: The scaled 2D deposition kernel.\n        \"\"\"\n        ksize = (\n            self.kernel_size\n            if self.kernel_size is not None\n            else config.deposit_kernel_size\n        )\n        normalized_kernel = _get_normalized_gaussian_kernel(\n            self.sigma, ksize, config.grid_resolution\n        )\n        return normalized_kernel * self.intensity\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.DepositInstruction.__init__","title":"<code>__init__(offset, intensity, sigma, kernel_size=None)</code>","text":"<p>Initialize a deposit instruction.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>Tuple[float, float]</code> <p>(dx, dy) offset in the animal's local coordinate frame (mm).</p> required <code>intensity</code> <code>float</code> <p>Overall intensity multiplier (amount of odor).</p> required <code>sigma</code> <code>float</code> <p>Standard deviation for the Gaussian deposit (in mm).</p> required <code>kernel_size</code> <code>int</code> <p>Kernel size (number of grid cells, assumed odd).                          If None, will use config value.</p> <code>None</code> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>def __init__(\n    self,\n    offset: Tuple[float, float],\n    intensity: float,\n    sigma: float,\n    kernel_size: int = None,\n):\n    \"\"\"\n    Initialize a deposit instruction.\n\n    Args:\n        offset (Tuple[float, float]): (dx, dy) offset in the animal's local coordinate frame (mm).\n        intensity (float): Overall intensity multiplier (amount of odor).\n        sigma (float): Standard deviation for the Gaussian deposit (in mm).\n        kernel_size (int, optional): Kernel size (number of grid cells, assumed odd).\n                                     If None, will use config value.\n    \"\"\"\n    self.offset = offset\n    self.intensity = intensity\n    self.sigma = sigma\n    self.kernel_size = kernel_size\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.DepositInstruction.generate_kernel","title":"<code>generate_kernel(config)</code>","text":"<p>Generate the deposition kernel.</p> <p>Retrieves a cached normalized kernel and scales it by the intensity.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The scaled 2D deposition kernel.</p> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>def generate_kernel(self, config: SimulationConfig) -&gt; np.ndarray:\n    \"\"\"\n    Generate the deposition kernel.\n\n    Retrieves a cached normalized kernel and scales it by the intensity.\n\n    Args:\n        config (SimulationConfig): Simulation configuration.\n\n    Returns:\n        np.ndarray: The scaled 2D deposition kernel.\n    \"\"\"\n    ksize = (\n        self.kernel_size\n        if self.kernel_size is not None\n        else config.deposit_kernel_size\n    )\n    normalized_kernel = _get_normalized_gaussian_kernel(\n        self.sigma, ksize, config.grid_resolution\n    )\n    return normalized_kernel * self.intensity\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.OdorReleaseStrategy","title":"<code>OdorReleaseStrategy</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for odor release strategies.</p> <p>A release strategy determines when and how much odor an agent releases into the environment.</p> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>class OdorReleaseStrategy(ABC):\n    \"\"\"\n    Abstract base class for odor release strategies.\n\n    A release strategy determines when and how much odor an agent releases into the environment.\n    \"\"\"\n\n    @abstractmethod\n    def release_odor(\n        self,\n        state: int,\n        position: Tuple[float, float],\n        heading: float,\n        config: SimulationConfig,\n        rng,\n    ) -&gt; List[DepositInstruction]:\n        \"\"\"\n        Determine odor release for the current time step.\n\n        Args:\n            state (int): Current state of the agent.\n            position (Tuple[float, float]): Current position (x, y).\n            heading (float): Current heading in radians.\n            config (SimulationConfig): Simulation configuration.\n            rng (np.random.Generator): Random number generator.\n\n        Returns:\n            List[DepositInstruction]: A list of instructions for depositing odor.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sim/odor_release/#arthroscape.sim.odor_release.OdorReleaseStrategy.release_odor","title":"<code>release_odor(state, position, heading, config, rng)</code>  <code>abstractmethod</code>","text":"<p>Determine odor release for the current time step.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>Current state of the agent.</p> required <code>position</code> <code>Tuple[float, float]</code> <p>Current position (x, y).</p> required <code>heading</code> <code>float</code> <p>Current heading in radians.</p> required <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <code>rng</code> <code>Generator</code> <p>Random number generator.</p> required <p>Returns:</p> Type Description <code>List[DepositInstruction]</code> <p>List[DepositInstruction]: A list of instructions for depositing odor.</p> Source code in <code>arthroscape/sim/odor_release.py</code> <pre><code>@abstractmethod\ndef release_odor(\n    self,\n    state: int,\n    position: Tuple[float, float],\n    heading: float,\n    config: SimulationConfig,\n    rng,\n) -&gt; List[DepositInstruction]:\n    \"\"\"\n    Determine odor release for the current time step.\n\n    Args:\n        state (int): Current state of the agent.\n        position (Tuple[float, float]): Current position (x, y).\n        heading (float): Current heading in radians.\n        config (SimulationConfig): Simulation configuration.\n        rng (np.random.Generator): Random number generator.\n\n    Returns:\n        List[DepositInstruction]: A list of instructions for depositing odor.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/odor_sources/","title":"Odor Sources","text":"<p>External odor source loading and manipulation for ArthroScape simulations.</p> <p>This module provides classes and utilities for loading odor distributions from external sources such as images and videos. These can be used to create complex, realistic odor landscapes that would be difficult to generate programmatically.</p>"},{"location":"api/sim/odor_sources/#base-class","title":"Base Class","text":""},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.OdorSource","title":"<code>arthroscape.sim.odor_sources.OdorSource</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for external odor sources.</p> <p>An odor source provides a 2D array of odor concentrations that can be applied to an arena's odor grid.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>class OdorSource(ABC):\n    \"\"\"\n    Abstract base class for external odor sources.\n\n    An odor source provides a 2D array of odor concentrations that can be\n    applied to an arena's odor grid.\n    \"\"\"\n\n    @abstractmethod\n    def get_odor_map(self, target_shape: Tuple[int, int]) -&gt; np.ndarray:\n        \"\"\"\n        Get the odor map resized to the target shape.\n\n        Args:\n            target_shape (Tuple[int, int]): Target shape (ny, nx) matching the arena grid.\n\n        Returns:\n            np.ndarray: 2D array of odor concentrations.\n        \"\"\"\n        pass\n\n    def apply_to_arena(\n        self,\n        arena: \"Arena\",\n        mode: str = \"replace\",\n        scale: float = 1.0,\n        offset: float = 0.0,\n    ) -&gt; None:\n        \"\"\"\n        Apply this odor source to an arena's odor grid.\n\n        Args:\n            arena (Arena): The arena object with an `odor_grid` attribute.\n            mode (str): How to apply the odor map:\n                - \"replace\": Replace the arena's odor grid entirely.\n                - \"add\": Add to the existing odor grid.\n                - \"multiply\": Multiply with the existing odor grid.\n                - \"max\": Take the element-wise maximum.\n            scale (float): Scaling factor applied to the odor values.\n            offset (float): Offset added after scaling.\n        \"\"\"\n        odor_map = self.get_odor_map((arena.ny, arena.nx))\n        scaled_map = odor_map * scale + offset\n\n        if mode == \"replace\":\n            arena.odor_grid = scaled_map.copy()\n        elif mode == \"add\":\n            arena.odor_grid += scaled_map\n        elif mode == \"multiply\":\n            arena.odor_grid *= scaled_map\n        elif mode == \"max\":\n            arena.odor_grid = np.maximum(arena.odor_grid, scaled_map)\n        else:\n            raise ValueError(\n                f\"Unknown mode: {mode}. Use 'replace', 'add', 'multiply', or 'max'.\"\n            )\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.OdorSource.apply_to_arena","title":"<code>apply_to_arena(arena, mode='replace', scale=1.0, offset=0.0)</code>","text":"<p>Apply this odor source to an arena's odor grid.</p> <p>Parameters:</p> Name Type Description Default <code>arena</code> <code>Arena</code> <p>The arena object with an <code>odor_grid</code> attribute.</p> required <code>mode</code> <code>str</code> <p>How to apply the odor map: - \"replace\": Replace the arena's odor grid entirely. - \"add\": Add to the existing odor grid. - \"multiply\": Multiply with the existing odor grid. - \"max\": Take the element-wise maximum.</p> <code>'replace'</code> <code>scale</code> <code>float</code> <p>Scaling factor applied to the odor values.</p> <code>1.0</code> <code>offset</code> <code>float</code> <p>Offset added after scaling.</p> <code>0.0</code> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def apply_to_arena(\n    self,\n    arena: \"Arena\",\n    mode: str = \"replace\",\n    scale: float = 1.0,\n    offset: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Apply this odor source to an arena's odor grid.\n\n    Args:\n        arena (Arena): The arena object with an `odor_grid` attribute.\n        mode (str): How to apply the odor map:\n            - \"replace\": Replace the arena's odor grid entirely.\n            - \"add\": Add to the existing odor grid.\n            - \"multiply\": Multiply with the existing odor grid.\n            - \"max\": Take the element-wise maximum.\n        scale (float): Scaling factor applied to the odor values.\n        offset (float): Offset added after scaling.\n    \"\"\"\n    odor_map = self.get_odor_map((arena.ny, arena.nx))\n    scaled_map = odor_map * scale + offset\n\n    if mode == \"replace\":\n        arena.odor_grid = scaled_map.copy()\n    elif mode == \"add\":\n        arena.odor_grid += scaled_map\n    elif mode == \"multiply\":\n        arena.odor_grid *= scaled_map\n    elif mode == \"max\":\n        arena.odor_grid = np.maximum(arena.odor_grid, scaled_map)\n    else:\n        raise ValueError(\n            f\"Unknown mode: {mode}. Use 'replace', 'add', 'multiply', or 'max'.\"\n        )\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.OdorSource.get_odor_map","title":"<code>get_odor_map(target_shape)</code>  <code>abstractmethod</code>","text":"<p>Get the odor map resized to the target shape.</p> <p>Parameters:</p> Name Type Description Default <code>target_shape</code> <code>Tuple[int, int]</code> <p>Target shape (ny, nx) matching the arena grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 2D array of odor concentrations.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>@abstractmethod\ndef get_odor_map(self, target_shape: Tuple[int, int]) -&gt; np.ndarray:\n    \"\"\"\n    Get the odor map resized to the target shape.\n\n    Args:\n        target_shape (Tuple[int, int]): Target shape (ny, nx) matching the arena grid.\n\n    Returns:\n        np.ndarray: 2D array of odor concentrations.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sim/odor_sources/#image-source","title":"Image Source","text":""},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.ImageOdorSource","title":"<code>arthroscape.sim.odor_sources.ImageOdorSource</code>","text":"<p>               Bases: <code>OdorSource</code></p> <p>Load a static odor landscape from an image file.</p> <p>The image is converted to grayscale and normalized to [0, 1] by default. You can provide a custom normalization function for more control.</p> <p>Attributes:</p> Name Type Description <code>image_path</code> <code>str</code> <p>Path to the image file.</p> <code>raw_data</code> <code>ndarray</code> <p>The loaded image data (grayscale, float64).</p> <code>invert</code> <code>bool</code> <p>If True, inverts the image (1 - value).</p> <code>normalize_func</code> <code>Callable</code> <p>Custom normalization function.</p> Example <p>source = ImageOdorSource(\"gradient.png\", invert=False) source.apply_to_arena(arena, mode=\"replace\", scale=10.0)</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>class ImageOdorSource(OdorSource):\n    \"\"\"\n    Load a static odor landscape from an image file.\n\n    The image is converted to grayscale and normalized to [0, 1] by default.\n    You can provide a custom normalization function for more control.\n\n    Attributes:\n        image_path (str): Path to the image file.\n        raw_data (np.ndarray): The loaded image data (grayscale, float64).\n        invert (bool): If True, inverts the image (1 - value).\n        normalize_func (Callable): Custom normalization function.\n\n    Example:\n        &gt;&gt;&gt; source = ImageOdorSource(\"gradient.png\", invert=False)\n        &gt;&gt;&gt; source.apply_to_arena(arena, mode=\"replace\", scale=10.0)\n    \"\"\"\n\n    def __init__(\n        self,\n        image_path: Union[str, Path],\n        invert: bool = False,\n        normalize_func: Optional[Callable[[np.ndarray], np.ndarray]] = None,\n        channel: Optional[int] = None,\n    ):\n        \"\"\"\n        Initialize the ImageOdorSource.\n\n        Args:\n            image_path (Union[str, Path]): Path to the image file.\n            invert (bool): If True, invert the image values (1 - normalized).\n            normalize_func (Optional[Callable]): Custom function to normalize the image.\n                Takes a numpy array and returns a normalized array.\n                If None, uses min-max normalization to [0, 1].\n            channel (Optional[int]): If provided, use only this channel (0=R, 1=G, 2=B).\n                If None, converts to grayscale using standard luminance weights.\n        \"\"\"\n        self.image_path = Path(image_path)\n        self.invert = invert\n        self.normalize_func = normalize_func\n        self.channel = channel\n        self._raw_data: Optional[np.ndarray] = None\n        self._load_image()\n\n    def _load_image(self) -&gt; None:\n        \"\"\"Load and preprocess the image.\"\"\"\n        try:\n            from PIL import Image\n        except ImportError:\n            raise ImportError(\n                \"Pillow is required for ImageOdorSource. \"\n                \"Install it with: pip install Pillow\"\n            )\n\n        if not self.image_path.exists():\n            raise FileNotFoundError(f\"Image not found: {self.image_path}\")\n\n        img = Image.open(self.image_path)\n\n        # Handle channel selection or grayscale conversion\n        if self.channel is not None:\n            img_array = np.array(img)\n            if len(img_array.shape) &lt; 3:\n                logger.warning(\n                    f\"Image is already grayscale, ignoring channel={self.channel}\"\n                )\n                gray = img_array.astype(np.float64)\n            else:\n                gray = img_array[:, :, self.channel].astype(np.float64)\n        else:\n            gray = np.array(img.convert(\"L\"), dtype=np.float64)\n\n        # Normalize\n        if self.normalize_func is not None:\n            normalized = self.normalize_func(gray)\n        else:\n            # Default: min-max normalization to [0, 1]\n            min_val, max_val = gray.min(), gray.max()\n            if max_val &gt; min_val:\n                normalized = (gray - min_val) / (max_val - min_val)\n            else:\n                normalized = np.zeros_like(gray)\n\n        # Invert if requested\n        if self.invert:\n            normalized = 1.0 - normalized\n\n        self._raw_data = normalized\n        logger.info(\n            f\"Loaded image '{self.image_path.name}' with shape {self._raw_data.shape}\"\n        )\n\n    def get_odor_map(self, target_shape: Tuple[int, int]) -&gt; np.ndarray:\n        \"\"\"\n        Get the odor map resized to match the arena grid.\n\n        Args:\n            target_shape (Tuple[int, int]): Target shape (ny, nx).\n\n        Returns:\n            np.ndarray: Resized odor map.\n        \"\"\"\n        from PIL import Image\n\n        # Resize using PIL for high-quality interpolation\n        img = Image.fromarray((self._raw_data * 255).astype(np.uint8))\n        # Note: PIL resize takes (width, height), but our shape is (ny, nx) = (height, width)\n        resized = img.resize(\n            (target_shape[1], target_shape[0]), Image.Resampling.BILINEAR\n        )\n        return np.array(resized, dtype=np.float64) / 255.0\n\n    @property\n    def raw_data(self) -&gt; np.ndarray:\n        \"\"\"Return the raw loaded image data.\"\"\"\n        return self._raw_data\n\n    @property\n    def shape(self) -&gt; Tuple[int, int]:\n        \"\"\"Return the original image shape (height, width).\"\"\"\n        return self._raw_data.shape\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.ImageOdorSource.raw_data","title":"<code>raw_data</code>  <code>property</code>","text":"<p>Return the raw loaded image data.</p>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.ImageOdorSource.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Return the original image shape (height, width).</p>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.ImageOdorSource.__init__","title":"<code>__init__(image_path, invert=False, normalize_func=None, channel=None)</code>","text":"<p>Initialize the ImageOdorSource.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>Union[str, Path]</code> <p>Path to the image file.</p> required <code>invert</code> <code>bool</code> <p>If True, invert the image values (1 - normalized).</p> <code>False</code> <code>normalize_func</code> <code>Optional[Callable]</code> <p>Custom function to normalize the image. Takes a numpy array and returns a normalized array. If None, uses min-max normalization to [0, 1].</p> <code>None</code> <code>channel</code> <code>Optional[int]</code> <p>If provided, use only this channel (0=R, 1=G, 2=B). If None, converts to grayscale using standard luminance weights.</p> <code>None</code> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def __init__(\n    self,\n    image_path: Union[str, Path],\n    invert: bool = False,\n    normalize_func: Optional[Callable[[np.ndarray], np.ndarray]] = None,\n    channel: Optional[int] = None,\n):\n    \"\"\"\n    Initialize the ImageOdorSource.\n\n    Args:\n        image_path (Union[str, Path]): Path to the image file.\n        invert (bool): If True, invert the image values (1 - normalized).\n        normalize_func (Optional[Callable]): Custom function to normalize the image.\n            Takes a numpy array and returns a normalized array.\n            If None, uses min-max normalization to [0, 1].\n        channel (Optional[int]): If provided, use only this channel (0=R, 1=G, 2=B).\n            If None, converts to grayscale using standard luminance weights.\n    \"\"\"\n    self.image_path = Path(image_path)\n    self.invert = invert\n    self.normalize_func = normalize_func\n    self.channel = channel\n    self._raw_data: Optional[np.ndarray] = None\n    self._load_image()\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.ImageOdorSource.get_odor_map","title":"<code>get_odor_map(target_shape)</code>","text":"<p>Get the odor map resized to match the arena grid.</p> <p>Parameters:</p> Name Type Description Default <code>target_shape</code> <code>Tuple[int, int]</code> <p>Target shape (ny, nx).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Resized odor map.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def get_odor_map(self, target_shape: Tuple[int, int]) -&gt; np.ndarray:\n    \"\"\"\n    Get the odor map resized to match the arena grid.\n\n    Args:\n        target_shape (Tuple[int, int]): Target shape (ny, nx).\n\n    Returns:\n        np.ndarray: Resized odor map.\n    \"\"\"\n    from PIL import Image\n\n    # Resize using PIL for high-quality interpolation\n    img = Image.fromarray((self._raw_data * 255).astype(np.uint8))\n    # Note: PIL resize takes (width, height), but our shape is (ny, nx) = (height, width)\n    resized = img.resize(\n        (target_shape[1], target_shape[0]), Image.Resampling.BILINEAR\n    )\n    return np.array(resized, dtype=np.float64) / 255.0\n</code></pre>"},{"location":"api/sim/odor_sources/#video-source","title":"Video Source","text":""},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource","title":"<code>arthroscape.sim.odor_sources.VideoOdorSource</code>","text":"<p>               Bases: <code>OdorSource</code></p> <p>Stream video frames as a dynamic, time-varying odor field.</p> <p>Each frame of the video becomes the odor landscape for that time step. The video can be synchronized with simulation frames using various strategies.</p> <p>Attributes:</p> Name Type Description <code>video_path</code> <code>str</code> <p>Path to the video file.</p> <code>fps</code> <code>float</code> <p>Frame rate of the video.</p> <code>total_frames</code> <code>int</code> <p>Total number of frames in the video.</p> <code>current_frame</code> <code>int</code> <p>Current frame index.</p> Example <p>source = VideoOdorSource(\"plume.mp4\") source.apply_to_arena(arena)  # Apply first frame</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>class VideoOdorSource(OdorSource):\n    \"\"\"\n    Stream video frames as a dynamic, time-varying odor field.\n\n    Each frame of the video becomes the odor landscape for that time step.\n    The video can be synchronized with simulation frames using various strategies.\n\n    Attributes:\n        video_path (str): Path to the video file.\n        fps (float): Frame rate of the video.\n        total_frames (int): Total number of frames in the video.\n        current_frame (int): Current frame index.\n\n    Example:\n        &gt;&gt;&gt; source = VideoOdorSource(\"plume.mp4\")\n        &gt;&gt;&gt; source.apply_to_arena(arena)  # Apply first frame\n        &gt;&gt;&gt; # In simulation loop:\n        &gt;&gt;&gt; source.advance_frame()\n        &gt;&gt;&gt; source.apply_to_arena(arena)\n    \"\"\"\n\n    def __init__(\n        self,\n        video_path: Union[str, Path],\n        loop: bool = True,\n        start_frame: int = 0,\n        end_frame: Optional[int] = None,\n        frame_step: int = 1,\n        invert: bool = False,\n        normalize_func: Optional[Callable[[np.ndarray], np.ndarray]] = None,\n        channel: Optional[int] = None,\n        preload: bool = False,\n    ):\n        \"\"\"\n        Initialize the VideoOdorSource.\n\n        Args:\n            video_path (Union[str, Path]): Path to the video file.\n            loop (bool): If True, loop back to start when video ends.\n            start_frame (int): First frame to use (0-indexed).\n            end_frame (Optional[int]): Last frame to use (exclusive). None means use all.\n            frame_step (int): Step between frames (e.g., 2 means use every other frame).\n            invert (bool): If True, invert the frame values.\n            normalize_func (Optional[Callable]): Custom normalization function.\n            channel (Optional[int]): If provided, use only this channel (0=R, 1=G, 2=B).\n            preload (bool): If True, preload all frames into memory (faster but uses more RAM).\n        \"\"\"\n        self.video_path = Path(video_path)\n        self.loop = loop\n        self.start_frame = start_frame\n        self.end_frame = end_frame\n        self.frame_step = frame_step\n        self.invert = invert\n        self.normalize_func = normalize_func\n        self.channel = channel\n        self.preload = preload\n\n        self._cap = None\n        self._preloaded_frames: Optional[np.ndarray] = None\n        self._current_frame_idx = 0\n        self._current_frame_data: Optional[np.ndarray] = None\n\n        self._open_video()\n\n        if preload:\n            self._preload_all_frames()\n        else:\n            self._read_frame(0)\n\n    def _open_video(self) -&gt; None:\n        \"\"\"Open the video file and read metadata.\"\"\"\n        try:\n            import cv2\n        except ImportError:\n            raise ImportError(\n                \"OpenCV is required for VideoOdorSource. \"\n                \"Install it with: pip install opencv-python\"\n            )\n\n        if not self.video_path.exists():\n            raise FileNotFoundError(f\"Video not found: {self.video_path}\")\n\n        self._cap = cv2.VideoCapture(str(self.video_path))\n        if not self._cap.isOpened():\n            raise IOError(f\"Could not open video: {self.video_path}\")\n\n        self._total_video_frames = int(self._cap.get(cv2.CAP_PROP_FRAME_COUNT))\n        self._video_fps = self._cap.get(cv2.CAP_PROP_FPS)\n        self._video_width = int(self._cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n        self._video_height = int(self._cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n\n        # Calculate effective range\n        self._effective_end = (\n            self.end_frame if self.end_frame is not None else self._total_video_frames\n        )\n        self._effective_end = min(self._effective_end, self._total_video_frames)\n        self._effective_frames = list(\n            range(self.start_frame, self._effective_end, self.frame_step)\n        )\n\n        logger.info(\n            f\"Opened video '{self.video_path.name}': \"\n            f\"{self._video_width}x{self._video_height}, {self._video_fps} fps, \"\n            f\"{len(self._effective_frames)} effective frames\"\n        )\n\n    def _preload_all_frames(self) -&gt; None:\n        \"\"\"Preload all frames into memory.\"\"\"\n        import cv2\n\n        frames = []\n        for frame_idx in self._effective_frames:\n            self._cap.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)\n            ret, frame = self._cap.read()\n            if ret:\n                processed = self._process_frame(frame)\n                frames.append(processed)\n            else:\n                logger.warning(f\"Could not read frame {frame_idx}\")\n\n        self._preloaded_frames = np.array(frames)\n        self._current_frame_data = self._preloaded_frames[0]\n        logger.info(f\"Preloaded {len(frames)} frames into memory\")\n\n    def _process_frame(self, frame: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Process a raw video frame into an odor map.\"\"\"\n        import cv2\n\n        # Channel selection or grayscale conversion\n        if self.channel is not None:\n            if len(frame.shape) == 3:\n                # OpenCV uses BGR order\n                channel_map = {0: 2, 1: 1, 2: 0}  # R=2, G=1, B=0 in BGR\n                gray = frame[:, :, channel_map.get(self.channel, self.channel)].astype(\n                    np.float64\n                )\n            else:\n                gray = frame.astype(np.float64)\n        else:\n            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY).astype(np.float64)\n\n        # Normalize\n        if self.normalize_func is not None:\n            normalized = self.normalize_func(gray)\n        else:\n            normalized = gray / 255.0\n\n        # Invert if requested\n        if self.invert:\n            normalized = 1.0 - normalized\n\n        return normalized\n\n    def _read_frame(self, logical_index: int) -&gt; bool:\n        \"\"\"Read a specific frame by logical index (after applying start/step).\"\"\"\n        if self._preloaded_frames is not None:\n            if 0 &lt;= logical_index &lt; len(self._preloaded_frames):\n                self._current_frame_data = self._preloaded_frames[logical_index]\n                self._current_frame_idx = logical_index\n                return True\n            return False\n\n        import cv2\n\n        if logical_index &gt;= len(self._effective_frames):\n            if self.loop:\n                logical_index = logical_index % len(self._effective_frames)\n            else:\n                return False\n\n        video_frame_idx = self._effective_frames[logical_index]\n        self._cap.set(cv2.CAP_PROP_POS_FRAMES, video_frame_idx)\n        ret, frame = self._cap.read()\n\n        if ret:\n            self._current_frame_data = self._process_frame(frame)\n            self._current_frame_idx = logical_index\n            return True\n        return False\n\n    def get_odor_map(self, target_shape: Tuple[int, int]) -&gt; np.ndarray:\n        \"\"\"\n        Get the current frame's odor map resized to target shape.\n\n        Args:\n            target_shape (Tuple[int, int]): Target shape (ny, nx).\n\n        Returns:\n            np.ndarray: Resized odor map from current frame.\n        \"\"\"\n        import cv2\n\n        if self._current_frame_data is None:\n            return np.zeros(target_shape, dtype=np.float64)\n\n        # Resize using OpenCV\n        # cv2.resize takes (width, height), shape is (ny, nx) = (height, width)\n        resized = cv2.resize(\n            self._current_frame_data,\n            (target_shape[1], target_shape[0]),\n            interpolation=cv2.INTER_LINEAR,\n        )\n        return resized\n\n    def advance_frame(self, steps: int = 1) -&gt; bool:\n        \"\"\"\n        Advance to the next frame(s).\n\n        Args:\n            steps (int): Number of logical frames to advance.\n\n        Returns:\n            bool: True if successful, False if end of video (and not looping).\n        \"\"\"\n        new_idx = self._current_frame_idx + steps\n        if new_idx &gt;= len(self._effective_frames):\n            if self.loop:\n                new_idx = new_idx % len(self._effective_frames)\n            else:\n                return False\n        return self._read_frame(new_idx)\n\n    def seek_frame(self, logical_index: int) -&gt; bool:\n        \"\"\"\n        Seek to a specific logical frame index.\n\n        Args:\n            logical_index (int): The frame index to seek to.\n\n        Returns:\n            bool: True if successful.\n        \"\"\"\n        return self._read_frame(logical_index)\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset to the first frame.\"\"\"\n        self._read_frame(0)\n\n    @property\n    def current_frame(self) -&gt; int:\n        \"\"\"Return the current logical frame index.\"\"\"\n        return self._current_frame_idx\n\n    @property\n    def total_frames(self) -&gt; int:\n        \"\"\"Return the total number of effective frames.\"\"\"\n        return len(self._effective_frames)\n\n    @property\n    def fps(self) -&gt; float:\n        \"\"\"Return the video's frame rate.\"\"\"\n        return self._video_fps\n\n    @property\n    def shape(self) -&gt; Tuple[int, int]:\n        \"\"\"Return the original video frame shape (height, width).\"\"\"\n        return (self._video_height, self._video_width)\n\n    def __del__(self):\n        \"\"\"Release video capture on deletion.\"\"\"\n        if self._cap is not None:\n            self._cap.release()\n\n    def close(self) -&gt; None:\n        \"\"\"Explicitly release video resources.\"\"\"\n        if self._cap is not None:\n            self._cap.release()\n            self._cap = None\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource--in-simulation-loop","title":"In simulation loop:","text":"<p>source.advance_frame() source.apply_to_arena(arena)</p>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.current_frame","title":"<code>current_frame</code>  <code>property</code>","text":"<p>Return the current logical frame index.</p>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.fps","title":"<code>fps</code>  <code>property</code>","text":"<p>Return the video's frame rate.</p>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Return the original video frame shape (height, width).</p>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.total_frames","title":"<code>total_frames</code>  <code>property</code>","text":"<p>Return the total number of effective frames.</p>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.__del__","title":"<code>__del__()</code>","text":"<p>Release video capture on deletion.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def __del__(self):\n    \"\"\"Release video capture on deletion.\"\"\"\n    if self._cap is not None:\n        self._cap.release()\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.__init__","title":"<code>__init__(video_path, loop=True, start_frame=0, end_frame=None, frame_step=1, invert=False, normalize_func=None, channel=None, preload=False)</code>","text":"<p>Initialize the VideoOdorSource.</p> <p>Parameters:</p> Name Type Description Default <code>video_path</code> <code>Union[str, Path]</code> <p>Path to the video file.</p> required <code>loop</code> <code>bool</code> <p>If True, loop back to start when video ends.</p> <code>True</code> <code>start_frame</code> <code>int</code> <p>First frame to use (0-indexed).</p> <code>0</code> <code>end_frame</code> <code>Optional[int]</code> <p>Last frame to use (exclusive). None means use all.</p> <code>None</code> <code>frame_step</code> <code>int</code> <p>Step between frames (e.g., 2 means use every other frame).</p> <code>1</code> <code>invert</code> <code>bool</code> <p>If True, invert the frame values.</p> <code>False</code> <code>normalize_func</code> <code>Optional[Callable]</code> <p>Custom normalization function.</p> <code>None</code> <code>channel</code> <code>Optional[int]</code> <p>If provided, use only this channel (0=R, 1=G, 2=B).</p> <code>None</code> <code>preload</code> <code>bool</code> <p>If True, preload all frames into memory (faster but uses more RAM).</p> <code>False</code> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def __init__(\n    self,\n    video_path: Union[str, Path],\n    loop: bool = True,\n    start_frame: int = 0,\n    end_frame: Optional[int] = None,\n    frame_step: int = 1,\n    invert: bool = False,\n    normalize_func: Optional[Callable[[np.ndarray], np.ndarray]] = None,\n    channel: Optional[int] = None,\n    preload: bool = False,\n):\n    \"\"\"\n    Initialize the VideoOdorSource.\n\n    Args:\n        video_path (Union[str, Path]): Path to the video file.\n        loop (bool): If True, loop back to start when video ends.\n        start_frame (int): First frame to use (0-indexed).\n        end_frame (Optional[int]): Last frame to use (exclusive). None means use all.\n        frame_step (int): Step between frames (e.g., 2 means use every other frame).\n        invert (bool): If True, invert the frame values.\n        normalize_func (Optional[Callable]): Custom normalization function.\n        channel (Optional[int]): If provided, use only this channel (0=R, 1=G, 2=B).\n        preload (bool): If True, preload all frames into memory (faster but uses more RAM).\n    \"\"\"\n    self.video_path = Path(video_path)\n    self.loop = loop\n    self.start_frame = start_frame\n    self.end_frame = end_frame\n    self.frame_step = frame_step\n    self.invert = invert\n    self.normalize_func = normalize_func\n    self.channel = channel\n    self.preload = preload\n\n    self._cap = None\n    self._preloaded_frames: Optional[np.ndarray] = None\n    self._current_frame_idx = 0\n    self._current_frame_data: Optional[np.ndarray] = None\n\n    self._open_video()\n\n    if preload:\n        self._preload_all_frames()\n    else:\n        self._read_frame(0)\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.advance_frame","title":"<code>advance_frame(steps=1)</code>","text":"<p>Advance to the next frame(s).</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>int</code> <p>Number of logical frames to advance.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful, False if end of video (and not looping).</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def advance_frame(self, steps: int = 1) -&gt; bool:\n    \"\"\"\n    Advance to the next frame(s).\n\n    Args:\n        steps (int): Number of logical frames to advance.\n\n    Returns:\n        bool: True if successful, False if end of video (and not looping).\n    \"\"\"\n    new_idx = self._current_frame_idx + steps\n    if new_idx &gt;= len(self._effective_frames):\n        if self.loop:\n            new_idx = new_idx % len(self._effective_frames)\n        else:\n            return False\n    return self._read_frame(new_idx)\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.close","title":"<code>close()</code>","text":"<p>Explicitly release video resources.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Explicitly release video resources.\"\"\"\n    if self._cap is not None:\n        self._cap.release()\n        self._cap = None\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.get_odor_map","title":"<code>get_odor_map(target_shape)</code>","text":"<p>Get the current frame's odor map resized to target shape.</p> <p>Parameters:</p> Name Type Description Default <code>target_shape</code> <code>Tuple[int, int]</code> <p>Target shape (ny, nx).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Resized odor map from current frame.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def get_odor_map(self, target_shape: Tuple[int, int]) -&gt; np.ndarray:\n    \"\"\"\n    Get the current frame's odor map resized to target shape.\n\n    Args:\n        target_shape (Tuple[int, int]): Target shape (ny, nx).\n\n    Returns:\n        np.ndarray: Resized odor map from current frame.\n    \"\"\"\n    import cv2\n\n    if self._current_frame_data is None:\n        return np.zeros(target_shape, dtype=np.float64)\n\n    # Resize using OpenCV\n    # cv2.resize takes (width, height), shape is (ny, nx) = (height, width)\n    resized = cv2.resize(\n        self._current_frame_data,\n        (target_shape[1], target_shape[0]),\n        interpolation=cv2.INTER_LINEAR,\n    )\n    return resized\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.reset","title":"<code>reset()</code>","text":"<p>Reset to the first frame.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset to the first frame.\"\"\"\n    self._read_frame(0)\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorSource.seek_frame","title":"<code>seek_frame(logical_index)</code>","text":"<p>Seek to a specific logical frame index.</p> <p>Parameters:</p> Name Type Description Default <code>logical_index</code> <code>int</code> <p>The frame index to seek to.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if successful.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def seek_frame(self, logical_index: int) -&gt; bool:\n    \"\"\"\n    Seek to a specific logical frame index.\n\n    Args:\n        logical_index (int): The frame index to seek to.\n\n    Returns:\n        bool: True if successful.\n    \"\"\"\n    return self._read_frame(logical_index)\n</code></pre>"},{"location":"api/sim/odor_sources/#video-release-strategy","title":"Video Release Strategy","text":""},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorReleaseStrategy","title":"<code>arthroscape.sim.odor_sources.VideoOdorReleaseStrategy</code>","text":"<p>An odor release strategy that updates the arena with video frames.</p> <p>This class wraps a VideoOdorSource and provides a method compatible with the simulation loop's odor update pattern. It can be used alongside agent-based odor release.</p> Example <p>video_strategy = VideoOdorReleaseStrategy( ...     \"plume.mp4\", ...     arena, ...     sync_mode=\"simulation_fps\", ...     simulation_fps=60 ... )</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>class VideoOdorReleaseStrategy:\n    \"\"\"\n    An odor release strategy that updates the arena with video frames.\n\n    This class wraps a VideoOdorSource and provides a method compatible with\n    the simulation loop's odor update pattern. It can be used alongside\n    agent-based odor release.\n\n    Example:\n        &gt;&gt;&gt; video_strategy = VideoOdorReleaseStrategy(\n        ...     \"plume.mp4\",\n        ...     arena,\n        ...     sync_mode=\"simulation_fps\",\n        ...     simulation_fps=60\n        ... )\n        &gt;&gt;&gt; # In simulation loop:\n        &gt;&gt;&gt; video_strategy.update(arena, simulation_frame_index)\n    \"\"\"\n\n    def __init__(\n        self,\n        video_path: Union[str, Path],\n        arena: \"Arena\",\n        mode: str = \"replace\",\n        scale: float = 1.0,\n        offset: float = 0.0,\n        sync_mode: str = \"one_to_one\",\n        simulation_fps: float = 60.0,\n        **video_kwargs: Union[bool, int, float, str, None],\n    ):\n        \"\"\"\n        Initialize the video-based odor release strategy.\n\n        Args:\n            video_path (Union[str, Path]): Path to the video file.\n            arena (Arena): The arena to apply odor to.\n            mode (str): Application mode ('replace', 'add', 'multiply', 'max').\n            scale (float): Scaling factor for odor values.\n            offset (float): Offset to add to odor values.\n            sync_mode (str): Frame synchronization mode:\n                - \"one_to_one\": Each simulation frame = one video frame.\n                - \"video_fps\": Use video's native FPS, interpolate if needed.\n                - \"simulation_fps\": Map simulation time to video time.\n            simulation_fps (float): Simulation frame rate (used for sync calculations).\n            **video_kwargs (Union[bool, int, float, str, None]): Additional arguments passed to VideoOdorSource.\n        \"\"\"\n        self.video_source = VideoOdorSource(video_path, **video_kwargs)\n        self.mode = mode\n        self.scale = scale\n        self.offset = offset\n        self.sync_mode = sync_mode\n        self.simulation_fps = simulation_fps\n\n        # Precompute sync parameters\n        if sync_mode == \"video_fps\":\n            self._frame_ratio = self.video_source.fps / simulation_fps\n        elif sync_mode == \"simulation_fps\":\n            self._frame_ratio = simulation_fps / self.video_source.fps\n        else:\n            self._frame_ratio = 1.0\n\n        self._last_video_frame = -1\n\n    def update(self, arena: \"Arena\", simulation_frame: int) -&gt; None:\n        \"\"\"\n        Update the arena's odor grid based on the current simulation frame.\n\n        Args:\n            arena (Arena): The arena to update.\n            simulation_frame (int): Current simulation frame index.\n        \"\"\"\n        # Calculate which video frame to use\n        if self.sync_mode == \"one_to_one\":\n            video_frame = simulation_frame\n        elif self.sync_mode == \"video_fps\":\n            # Simulation is faster/slower than video\n            video_frame = int(simulation_frame * self._frame_ratio)\n        else:  # simulation_fps\n            # Map simulation time to video frame\n            sim_time = simulation_frame / self.simulation_fps\n            video_frame = int(sim_time * self.video_source.fps)\n\n        # Only update if we've moved to a new video frame\n        if video_frame != self._last_video_frame:\n            self.video_source.seek_frame(video_frame)\n            self.video_source.apply_to_arena(\n                arena, mode=self.mode, scale=self.scale, offset=self.offset\n            )\n            self._last_video_frame = video_frame\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the video source to the beginning.\"\"\"\n        self.video_source.reset()\n        self._last_video_frame = -1\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorReleaseStrategy--in-simulation-loop","title":"In simulation loop:","text":"<p>video_strategy.update(arena, simulation_frame_index)</p>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorReleaseStrategy.__init__","title":"<code>__init__(video_path, arena, mode='replace', scale=1.0, offset=0.0, sync_mode='one_to_one', simulation_fps=60.0, **video_kwargs)</code>","text":"<p>Initialize the video-based odor release strategy.</p> <p>Parameters:</p> Name Type Description Default <code>video_path</code> <code>Union[str, Path]</code> <p>Path to the video file.</p> required <code>arena</code> <code>Arena</code> <p>The arena to apply odor to.</p> required <code>mode</code> <code>str</code> <p>Application mode ('replace', 'add', 'multiply', 'max').</p> <code>'replace'</code> <code>scale</code> <code>float</code> <p>Scaling factor for odor values.</p> <code>1.0</code> <code>offset</code> <code>float</code> <p>Offset to add to odor values.</p> <code>0.0</code> <code>sync_mode</code> <code>str</code> <p>Frame synchronization mode: - \"one_to_one\": Each simulation frame = one video frame. - \"video_fps\": Use video's native FPS, interpolate if needed. - \"simulation_fps\": Map simulation time to video time.</p> <code>'one_to_one'</code> <code>simulation_fps</code> <code>float</code> <p>Simulation frame rate (used for sync calculations).</p> <code>60.0</code> <code>**video_kwargs</code> <code>Union[bool, int, float, str, None]</code> <p>Additional arguments passed to VideoOdorSource.</p> <code>{}</code> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def __init__(\n    self,\n    video_path: Union[str, Path],\n    arena: \"Arena\",\n    mode: str = \"replace\",\n    scale: float = 1.0,\n    offset: float = 0.0,\n    sync_mode: str = \"one_to_one\",\n    simulation_fps: float = 60.0,\n    **video_kwargs: Union[bool, int, float, str, None],\n):\n    \"\"\"\n    Initialize the video-based odor release strategy.\n\n    Args:\n        video_path (Union[str, Path]): Path to the video file.\n        arena (Arena): The arena to apply odor to.\n        mode (str): Application mode ('replace', 'add', 'multiply', 'max').\n        scale (float): Scaling factor for odor values.\n        offset (float): Offset to add to odor values.\n        sync_mode (str): Frame synchronization mode:\n            - \"one_to_one\": Each simulation frame = one video frame.\n            - \"video_fps\": Use video's native FPS, interpolate if needed.\n            - \"simulation_fps\": Map simulation time to video time.\n        simulation_fps (float): Simulation frame rate (used for sync calculations).\n        **video_kwargs (Union[bool, int, float, str, None]): Additional arguments passed to VideoOdorSource.\n    \"\"\"\n    self.video_source = VideoOdorSource(video_path, **video_kwargs)\n    self.mode = mode\n    self.scale = scale\n    self.offset = offset\n    self.sync_mode = sync_mode\n    self.simulation_fps = simulation_fps\n\n    # Precompute sync parameters\n    if sync_mode == \"video_fps\":\n        self._frame_ratio = self.video_source.fps / simulation_fps\n    elif sync_mode == \"simulation_fps\":\n        self._frame_ratio = simulation_fps / self.video_source.fps\n    else:\n        self._frame_ratio = 1.0\n\n    self._last_video_frame = -1\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorReleaseStrategy.reset","title":"<code>reset()</code>","text":"<p>Reset the video source to the beginning.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the video source to the beginning.\"\"\"\n    self.video_source.reset()\n    self._last_video_frame = -1\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.VideoOdorReleaseStrategy.update","title":"<code>update(arena, simulation_frame)</code>","text":"<p>Update the arena's odor grid based on the current simulation frame.</p> <p>Parameters:</p> Name Type Description Default <code>arena</code> <code>Arena</code> <p>The arena to update.</p> required <code>simulation_frame</code> <code>int</code> <p>Current simulation frame index.</p> required Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def update(self, arena: \"Arena\", simulation_frame: int) -&gt; None:\n    \"\"\"\n    Update the arena's odor grid based on the current simulation frame.\n\n    Args:\n        arena (Arena): The arena to update.\n        simulation_frame (int): Current simulation frame index.\n    \"\"\"\n    # Calculate which video frame to use\n    if self.sync_mode == \"one_to_one\":\n        video_frame = simulation_frame\n    elif self.sync_mode == \"video_fps\":\n        # Simulation is faster/slower than video\n        video_frame = int(simulation_frame * self._frame_ratio)\n    else:  # simulation_fps\n        # Map simulation time to video frame\n        sim_time = simulation_frame / self.simulation_fps\n        video_frame = int(sim_time * self.video_source.fps)\n\n    # Only update if we've moved to a new video frame\n    if video_frame != self._last_video_frame:\n        self.video_source.seek_frame(video_frame)\n        self.video_source.apply_to_arena(\n            arena, mode=self.mode, scale=self.scale, offset=self.offset\n        )\n        self._last_video_frame = video_frame\n</code></pre>"},{"location":"api/sim/odor_sources/#convenience-functions","title":"Convenience Functions","text":""},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.load_odor_from_image","title":"<code>arthroscape.sim.odor_sources.load_odor_from_image(image_path, arena, scale=1.0, invert=False, mode='replace')</code>","text":"<p>Convenience function to load an image as the arena's odor landscape.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>Union[str, Path]</code> <p>Path to the image file.</p> required <code>arena</code> <code>Arena</code> <p>The arena to apply odor to.</p> required <code>scale</code> <code>float</code> <p>Scaling factor for odor values.</p> <code>1.0</code> <code>invert</code> <code>bool</code> <p>If True, invert the image values.</p> <code>False</code> <code>mode</code> <code>str</code> <p>Application mode ('replace', 'add', 'multiply', 'max').</p> <code>'replace'</code> <p>Returns:</p> Name Type Description <code>ImageOdorSource</code> <code>ImageOdorSource</code> <p>The created odor source (for further manipulation if needed).</p> Example <p>from arthroscape.sim.odor_sources import load_odor_from_image source = load_odor_from_image(\"gradient.png\", arena, scale=5.0)</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def load_odor_from_image(\n    image_path: Union[str, Path],\n    arena: \"Arena\",\n    scale: float = 1.0,\n    invert: bool = False,\n    mode: str = \"replace\",\n) -&gt; ImageOdorSource:\n    \"\"\"\n    Convenience function to load an image as the arena's odor landscape.\n\n    Args:\n        image_path (Union[str, Path]): Path to the image file.\n        arena (Arena): The arena to apply odor to.\n        scale (float): Scaling factor for odor values.\n        invert (bool): If True, invert the image values.\n        mode (str): Application mode ('replace', 'add', 'multiply', 'max').\n\n    Returns:\n        ImageOdorSource: The created odor source (for further manipulation if needed).\n\n    Example:\n        &gt;&gt;&gt; from arthroscape.sim.odor_sources import load_odor_from_image\n        &gt;&gt;&gt; source = load_odor_from_image(\"gradient.png\", arena, scale=5.0)\n    \"\"\"\n    source = ImageOdorSource(image_path, invert=invert)\n    source.apply_to_arena(arena, mode=mode, scale=scale)\n    return source\n</code></pre>"},{"location":"api/sim/odor_sources/#arthroscape.sim.odor_sources.create_gradient_odor_map","title":"<code>arthroscape.sim.odor_sources.create_gradient_odor_map(shape, direction='horizontal', min_val=0.0, max_val=1.0)</code>","text":"<p>Create a simple gradient odor map.</p> <p>This is a utility function for testing and simple experiments.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Tuple[int, int]</code> <p>Shape of the map (ny, nx).</p> required <code>direction</code> <code>str</code> <p>Gradient direction: - \"horizontal\": Left to right. - \"vertical\": Bottom to top. - \"radial\": Center outward. - \"radial_inward\": Edge inward to center.</p> <code>'horizontal'</code> <code>min_val</code> <code>float</code> <p>Minimum odor value.</p> <code>0.0</code> <code>max_val</code> <code>float</code> <p>Maximum odor value.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The gradient odor map.</p> Source code in <code>arthroscape/sim/odor_sources.py</code> <pre><code>def create_gradient_odor_map(\n    shape: Tuple[int, int],\n    direction: str = \"horizontal\",\n    min_val: float = 0.0,\n    max_val: float = 1.0,\n) -&gt; np.ndarray:\n    \"\"\"\n    Create a simple gradient odor map.\n\n    This is a utility function for testing and simple experiments.\n\n    Args:\n        shape (Tuple[int, int]): Shape of the map (ny, nx).\n        direction (str): Gradient direction:\n            - \"horizontal\": Left to right.\n            - \"vertical\": Bottom to top.\n            - \"radial\": Center outward.\n            - \"radial_inward\": Edge inward to center.\n        min_val (float): Minimum odor value.\n        max_val (float): Maximum odor value.\n\n    Returns:\n        np.ndarray: The gradient odor map.\n    \"\"\"\n    ny, nx = shape\n\n    if direction == \"horizontal\":\n        gradient = np.linspace(min_val, max_val, nx)\n        return np.tile(gradient, (ny, 1))\n\n    elif direction == \"vertical\":\n        gradient = np.linspace(min_val, max_val, ny)\n        return np.tile(gradient.reshape(-1, 1), (1, nx))\n\n    elif direction in (\"radial\", \"radial_inward\"):\n        y_coords = np.linspace(-1, 1, ny)\n        x_coords = np.linspace(-1, 1, nx)\n        X, Y = np.meshgrid(x_coords, y_coords)\n        distance = np.sqrt(X**2 + Y**2)\n        distance = distance / distance.max()  # Normalize to [0, 1]\n\n        if direction == \"radial_inward\":\n            distance = 1.0 - distance\n\n        return min_val + (max_val - min_val) * distance\n\n    else:\n        raise ValueError(\n            f\"Unknown direction: {direction}. \"\n            \"Use 'horizontal', 'vertical', 'radial', or 'radial_inward'.\"\n        )\n</code></pre>"},{"location":"api/sim/runner/","title":"Runner","text":""},{"location":"api/sim/runner/#arthroscape.sim.runner","title":"<code>arthroscape.sim.runner</code>","text":"<p>Simulation runner module for ArthroScape.</p> <p>This module provides functions to run simulations in parallel or sequentially. It handles the execution of multiple replicates and the collection of results.</p>"},{"location":"api/sim/runner/#arthroscape.sim.runner.run_simulations","title":"<code>run_simulations(config, behavior, arena, odor_release_strategy, n_replicates=1, parallel=True)</code>","text":"<p>Run multiple simulation replicates, optionally in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <code>behavior</code> <code>BehaviorAlgorithm</code> <p>Behavior algorithm instance.</p> required <code>arena</code> <code>Arena</code> <p>Arena instance.</p> required <code>odor_release_strategy</code> <code>OdorReleaseStrategy</code> <p>Odor release strategy instance.</p> required <code>n_replicates</code> <code>int</code> <p>Number of replicates to run. Defaults to 1.</p> <code>1</code> <code>parallel</code> <code>bool</code> <p>Whether to run replicates in parallel using ProcessPoolExecutor. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of result dictionaries, one for each replicate.</p> Source code in <code>arthroscape/sim/runner.py</code> <pre><code>def run_simulations(\n    config: SimulationConfig,\n    behavior: BehaviorAlgorithm,\n    arena: Arena,\n    odor_release_strategy: OdorReleaseStrategy,\n    n_replicates: int = 1,\n    parallel: bool = True,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Run multiple simulation replicates, optionally in parallel.\n\n    Args:\n        config (SimulationConfig): Simulation configuration.\n        behavior (BehaviorAlgorithm): Behavior algorithm instance.\n        arena (Arena): Arena instance.\n        odor_release_strategy (OdorReleaseStrategy): Odor release strategy instance.\n        n_replicates (int): Number of replicates to run. Defaults to 1.\n        parallel (bool): Whether to run replicates in parallel using ProcessPoolExecutor. Defaults to True.\n\n    Returns:\n        List[Dict[str, Any]]: A list of result dictionaries, one for each replicate.\n    \"\"\"\n    results = []\n    seeds = [np.random.SeedSequence().entropy for _ in range(n_replicates)]\n    if parallel:\n        with ProcessPoolExecutor() as executor:\n            futures = {\n                executor.submit(\n                    simulate_replicate,\n                    config,\n                    behavior,\n                    arena,\n                    odor_release_strategy,\n                    seed,\n                ): i\n                for i, seed in enumerate(seeds)\n            }\n            for future in tqdm(\n                as_completed(futures), total=n_replicates, desc=\"Simulating\"\n            ):\n                results.append(future.result())\n    else:\n        for seed in tqdm(seeds, desc=\"Simulating\"):\n            results.append(\n                simulate_replicate(config, behavior, arena, odor_release_strategy, seed)\n            )\n    return results\n</code></pre>"},{"location":"api/sim/runner/#arthroscape.sim.runner.run_simulations_vectorized","title":"<code>run_simulations_vectorized(config, behavior, arena, odor_release_strategy, n_replicates=1, parallel=True)</code>","text":"<p>Run multiple vectorized simulation replicates, optionally in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <code>behavior</code> <code>BehaviorAlgorithm</code> <p>Behavior algorithm instance.</p> required <code>arena</code> <code>Arena</code> <p>Arena instance.</p> required <code>odor_release_strategy</code> <code>OdorReleaseStrategy</code> <p>Odor release strategy instance.</p> required <code>n_replicates</code> <code>int</code> <p>Number of replicates to run. Defaults to 1.</p> <code>1</code> <code>parallel</code> <code>bool</code> <p>Whether to run replicates in parallel. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of result dictionaries.</p> Source code in <code>arthroscape/sim/runner.py</code> <pre><code>def run_simulations_vectorized(\n    config: SimulationConfig,\n    behavior: BehaviorAlgorithm,\n    arena: Arena,\n    odor_release_strategy: OdorReleaseStrategy,\n    n_replicates: int = 1,\n    parallel: bool = True,\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Run multiple vectorized simulation replicates, optionally in parallel.\n\n    Args:\n       config (SimulationConfig): Simulation configuration.\n       behavior (BehaviorAlgorithm): Behavior algorithm instance.\n       arena (Arena): Arena instance.\n       odor_release_strategy (OdorReleaseStrategy): Odor release strategy instance.\n       n_replicates (int): Number of replicates to run. Defaults to 1.\n       parallel (bool): Whether to run replicates in parallel. Defaults to True.\n\n    Returns:\n       List[Dict[str, Any]]: A list of result dictionaries.\n    \"\"\"\n    results = []\n    seeds = [np.random.SeedSequence().entropy for _ in range(n_replicates)]\n    if parallel:\n        with ProcessPoolExecutor() as executor:\n            futures = {\n                executor.submit(\n                    simulate_replicate_vectorized,\n                    config,\n                    behavior,\n                    arena,\n                    odor_release_strategy,\n                    seed,\n                ): i\n                for i, seed in enumerate(seeds)\n            }\n            for future in tqdm(\n                as_completed(futures), total=n_replicates, desc=\"Simulating\"\n            ):\n                results.append(future.result())\n    else:\n        for seed in tqdm(seeds, desc=\"Simulating\"):\n            results.append(\n                simulate_replicate_vectorized(\n                    config, behavior, arena, odor_release_strategy, seed\n                )\n            )\n    return results\n</code></pre>"},{"location":"api/sim/runner/#arthroscape.sim.runner.save_simulation_results","title":"<code>save_simulation_results(results, filename)</code>","text":"<p>Save simulation results to a compressed NumPy file.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[Dict[str, Any]]</code> <p>List of simulation result dictionaries.</p> required <code>filename</code> <code>str</code> <p>Path to the output file (should end in .npz).</p> required Source code in <code>arthroscape/sim/runner.py</code> <pre><code>def save_simulation_results(results: List[Dict[str, Any]], filename: str) -&gt; None:\n    \"\"\"\n    Save simulation results to a compressed NumPy file.\n\n    Args:\n        results (List[Dict[str, Any]]): List of simulation result dictionaries.\n        filename (str): Path to the output file (should end in .npz).\n    \"\"\"\n    np.savez_compressed(filename, results=results)\n</code></pre>"},{"location":"api/sim/runner/#arthroscape.sim.runner.simulate_replicate","title":"<code>simulate_replicate(config, behavior, arena, odor_release_strategy, seed=None)</code>","text":"<p>Run a single simulation replicate.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <code>behavior</code> <code>BehaviorAlgorithm</code> <p>Behavior algorithm instance.</p> required <code>arena</code> <code>Arena</code> <p>Arena instance.</p> required <code>odor_release_strategy</code> <code>OdorReleaseStrategy</code> <p>Odor release strategy instance.</p> required <code>seed</code> <code>int</code> <p>Random seed for this replicate.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Simulation results dictionary containing tracks, odor fields, etc.</p> Source code in <code>arthroscape/sim/runner.py</code> <pre><code>def simulate_replicate(\n    config: SimulationConfig,\n    behavior: BehaviorAlgorithm,\n    arena: Arena,\n    odor_release_strategy: OdorReleaseStrategy,\n    seed: int = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Run a single simulation replicate.\n\n    Args:\n        config (SimulationConfig): Simulation configuration.\n        behavior (BehaviorAlgorithm): Behavior algorithm instance.\n        arena (Arena): Arena instance.\n        odor_release_strategy (OdorReleaseStrategy): Odor release strategy instance.\n        seed (int, optional): Random seed for this replicate.\n\n    Returns:\n        Dict[str, Any]: Simulation results dictionary containing tracks, odor fields, etc.\n    \"\"\"\n    simulator = MultiAnimalSimulator(\n        config, behavior, arena, odor_release_strategy, seed\n    )\n    result = simulator.simulate()\n    result[\"seed\"] = seed\n    return result\n</code></pre>"},{"location":"api/sim/runner/#arthroscape.sim.runner.simulate_replicate_vectorized","title":"<code>simulate_replicate_vectorized(config, behavior, arena, odor_release_strategy, seed=None)</code>","text":"<p>Run a single vectorized simulation replicate.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration.</p> required <code>behavior</code> <code>BehaviorAlgorithm</code> <p>Behavior algorithm instance.</p> required <code>arena</code> <code>Arena</code> <p>Arena instance.</p> required <code>odor_release_strategy</code> <code>OdorReleaseStrategy</code> <p>Odor release strategy instance.</p> required <code>seed</code> <code>int</code> <p>Random seed for this replicate.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Simulation results dictionary.</p> Source code in <code>arthroscape/sim/runner.py</code> <pre><code>def simulate_replicate_vectorized(\n    config: SimulationConfig,\n    behavior: BehaviorAlgorithm,\n    arena: Arena,\n    odor_release_strategy: OdorReleaseStrategy,\n    seed: int = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Run a single vectorized simulation replicate.\n\n    Args:\n        config (SimulationConfig): Simulation configuration.\n        behavior (BehaviorAlgorithm): Behavior algorithm instance.\n        arena (Arena): Arena instance.\n        odor_release_strategy (OdorReleaseStrategy): Odor release strategy instance.\n        seed (int, optional): Random seed for this replicate.\n\n    Returns:\n        Dict[str, Any]: Simulation results dictionary.\n    \"\"\"\n    simulator = MultiAnimalSimulator(\n        config, behavior, arena, odor_release_strategy, seed\n    )\n    result = simulator.simulate_vectorized()\n    result[\"seed\"] = seed\n    return result\n</code></pre>"},{"location":"api/sim/saver/","title":"Saver","text":""},{"location":"api/sim/saver/#arthroscape.sim.saver","title":"<code>arthroscape.sim.saver</code>","text":"<p>Data saving module for ArthroScape.</p> <p>This module handles saving simulation results to HDF5 format. It structures the data hierarchically by replicate and animal.</p>"},{"location":"api/sim/saver/#arthroscape.sim.saver.save_simulation_results_hdf5","title":"<code>save_simulation_results_hdf5(results, filename)</code>","text":"<p>Save simulation results to an HDF5 file.</p> <p>The HDF5 file structure is as follows: - Root     - replicate_0         - final_odor_grid (dataset)         - trajectories (group)             - animal_0 (group)                 - x (dataset)                 - y (dataset)                 - heading (dataset)                 - state (dataset)                 - odor_left (dataset)                 - odor_right (dataset)                 - perceived_odor_left (dataset)                 - perceived_odor_right (dataset)             - animal_1 ...         - odor_grid_history (dataset, optional)     - replicate_1 ...</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[Dict]</code> <p>A list of simulation result dictionaries.</p> required <code>filename</code> <code>str</code> <p>The path to the output HDF5 file.</p> required Source code in <code>arthroscape/sim/saver.py</code> <pre><code>def save_simulation_results_hdf5(results: List[Dict], filename: str) -&gt; None:\n    \"\"\"\n    Save simulation results to an HDF5 file.\n\n    The HDF5 file structure is as follows:\n    - Root\n        - replicate_0\n            - final_odor_grid (dataset)\n            - trajectories (group)\n                - animal_0 (group)\n                    - x (dataset)\n                    - y (dataset)\n                    - heading (dataset)\n                    - state (dataset)\n                    - odor_left (dataset)\n                    - odor_right (dataset)\n                    - perceived_odor_left (dataset)\n                    - perceived_odor_right (dataset)\n                - animal_1 ...\n            - odor_grid_history (dataset, optional)\n        - replicate_1 ...\n\n    Args:\n        results (List[Dict]): A list of simulation result dictionaries.\n        filename (str): The path to the output HDF5 file.\n    \"\"\"\n    with h5py.File(filename, \"w\") as hf:\n        for rep_idx, result in enumerate(results):\n            rep_group = hf.create_group(f\"replicate_{rep_idx}\")\n            # Save final odor grid.\n            final_grid = result.get(\"final_odor_grid\", np.array([]))\n            rep_group.create_dataset(\"final_odor_grid\", data=final_grid)\n\n            # Save trajectories.\n            traj_group = rep_group.create_group(\"trajectories\")\n            trajectories = result.get(\"trajectories\", [])\n            for animal_idx, traj in enumerate(trajectories):\n                animal_group = traj_group.create_group(f\"animal_{animal_idx}\")\n                animal_group.create_dataset(\"x\", data=np.array(traj.get(\"x\", [])))\n                animal_group.create_dataset(\"y\", data=np.array(traj.get(\"y\", [])))\n                animal_group.create_dataset(\n                    \"heading\", data=np.array(traj.get(\"heading\", []))\n                )\n                animal_group.create_dataset(\n                    \"state\", data=np.array(traj.get(\"state\", []))\n                )\n                animal_group.create_dataset(\n                    \"odor_left\", data=np.array(traj.get(\"odor_left\", []))\n                )\n                animal_group.create_dataset(\n                    \"odor_right\", data=np.array(traj.get(\"odor_right\", []))\n                )\n                animal_group.create_dataset(\n                    \"perceived_odor_left\",\n                    data=np.array(traj.get(\"perceived_odor_left\", [])),\n                )\n                animal_group.create_dataset(\n                    \"perceived_odor_right\",\n                    data=np.array(traj.get(\"perceived_odor_right\", [])),\n                )\n\n            # Optionally, save odor grid history if it exists.\n            if \"odor_grid_history\" in result:\n                history = np.array(result[\"odor_grid_history\"])\n                rep_group.create_dataset(\"odor_grid_history\", data=history)\n</code></pre>"},{"location":"api/sim/simulator/","title":"Simulator","text":""},{"location":"api/sim/simulator/#arthroscape.sim.simulator","title":"<code>arthroscape.sim.simulator</code>","text":"<p>Core simulation engine for ArthroScape.</p> <p>This module defines the <code>MultiAnimalSimulator</code> class, which orchestrates the simulation loop. It manages the state of multiple animals, their interactions with the arena (odor deposition, sensing, movement), and the evolution of the odor field over time.</p>"},{"location":"api/sim/simulator/#arthroscape.sim.simulator.MultiAnimalSimulator","title":"<code>MultiAnimalSimulator</code>","text":"<p>Simulator for multiple animals in an odor arena.</p> <p>This class manages the main simulation loop, updating animal states, positions, and the odor field at each time step. It supports both a standard sequential simulation method and a vectorized version for better performance with many animals.</p> Source code in <code>arthroscape/sim/simulator.py</code> <pre><code>class MultiAnimalSimulator:\n    \"\"\"\n    Simulator for multiple animals in an odor arena.\n\n    This class manages the main simulation loop, updating animal states, positions,\n    and the odor field at each time step. It supports both a standard sequential\n    simulation method and a vectorized version for better performance with many animals.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: SimulationConfig,\n        behavior: BehaviorAlgorithm,\n        arena: Arena,\n        odor_release_strategy: OdorReleaseStrategy,\n        seed: int = None,\n    ):\n        \"\"\"\n        Initialize the simulator.\n\n        Args:\n            config (SimulationConfig): Simulation configuration parameters.\n            behavior (BehaviorAlgorithm): The behavior algorithm governing animal decisions.\n            arena (Arena): The arena environment (shared by all animals).\n            odor_release_strategy (OdorReleaseStrategy): Strategy for odor deposition.\n            seed (int, optional): Random seed for the simulation's random number generator.\n        \"\"\"\n        self.config = config\n        self.behavior = behavior\n        self.arena = arena  # shared arena for all animals\n        self.odor_release_strategy = odor_release_strategy\n        self.rng = np.random.default_rng(seed)\n        self.num_animals = config.number_of_animals\n        # For each agent, create a new instance of the odor perception:\n        self.odor_perceptions = [\n            config.odor_perception_factory() for _ in range(self.num_animals)\n        ]\n\n    def simulate(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Run the simulation step-by-step (unvectorized).\n\n        This method iterates through each time step and each animal sequentially.\n        It performs the following operations in order:\n        1. Update animal state (e.g., deciding to turn or walk).\n        2. Release odor into the arena based on the current state.\n        3. Calculate antenna positions.\n        4. Sample odor concentration at antenna positions.\n        5. Process odor perception (filtering, adaptation).\n        6. Update heading based on perceived odor.\n        7. Update position (move) if the path is clear.\n        8. Update the global odor field (diffusion and decay).\n\n        Returns:\n            Dict[str, Any]: A dictionary containing simulation results, including:\n                - \"trajectories\": A list of dictionaries, one per animal, containing time-series data\n                  for position (x, y), heading, state, and odor readings.\n                - \"final_odor_grid\": The state of the odor grid at the end of the simulation.\n        \"\"\"\n        cfg = self.config\n        N = cfg.total_frames\n        num = self.num_animals\n\n        # Initialize per-animal arrays.\n        states = [[0] * N for _ in range(num)]\n        headings = [[0.0] * N for _ in range(num)]\n        xs = [[0.0] * N for _ in range(num)]\n        ys = [[0.0] * N for _ in range(num)]\n        odor_left_arr = [[0.0] * N for _ in range(num)]\n        odor_right_arr = [[0.0] * N for _ in range(num)]\n        perc_odor_left_arr = [[0.0] * N for _ in range(num)]\n        perc_odor_right_arr = [[0.0] * N for _ in range(num)]\n\n        # Reset each agent's perception at start\n        for a in range(num):\n            self.odor_perceptions[a].reset()\n\n        # Initialize each animal with a random heading and a random initial position.\n        for a in range(num):\n            headings[a][0] = cfg.initial_heading_sampler()\n            xs[a][0], ys[a][0] = cfg.initial_position_sampler()\n\n        # Main simulation loop.\n        progress_interval = max(1, N // 100)  # report every 1%\n        for i in range(1, N):\n            for a in range(num):\n                # 1) Update state\n                states[a][i] = self.behavior.update_state(\n                    states[a][i - 1], cfg, self.rng\n                )\n\n                # 2) Odor release\n                deposits = self.odor_release_strategy.release_odor(\n                    states[a][i - 1],\n                    (xs[a][i - 1], ys[a][i - 1]),\n                    headings[a][i - 1],\n                    cfg,\n                    self.rng,\n                )\n                for deposit in deposits:\n                    dx, dy = deposit.offset\n                    heading_prev = headings[a][i - 1]\n                    cos_h = math.cos(heading_prev)\n                    sin_h = math.sin(heading_prev)\n                    global_dx = dx * cos_h - dy * sin_h\n                    global_dy = dx * sin_h + dy * cos_h\n                    deposit_x = xs[a][i - 1] + global_dx\n                    deposit_y = ys[a][i - 1] + global_dy\n                    kernel = deposit.generate_kernel(cfg)\n                    self.arena.deposit_odor_kernel(deposit_x, deposit_y, kernel)\n\n                # 3) Compute left/right antenna positions\n                cos_h = math.cos(headings[a][i - 1])\n                sin_h = math.sin(headings[a][i - 1])\n                left_dx = (\n                    cfg.antenna_left_offset[0] * cos_h\n                    - cfg.antenna_left_offset[1] * sin_h\n                )\n                left_dy = (\n                    cfg.antenna_left_offset[0] * sin_h\n                    + cfg.antenna_left_offset[1] * cos_h\n                )\n                right_dx = (\n                    cfg.antenna_right_offset[0] * cos_h\n                    - cfg.antenna_right_offset[1] * sin_h\n                )\n                right_dy = (\n                    cfg.antenna_right_offset[0] * sin_h\n                    + cfg.antenna_right_offset[1] * cos_h\n                )\n                left_x = xs[a][i - 1] + left_dx\n                left_y = ys[a][i - 1] + left_dy\n                right_x = xs[a][i - 1] + right_dx\n                right_y = ys[a][i - 1] + right_dy\n\n                # 4) Sample odor\n                odor_left = self.arena.get_odor(left_x, left_y)\n                odor_right = self.arena.get_odor(right_x, right_y)\n                odor_left_arr[a][i] = odor_left\n                odor_right_arr[a][i] = odor_right\n\n                # 5) Perceive odor\n                dt = 1.0 / cfg.fps\n                perc_left, perc_right = self.odor_perceptions[a].perceive_odor(\n                    odor_left, odor_right, dt\n                )\n                perc_odor_left_arr[a][i] = perc_left\n                perc_odor_right_arr[a][i] = perc_right\n\n                # 6) Update heading\n                headings[a][i] = self.behavior.update_heading(\n                    headings[a][i - 1], perc_left, perc_right, False, cfg, self.rng\n                )\n\n                # 7) Update position if walking\n                if states[a][i] == 0:\n                    xs[a][i] = xs[a][i - 1]\n                    ys[a][i] = ys[a][i - 1]\n                else:\n                    current_speed = cfg.walking_speed_sampler()\n                    walking_distance = current_speed / cfg.fps\n                    new_x = xs[a][i - 1] + math.cos(headings[a][i]) * walking_distance\n                    new_y = ys[a][i - 1] + math.sin(headings[a][i]) * walking_distance\n                    if self.arena.is_free(new_x, new_y):\n                        xs[a][i] = new_x\n                        ys[a][i] = new_y\n                    else:\n                        xs[a][i] = xs[a][i - 1]\n                        ys[a][i] = ys[a][i - 1]\n\n            # 8) Diffusion / decay\n            if cfg.diffusion_coefficient &gt; 0 or cfg.odor_decay_rate &gt; 0:\n                dt = 1.0 / cfg.fps\n                self.arena.update_odor_field(dt=dt)\n\n            # 9) Progress logging\n            if i % progress_interval == 0:\n                logger.info(f\"Replicate progress: frame {i}/{N} ({i / N:.0%} done)\")\n\n        result = {\n            \"trajectories\": [\n                {\n                    \"x\": xs[a],\n                    \"y\": ys[a],\n                    \"heading\": headings[a],\n                    \"state\": states[a],\n                    \"odor_left\": odor_left_arr[a],\n                    \"odor_right\": odor_right_arr[a],\n                    \"perc_odor_left\": perc_odor_left_arr[a],\n                    \"perc_odor_right\": perc_odor_right_arr[a],\n                }\n                for a in range(num)\n            ],\n            \"final_odor_grid\": self.arena.odor_grid,\n        }\n        return result\n\n    def simulate_vectorized(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Run a vectorized version of the simulation.\n\n        This method optimizes the simulation loop by using NumPy vectorization for:\n        - Odor deposition (batching deposits).\n        - Sensor position calculation (vectorized trigonometry).\n        - Odor sampling (vectorized grid access).\n        - Position updates (vectorized movement and collision checking).\n\n        Behavioral state updates and heading updates remain per-animal as they may involve\n        complex, state-dependent logic that is harder to vectorize efficiently.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing simulation results, structured identically\n            to `simulate()`.\n        \"\"\"\n        cfg = self.config\n        N = cfg.total_frames\n        num = self.num_animals\n\n        # Pre-allocate arrays for simulation outputs\n        states = np.zeros((num, N), dtype=int)\n        headings = np.zeros((num, N))\n        xs = np.zeros((num, N))\n        ys = np.zeros((num, N))\n        odor_left_arr = np.zeros((num, N))\n        odor_right_arr = np.zeros((num, N))\n        perc_odor_left_arr = np.zeros((num, N))\n        perc_odor_right_arr = np.zeros((num, N))\n\n        # Initialize positions and headings (still looping over animals for initial values)\n        for a in range(num):\n            headings[a, 0] = cfg.initial_heading_sampler()\n            xs[a, 0], ys[a, 0] = cfg.initial_position_sampler()\n\n        # Reset odor perceptions for each agent\n        for a in range(num):\n            self.odor_perceptions[a].reset()\n\n        # Main simulation loop (over frames)\n        for i in range(1, N):\n            # --- State update (scalar per animal) ---\n            for a in range(num):\n                states[a, i] = self.behavior.update_state(\n                    states[a, i - 1], cfg, self.rng\n                )\n\n            # --- Odor deposition (vectorized if possible) ---\n            deposit_xs = []\n            deposit_ys = []\n            kernels = []\n            for a in range(num):\n                deposits = self.odor_release_strategy.release_odor(\n                    states[a, i - 1],\n                    (xs[a, i - 1], ys[a, i - 1]),\n                    headings[a, i - 1],\n                    cfg,\n                    self.rng,\n                )\n                for deposit in deposits:\n                    dx, dy = deposit.offset\n                    # Compute global deposit offset for this animal (scalar)\n                    global_dx = dx * math.cos(headings[a, i - 1]) - dy * math.sin(\n                        headings[a, i - 1]\n                    )\n                    global_dy = dx * math.sin(headings[a, i - 1]) + dy * math.cos(\n                        headings[a, i - 1]\n                    )\n                    deposit_xs.append(xs[a, i - 1] + global_dx)\n                    deposit_ys.append(ys[a, i - 1] + global_dy)\n                    kernels.append(deposit.generate_kernel(cfg))\n            # If any deposits occurred, try a vectorized deposit if the arena supports it.\n            if deposit_xs:\n                deposit_xs_arr = np.array(deposit_xs)\n                deposit_ys_arr = np.array(deposit_ys)\n                # Check if all kernels have the same shape.\n                if all(k.shape == kernels[0].shape for k in kernels) and hasattr(\n                    self.arena, \"deposit_odor_kernels_vectorized\"\n                ):\n                    self.arena.deposit_odor_kernels_vectorized(\n                        deposit_xs_arr, deposit_ys_arr, kernels[0]\n                    )\n                else:\n                    # Fall back to scalar deposits.\n                    for dx, dy, kernel in zip(deposit_xs, deposit_ys, kernels):\n                        self.arena.deposit_odor_kernel(dx, dy, kernel)\n\n            # --- Compute sensor positions vectorized ---\n            # Calculate rotated offsets using vectorized trigonometry.\n            current_headings = headings[:, i - 1]  # shape (num,)\n            cos_vals = np.cos(current_headings)\n            sin_vals = np.sin(current_headings)\n            left_offset = np.array(cfg.antenna_left_offset)  # shape (2,)\n            right_offset = np.array(cfg.antenna_right_offset)  # shape (2,)\n            left_dx = left_offset[0] * cos_vals - left_offset[1] * sin_vals\n            left_dy = left_offset[0] * sin_vals + left_offset[1] * cos_vals\n            right_dx = right_offset[0] * cos_vals - right_offset[1] * sin_vals\n            right_dy = right_offset[0] * sin_vals + right_offset[1] * cos_vals\n            left_sensor_x = xs[:, i - 1] + left_dx\n            left_sensor_y = ys[:, i - 1] + left_dy\n            right_sensor_x = xs[:, i - 1] + right_dx\n            right_sensor_y = ys[:, i - 1] + right_dy\n\n            # --- Get odor sensor readings vectorized ---\n            # We assume your arena provides a vectorized get_odor_vectorized method.\n            if hasattr(self.arena, \"get_odor_vectorized\"):\n                odor_left_vals = self.arena.get_odor_vectorized(\n                    left_sensor_x, left_sensor_y\n                )\n                odor_right_vals = self.arena.get_odor_vectorized(\n                    right_sensor_x, right_sensor_y\n                )\n            else:\n                odor_left_vals = np.array(\n                    [\n                        self.arena.get_odor(x, y)\n                        for x, y in zip(left_sensor_x, left_sensor_y)\n                    ]\n                )\n                odor_right_vals = np.array(\n                    [\n                        self.arena.get_odor(x, y)\n                        for x, y in zip(right_sensor_x, right_sensor_y)\n                    ]\n                )\n            odor_left_arr[:, i] = odor_left_vals\n            odor_right_arr[:, i] = odor_right_vals\n\n            # --- Update perceived odor (still per-animal) ---\n            dt = 1.0 / cfg.fps\n            for a in range(num):\n                perc_left, perc_right = self.odor_perceptions[a].perceive_odor(\n                    odor_left_arr[a, i], odor_right_arr[a, i], dt\n                )\n                perc_odor_left_arr[a, i] = perc_left\n                perc_odor_right_arr[a, i] = perc_right\n\n            # --- Update headings (per-animal) ---\n            for a in range(num):\n                headings[a, i] = self.behavior.update_heading(\n                    headings[a, i - 1],\n                    perc_odor_left_arr[a, i],\n                    perc_odor_right_arr[a, i],\n                    False,\n                    cfg,\n                    self.rng,\n                )\n\n            # --- Compute new positions vectorized ---\n            # Compute walking distances for each animal.\n            current_speeds = np.array([cfg.walking_speed_sampler() for _ in range(num)])\n            walking_distance = current_speeds / cfg.fps\n            proposed_x = xs[:, i - 1] + np.cos(headings[:, i]) * walking_distance\n            proposed_y = ys[:, i - 1] + np.sin(headings[:, i]) * walking_distance\n\n            # Use vectorized free-space check if available.\n            if hasattr(self.arena, \"is_free_vectorized\"):\n                free = self.arena.is_free_vectorized(proposed_x, proposed_y)\n            else:\n                free = np.array(\n                    [self.arena.is_free(x, y) for x, y in zip(proposed_x, proposed_y)]\n                )\n            xs[:, i] = np.where(free, proposed_x, xs[:, i - 1])\n            ys[:, i] = np.where(free, proposed_y, ys[:, i - 1])\n\n            # --- Update the odor field ---\n            if cfg.diffusion_coefficient &gt; 0 or cfg.odor_decay_rate &gt; 0:\n                self.arena.update_odor_field(dt=dt)\n\n            if i % max(1, N // 100) == 0:\n                logger.info(\n                    f\"Vectorized simulation progress: frame {i}/{N} ({i / N:.0%} done)\"\n                )\n\n        # Pack the result into a dictionary.\n        result = {\n            \"trajectories\": [\n                {\n                    \"x\": xs[a, :].tolist(),\n                    \"y\": ys[a, :].tolist(),\n                    \"heading\": headings[a, :].tolist(),\n                    \"state\": states[a, :].tolist(),\n                    \"odor_left\": odor_left_arr[a, :].tolist(),\n                    \"odor_right\": odor_right_arr[a, :].tolist(),\n                    \"perceived_odor_left\": perc_odor_left_arr[a, :].tolist(),\n                    \"perceived_odor_right\": perc_odor_right_arr[a, :].tolist(),\n                }\n                for a in range(num)\n            ],\n            \"final_odor_grid\": self.arena.odor_grid,\n        }\n        return result\n</code></pre>"},{"location":"api/sim/simulator/#arthroscape.sim.simulator.MultiAnimalSimulator.__init__","title":"<code>__init__(config, behavior, arena, odor_release_strategy, seed=None)</code>","text":"<p>Initialize the simulator.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SimulationConfig</code> <p>Simulation configuration parameters.</p> required <code>behavior</code> <code>BehaviorAlgorithm</code> <p>The behavior algorithm governing animal decisions.</p> required <code>arena</code> <code>Arena</code> <p>The arena environment (shared by all animals).</p> required <code>odor_release_strategy</code> <code>OdorReleaseStrategy</code> <p>Strategy for odor deposition.</p> required <code>seed</code> <code>int</code> <p>Random seed for the simulation's random number generator.</p> <code>None</code> Source code in <code>arthroscape/sim/simulator.py</code> <pre><code>def __init__(\n    self,\n    config: SimulationConfig,\n    behavior: BehaviorAlgorithm,\n    arena: Arena,\n    odor_release_strategy: OdorReleaseStrategy,\n    seed: int = None,\n):\n    \"\"\"\n    Initialize the simulator.\n\n    Args:\n        config (SimulationConfig): Simulation configuration parameters.\n        behavior (BehaviorAlgorithm): The behavior algorithm governing animal decisions.\n        arena (Arena): The arena environment (shared by all animals).\n        odor_release_strategy (OdorReleaseStrategy): Strategy for odor deposition.\n        seed (int, optional): Random seed for the simulation's random number generator.\n    \"\"\"\n    self.config = config\n    self.behavior = behavior\n    self.arena = arena  # shared arena for all animals\n    self.odor_release_strategy = odor_release_strategy\n    self.rng = np.random.default_rng(seed)\n    self.num_animals = config.number_of_animals\n    # For each agent, create a new instance of the odor perception:\n    self.odor_perceptions = [\n        config.odor_perception_factory() for _ in range(self.num_animals)\n    ]\n</code></pre>"},{"location":"api/sim/simulator/#arthroscape.sim.simulator.MultiAnimalSimulator.simulate","title":"<code>simulate()</code>","text":"<p>Run the simulation step-by-step (unvectorized).</p> <p>This method iterates through each time step and each animal sequentially. It performs the following operations in order: 1. Update animal state (e.g., deciding to turn or walk). 2. Release odor into the arena based on the current state. 3. Calculate antenna positions. 4. Sample odor concentration at antenna positions. 5. Process odor perception (filtering, adaptation). 6. Update heading based on perceived odor. 7. Update position (move) if the path is clear. 8. Update the global odor field (diffusion and decay).</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing simulation results, including: - \"trajectories\": A list of dictionaries, one per animal, containing time-series data   for position (x, y), heading, state, and odor readings. - \"final_odor_grid\": The state of the odor grid at the end of the simulation.</p> Source code in <code>arthroscape/sim/simulator.py</code> <pre><code>def simulate(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Run the simulation step-by-step (unvectorized).\n\n    This method iterates through each time step and each animal sequentially.\n    It performs the following operations in order:\n    1. Update animal state (e.g., deciding to turn or walk).\n    2. Release odor into the arena based on the current state.\n    3. Calculate antenna positions.\n    4. Sample odor concentration at antenna positions.\n    5. Process odor perception (filtering, adaptation).\n    6. Update heading based on perceived odor.\n    7. Update position (move) if the path is clear.\n    8. Update the global odor field (diffusion and decay).\n\n    Returns:\n        Dict[str, Any]: A dictionary containing simulation results, including:\n            - \"trajectories\": A list of dictionaries, one per animal, containing time-series data\n              for position (x, y), heading, state, and odor readings.\n            - \"final_odor_grid\": The state of the odor grid at the end of the simulation.\n    \"\"\"\n    cfg = self.config\n    N = cfg.total_frames\n    num = self.num_animals\n\n    # Initialize per-animal arrays.\n    states = [[0] * N for _ in range(num)]\n    headings = [[0.0] * N for _ in range(num)]\n    xs = [[0.0] * N for _ in range(num)]\n    ys = [[0.0] * N for _ in range(num)]\n    odor_left_arr = [[0.0] * N for _ in range(num)]\n    odor_right_arr = [[0.0] * N for _ in range(num)]\n    perc_odor_left_arr = [[0.0] * N for _ in range(num)]\n    perc_odor_right_arr = [[0.0] * N for _ in range(num)]\n\n    # Reset each agent's perception at start\n    for a in range(num):\n        self.odor_perceptions[a].reset()\n\n    # Initialize each animal with a random heading and a random initial position.\n    for a in range(num):\n        headings[a][0] = cfg.initial_heading_sampler()\n        xs[a][0], ys[a][0] = cfg.initial_position_sampler()\n\n    # Main simulation loop.\n    progress_interval = max(1, N // 100)  # report every 1%\n    for i in range(1, N):\n        for a in range(num):\n            # 1) Update state\n            states[a][i] = self.behavior.update_state(\n                states[a][i - 1], cfg, self.rng\n            )\n\n            # 2) Odor release\n            deposits = self.odor_release_strategy.release_odor(\n                states[a][i - 1],\n                (xs[a][i - 1], ys[a][i - 1]),\n                headings[a][i - 1],\n                cfg,\n                self.rng,\n            )\n            for deposit in deposits:\n                dx, dy = deposit.offset\n                heading_prev = headings[a][i - 1]\n                cos_h = math.cos(heading_prev)\n                sin_h = math.sin(heading_prev)\n                global_dx = dx * cos_h - dy * sin_h\n                global_dy = dx * sin_h + dy * cos_h\n                deposit_x = xs[a][i - 1] + global_dx\n                deposit_y = ys[a][i - 1] + global_dy\n                kernel = deposit.generate_kernel(cfg)\n                self.arena.deposit_odor_kernel(deposit_x, deposit_y, kernel)\n\n            # 3) Compute left/right antenna positions\n            cos_h = math.cos(headings[a][i - 1])\n            sin_h = math.sin(headings[a][i - 1])\n            left_dx = (\n                cfg.antenna_left_offset[0] * cos_h\n                - cfg.antenna_left_offset[1] * sin_h\n            )\n            left_dy = (\n                cfg.antenna_left_offset[0] * sin_h\n                + cfg.antenna_left_offset[1] * cos_h\n            )\n            right_dx = (\n                cfg.antenna_right_offset[0] * cos_h\n                - cfg.antenna_right_offset[1] * sin_h\n            )\n            right_dy = (\n                cfg.antenna_right_offset[0] * sin_h\n                + cfg.antenna_right_offset[1] * cos_h\n            )\n            left_x = xs[a][i - 1] + left_dx\n            left_y = ys[a][i - 1] + left_dy\n            right_x = xs[a][i - 1] + right_dx\n            right_y = ys[a][i - 1] + right_dy\n\n            # 4) Sample odor\n            odor_left = self.arena.get_odor(left_x, left_y)\n            odor_right = self.arena.get_odor(right_x, right_y)\n            odor_left_arr[a][i] = odor_left\n            odor_right_arr[a][i] = odor_right\n\n            # 5) Perceive odor\n            dt = 1.0 / cfg.fps\n            perc_left, perc_right = self.odor_perceptions[a].perceive_odor(\n                odor_left, odor_right, dt\n            )\n            perc_odor_left_arr[a][i] = perc_left\n            perc_odor_right_arr[a][i] = perc_right\n\n            # 6) Update heading\n            headings[a][i] = self.behavior.update_heading(\n                headings[a][i - 1], perc_left, perc_right, False, cfg, self.rng\n            )\n\n            # 7) Update position if walking\n            if states[a][i] == 0:\n                xs[a][i] = xs[a][i - 1]\n                ys[a][i] = ys[a][i - 1]\n            else:\n                current_speed = cfg.walking_speed_sampler()\n                walking_distance = current_speed / cfg.fps\n                new_x = xs[a][i - 1] + math.cos(headings[a][i]) * walking_distance\n                new_y = ys[a][i - 1] + math.sin(headings[a][i]) * walking_distance\n                if self.arena.is_free(new_x, new_y):\n                    xs[a][i] = new_x\n                    ys[a][i] = new_y\n                else:\n                    xs[a][i] = xs[a][i - 1]\n                    ys[a][i] = ys[a][i - 1]\n\n        # 8) Diffusion / decay\n        if cfg.diffusion_coefficient &gt; 0 or cfg.odor_decay_rate &gt; 0:\n            dt = 1.0 / cfg.fps\n            self.arena.update_odor_field(dt=dt)\n\n        # 9) Progress logging\n        if i % progress_interval == 0:\n            logger.info(f\"Replicate progress: frame {i}/{N} ({i / N:.0%} done)\")\n\n    result = {\n        \"trajectories\": [\n            {\n                \"x\": xs[a],\n                \"y\": ys[a],\n                \"heading\": headings[a],\n                \"state\": states[a],\n                \"odor_left\": odor_left_arr[a],\n                \"odor_right\": odor_right_arr[a],\n                \"perc_odor_left\": perc_odor_left_arr[a],\n                \"perc_odor_right\": perc_odor_right_arr[a],\n            }\n            for a in range(num)\n        ],\n        \"final_odor_grid\": self.arena.odor_grid,\n    }\n    return result\n</code></pre>"},{"location":"api/sim/simulator/#arthroscape.sim.simulator.MultiAnimalSimulator.simulate_vectorized","title":"<code>simulate_vectorized()</code>","text":"<p>Run a vectorized version of the simulation.</p> <p>This method optimizes the simulation loop by using NumPy vectorization for: - Odor deposition (batching deposits). - Sensor position calculation (vectorized trigonometry). - Odor sampling (vectorized grid access). - Position updates (vectorized movement and collision checking).</p> <p>Behavioral state updates and heading updates remain per-animal as they may involve complex, state-dependent logic that is harder to vectorize efficiently.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing simulation results, structured identically</p> <code>Dict[str, Any]</code> <p>to <code>simulate()</code>.</p> Source code in <code>arthroscape/sim/simulator.py</code> <pre><code>def simulate_vectorized(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Run a vectorized version of the simulation.\n\n    This method optimizes the simulation loop by using NumPy vectorization for:\n    - Odor deposition (batching deposits).\n    - Sensor position calculation (vectorized trigonometry).\n    - Odor sampling (vectorized grid access).\n    - Position updates (vectorized movement and collision checking).\n\n    Behavioral state updates and heading updates remain per-animal as they may involve\n    complex, state-dependent logic that is harder to vectorize efficiently.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing simulation results, structured identically\n        to `simulate()`.\n    \"\"\"\n    cfg = self.config\n    N = cfg.total_frames\n    num = self.num_animals\n\n    # Pre-allocate arrays for simulation outputs\n    states = np.zeros((num, N), dtype=int)\n    headings = np.zeros((num, N))\n    xs = np.zeros((num, N))\n    ys = np.zeros((num, N))\n    odor_left_arr = np.zeros((num, N))\n    odor_right_arr = np.zeros((num, N))\n    perc_odor_left_arr = np.zeros((num, N))\n    perc_odor_right_arr = np.zeros((num, N))\n\n    # Initialize positions and headings (still looping over animals for initial values)\n    for a in range(num):\n        headings[a, 0] = cfg.initial_heading_sampler()\n        xs[a, 0], ys[a, 0] = cfg.initial_position_sampler()\n\n    # Reset odor perceptions for each agent\n    for a in range(num):\n        self.odor_perceptions[a].reset()\n\n    # Main simulation loop (over frames)\n    for i in range(1, N):\n        # --- State update (scalar per animal) ---\n        for a in range(num):\n            states[a, i] = self.behavior.update_state(\n                states[a, i - 1], cfg, self.rng\n            )\n\n        # --- Odor deposition (vectorized if possible) ---\n        deposit_xs = []\n        deposit_ys = []\n        kernels = []\n        for a in range(num):\n            deposits = self.odor_release_strategy.release_odor(\n                states[a, i - 1],\n                (xs[a, i - 1], ys[a, i - 1]),\n                headings[a, i - 1],\n                cfg,\n                self.rng,\n            )\n            for deposit in deposits:\n                dx, dy = deposit.offset\n                # Compute global deposit offset for this animal (scalar)\n                global_dx = dx * math.cos(headings[a, i - 1]) - dy * math.sin(\n                    headings[a, i - 1]\n                )\n                global_dy = dx * math.sin(headings[a, i - 1]) + dy * math.cos(\n                    headings[a, i - 1]\n                )\n                deposit_xs.append(xs[a, i - 1] + global_dx)\n                deposit_ys.append(ys[a, i - 1] + global_dy)\n                kernels.append(deposit.generate_kernel(cfg))\n        # If any deposits occurred, try a vectorized deposit if the arena supports it.\n        if deposit_xs:\n            deposit_xs_arr = np.array(deposit_xs)\n            deposit_ys_arr = np.array(deposit_ys)\n            # Check if all kernels have the same shape.\n            if all(k.shape == kernels[0].shape for k in kernels) and hasattr(\n                self.arena, \"deposit_odor_kernels_vectorized\"\n            ):\n                self.arena.deposit_odor_kernels_vectorized(\n                    deposit_xs_arr, deposit_ys_arr, kernels[0]\n                )\n            else:\n                # Fall back to scalar deposits.\n                for dx, dy, kernel in zip(deposit_xs, deposit_ys, kernels):\n                    self.arena.deposit_odor_kernel(dx, dy, kernel)\n\n        # --- Compute sensor positions vectorized ---\n        # Calculate rotated offsets using vectorized trigonometry.\n        current_headings = headings[:, i - 1]  # shape (num,)\n        cos_vals = np.cos(current_headings)\n        sin_vals = np.sin(current_headings)\n        left_offset = np.array(cfg.antenna_left_offset)  # shape (2,)\n        right_offset = np.array(cfg.antenna_right_offset)  # shape (2,)\n        left_dx = left_offset[0] * cos_vals - left_offset[1] * sin_vals\n        left_dy = left_offset[0] * sin_vals + left_offset[1] * cos_vals\n        right_dx = right_offset[0] * cos_vals - right_offset[1] * sin_vals\n        right_dy = right_offset[0] * sin_vals + right_offset[1] * cos_vals\n        left_sensor_x = xs[:, i - 1] + left_dx\n        left_sensor_y = ys[:, i - 1] + left_dy\n        right_sensor_x = xs[:, i - 1] + right_dx\n        right_sensor_y = ys[:, i - 1] + right_dy\n\n        # --- Get odor sensor readings vectorized ---\n        # We assume your arena provides a vectorized get_odor_vectorized method.\n        if hasattr(self.arena, \"get_odor_vectorized\"):\n            odor_left_vals = self.arena.get_odor_vectorized(\n                left_sensor_x, left_sensor_y\n            )\n            odor_right_vals = self.arena.get_odor_vectorized(\n                right_sensor_x, right_sensor_y\n            )\n        else:\n            odor_left_vals = np.array(\n                [\n                    self.arena.get_odor(x, y)\n                    for x, y in zip(left_sensor_x, left_sensor_y)\n                ]\n            )\n            odor_right_vals = np.array(\n                [\n                    self.arena.get_odor(x, y)\n                    for x, y in zip(right_sensor_x, right_sensor_y)\n                ]\n            )\n        odor_left_arr[:, i] = odor_left_vals\n        odor_right_arr[:, i] = odor_right_vals\n\n        # --- Update perceived odor (still per-animal) ---\n        dt = 1.0 / cfg.fps\n        for a in range(num):\n            perc_left, perc_right = self.odor_perceptions[a].perceive_odor(\n                odor_left_arr[a, i], odor_right_arr[a, i], dt\n            )\n            perc_odor_left_arr[a, i] = perc_left\n            perc_odor_right_arr[a, i] = perc_right\n\n        # --- Update headings (per-animal) ---\n        for a in range(num):\n            headings[a, i] = self.behavior.update_heading(\n                headings[a, i - 1],\n                perc_odor_left_arr[a, i],\n                perc_odor_right_arr[a, i],\n                False,\n                cfg,\n                self.rng,\n            )\n\n        # --- Compute new positions vectorized ---\n        # Compute walking distances for each animal.\n        current_speeds = np.array([cfg.walking_speed_sampler() for _ in range(num)])\n        walking_distance = current_speeds / cfg.fps\n        proposed_x = xs[:, i - 1] + np.cos(headings[:, i]) * walking_distance\n        proposed_y = ys[:, i - 1] + np.sin(headings[:, i]) * walking_distance\n\n        # Use vectorized free-space check if available.\n        if hasattr(self.arena, \"is_free_vectorized\"):\n            free = self.arena.is_free_vectorized(proposed_x, proposed_y)\n        else:\n            free = np.array(\n                [self.arena.is_free(x, y) for x, y in zip(proposed_x, proposed_y)]\n            )\n        xs[:, i] = np.where(free, proposed_x, xs[:, i - 1])\n        ys[:, i] = np.where(free, proposed_y, ys[:, i - 1])\n\n        # --- Update the odor field ---\n        if cfg.diffusion_coefficient &gt; 0 or cfg.odor_decay_rate &gt; 0:\n            self.arena.update_odor_field(dt=dt)\n\n        if i % max(1, N // 100) == 0:\n            logger.info(\n                f\"Vectorized simulation progress: frame {i}/{N} ({i / N:.0%} done)\"\n            )\n\n    # Pack the result into a dictionary.\n    result = {\n        \"trajectories\": [\n            {\n                \"x\": xs[a, :].tolist(),\n                \"y\": ys[a, :].tolist(),\n                \"heading\": headings[a, :].tolist(),\n                \"state\": states[a, :].tolist(),\n                \"odor_left\": odor_left_arr[a, :].tolist(),\n                \"odor_right\": odor_right_arr[a, :].tolist(),\n                \"perceived_odor_left\": perc_odor_left_arr[a, :].tolist(),\n                \"perceived_odor_right\": perc_odor_right_arr[a, :].tolist(),\n            }\n            for a in range(num)\n        ],\n        \"final_odor_grid\": self.arena.odor_grid,\n    }\n    return result\n</code></pre>"},{"location":"api/sim/visualization/","title":"Visualization","text":""},{"location":"api/sim/visualization/#arthroscape.sim.visualization","title":"<code>arthroscape.sim.visualization</code>","text":"<p>Visualization module for ArthroScape.</p> <p>This module provides tools for visualizing simulation results, including: - Static plots of trajectories colored by odor intensity. - Heatmaps of the final odor field. - Time-series plots of odor concentration at antennae. - Animations of animal movement and odor sensing using Matplotlib and OpenCV.</p>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.VisualizationPipeline","title":"<code>VisualizationPipeline</code>","text":"<p>A pipeline for generating visualizations from simulation results.</p> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>class VisualizationPipeline:\n    \"\"\"\n    A pipeline for generating visualizations from simulation results.\n    \"\"\"\n\n    def __init__(\n        self,\n        sim_results: List[Dict[str, Any]],\n        config: SimulationConfig,\n        arena: GridArena,\n    ):\n        \"\"\"\n        Initialize the visualization pipeline.\n\n        Args:\n            sim_results (List[Dict[str, Any]]): A list of simulation result dictionaries.\n                                                Each result should contain \"trajectories\" and optionally \"final_odor_grid\".\n            config (SimulationConfig): The simulation configuration.\n            arena (GridArena): The arena object used in the simulation.\n        \"\"\"\n        self.sim_results = sim_results\n        self.config = config\n        self.arena = arena\n\n    def plot_trajectories_with_odor(\n        self,\n        sim_index: int = 0,\n        show: bool = True,\n        save_path: str = None,\n        wraparound: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Plot all animals' trajectories colored by average odor intensity.\n\n        Args:\n            sim_index (int): Index of the simulation replicate to plot. Defaults to 0.\n            show (bool): Whether to display the plot. Defaults to True.\n            save_path (str, optional): Path to save the plot image. Defaults to None.\n            wraparound (bool): If True, segments trajectories to handle periodic boundaries. Defaults to False.\n        \"\"\"\n        result = self.sim_results[sim_index]\n        fig, ax = plt.subplots(figsize=(8, 8))\n        colors = plt.cm.tab10(np.linspace(0, 1, len(result[\"trajectories\"])))\n\n        for idx, traj in enumerate(result[\"trajectories\"]):\n            x = np.array(traj[\"x\"])\n            y = np.array(traj[\"y\"])\n\n            if wraparound:\n                x_wrapped = wrap_coordinates(\n                    x, self.config.grid_x_min, self.config.grid_x_max\n                )\n                y_wrapped = wrap_coordinates(\n                    y, self.config.grid_y_min, self.config.grid_y_max\n                )\n                segments_idx = segment_trajectory_with_indices(\n                    x_wrapped,\n                    y_wrapped,\n                    self.config.grid_x_min,\n                    self.config.grid_x_max,\n                    self.config.grid_y_min,\n                    self.config.grid_y_max,\n                )\n            else:\n                segments_idx = [(0, len(x))]\n                x_wrapped = x\n                y_wrapped = y\n\n            avg_odor = (\n                np.array(traj[\"odor_left\"]) + np.array(traj[\"odor_right\"])\n            ) / 2.0\n\n            for start, end in segments_idx:\n                if end - start &lt; 2:\n                    continue\n                segment = np.column_stack((x_wrapped[start:end], y_wrapped[start:end]))\n                lc = LineCollection(\n                    [segment],\n                    cmap=\"viridis\",\n                    norm=plt.Normalize(vmin=avg_odor.min(), vmax=avg_odor.max()),\n                )\n                lc.set_array(avg_odor[start : end - 1])\n                lc.set_linewidth(0.5)\n                ax.add_collection(lc)\n\n        ax.set_xlim(self.config.grid_x_min, self.config.grid_x_max)\n        ax.set_ylim(self.config.grid_y_min, self.config.grid_y_max)\n        ax.set_title(\"Fly Trajectories Colored by Average Odor\")\n        ax.set_xlabel(\"x (mm)\")\n        ax.set_ylabel(\"y (mm)\")\n        ax.set_aspect(\"equal\")\n        fig.colorbar(lc, ax=ax, label=\"Average Odor Intensity\")\n        if save_path:\n            plt.savefig(save_path, dpi=150)\n        if show:\n            plt.show()\n        plt.close(fig)\n\n    def plot_final_odor_grid(\n        self,\n        sim_index: int = 0,\n        downsample_factor: int = 1,\n        show: bool = True,\n        save_path: str = None,\n    ) -&gt; None:\n        \"\"\"\n        Plot the final odor grid as a heatmap.\n\n        Args:\n            sim_index (int): Index of the simulation replicate. Defaults to 0.\n            downsample_factor (int): Factor by which to downsample the grid for plotting. Defaults to 1.\n            show (bool): Whether to display the plot. Defaults to True.\n            save_path (str, optional): Path to save the plot image. Defaults to None.\n        \"\"\"\n        result = self.sim_results[sim_index]\n        odor_grid = result[\"final_odor_grid\"]\n        if downsample_factor &gt; 1:\n            odor_grid = odor_grid[::downsample_factor, ::downsample_factor]\n            extent = [\n                self.config.grid_x_min,\n                self.config.grid_x_max,\n                self.config.grid_y_min,\n                self.config.grid_y_max,\n            ]\n        else:\n            extent = [\n                self.config.grid_x_min,\n                self.config.grid_x_max,\n                self.config.grid_y_min,\n                self.config.grid_y_max,\n            ]\n        fig, ax = plt.subplots(figsize=(8, 8))\n        im = ax.imshow(odor_grid, origin=\"lower\", extent=extent, cmap=\"viridis\")\n        ax.set_title(\"Final Odor Grid\")\n        ax.set_xlabel(\"x (mm)\")\n        ax.set_ylabel(\"y (mm)\")\n        ax.set_aspect(\"equal\")\n        fig.colorbar(im, ax=ax, label=\"Odor Intensity\")\n        if save_path:\n            plt.savefig(save_path, dpi=150)\n        if show:\n            plt.show()\n        plt.close(fig)\n\n    def plot_odor_time_series(\n        self, sim_index: int = 0, show: bool = True, save_path: str = None\n    ) -&gt; None:\n        \"\"\"\n        Plot time series of odor intensity at the antennae for all animals.\n\n        Args:\n            sim_index (int): Index of the simulation replicate. Defaults to 0.\n            show (bool): Whether to display the plot. Defaults to True.\n            save_path (str, optional): Path to save the plot image. Defaults to None.\n        \"\"\"\n        result = self.sim_results[sim_index]\n        fig, ax = plt.subplots(figsize=(10, 4))\n        for idx, traj in enumerate(result[\"trajectories\"]):\n            ax.plot(traj[\"odor_left\"], label=f\"Animal {idx+1} Left\", lw=2)\n            ax.plot(\n                traj[\"odor_right\"], label=f\"Animal {idx+1} Right\", lw=2, linestyle=\"--\"\n            )\n        ax.set_xlabel(\"Frame\")\n        ax.set_ylabel(\"Odor Intensity\")\n        ax.set_title(\"Odor Time Series at Antennae\")\n        ax.legend(loc=\"upper right\")\n        if save_path:\n            plt.savefig(save_path, dpi=150)\n        if show:\n            plt.show()\n        plt.close(fig)\n\n    def animate_enhanced_trajectory(\n        self,\n        sim_index: int = 0,\n        interval: int = 50,\n        frame_skip: int = 5,\n        save_path: str = None,\n        wraparound: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Create an enhanced animation using Matplotlib.\n\n        Animates trajectories for all animals with heading arrows and antenna markers.\n        Handles wraparound boundaries by segmenting trajectories.\n\n        Args:\n            sim_index (int): Index of the simulation replicate. Defaults to 0.\n            interval (int): Delay between frames in milliseconds. Defaults to 50.\n            frame_skip (int): Number of simulation frames to skip per animation frame. Defaults to 5.\n            save_path (str, optional): Path to save the animation (e.g., .mp4 or .gif). Defaults to None.\n            wraparound (bool): Whether to handle periodic boundaries. Defaults to False.\n        \"\"\"\n        result = self.sim_results[sim_index]\n        cfg = self.config\n        num = len(result[\"trajectories\"])\n        colors = plt.cm.rainbow(np.linspace(0, 1, num))\n\n        # Pre-compute segmentation indices if wraparound is enabled.\n        seg_indices = []\n        if wraparound:\n            for traj in result[\"trajectories\"]:\n                x = np.array(traj[\"x\"])\n                y = np.array(traj[\"y\"])\n                x_wrapped = wrap_coordinates(x, cfg.grid_x_min, cfg.grid_x_max)\n                y_wrapped = wrap_coordinates(y, cfg.grid_y_min, cfg.grid_y_max)\n                seg_idx = segment_trajectory_with_indices(\n                    x_wrapped,\n                    y_wrapped,\n                    cfg.grid_x_min,\n                    cfg.grid_x_max,\n                    cfg.grid_y_min,\n                    cfg.grid_y_max,\n                )\n                seg_indices.append(seg_idx)\n        else:\n            seg_indices = [[(0, len(traj[\"x\"]))] for traj in result[\"trajectories\"]]\n\n        fig, ax = plt.subplots(figsize=(8, 8))\n        ax.set_xlim(cfg.grid_x_min, cfg.grid_x_max)\n        ax.set_ylim(cfg.grid_y_min, cfg.grid_y_max)\n        ax.set_xlabel(\"x (mm)\")\n        ax.set_ylabel(\"y (mm)\")\n        ax.set_title(\"Enhanced Multi-Animal Trajectory Animation\")\n        ax.set_aspect(\"equal\")\n\n        # Create a LineCollection for each animal to hold segments.\n        line_collections = []\n        for idx in range(num):\n            lc = LineCollection([], colors=[colors[idx]], linewidths=0.5)\n            line_collections.append(lc)\n            ax.add_collection(lc)\n\n        # Create heading arrows and antenna scatter objects.\n        heading_arrows = [None] * num\n        left_scatters = []\n        right_scatters = []\n        for idx in range(num):\n            ls = ax.scatter([], [], s=[], c=[], cmap=\"viridis\", edgecolors=\"k\")\n            rs = ax.scatter([], [], s=[], c=[], cmap=\"viridis\", edgecolors=\"k\")\n            left_scatters.append(ls)\n            right_scatters.append(rs)\n\n        time_text = ax.text(0.02, 0.95, \"\", transform=ax.transAxes)\n\n        total_frames = len(result[\"trajectories\"][0][\"x\"])\n        frames = range(0, total_frames, frame_skip)\n\n        def init():\n            for lc in line_collections:\n                lc.set_segments([])\n            for idx in range(num):\n                left_scatters[idx].set_offsets(np.empty((0, 2)))\n                right_scatters[idx].set_offsets(np.empty((0, 2)))\n                left_scatters[idx].set_sizes(np.array([]))\n                right_scatters[idx].set_sizes(np.array([]))\n                left_scatters[idx].set_array(np.array([]))\n                right_scatters[idx].set_array(np.array([]))\n                if heading_arrows[idx] is not None:\n                    try:\n                        heading_arrows[idx].remove()\n                    except ValueError:\n                        pass\n                    heading_arrows[idx] = None\n            time_text.set_text(\"\")\n            return line_collections + left_scatters + right_scatters + [time_text]\n\n        def update(frame):\n            for idx, traj in enumerate(result[\"trajectories\"]):\n                x = np.array(traj[\"x\"])\n                y = np.array(traj[\"y\"])\n                if wraparound:\n                    x = wrap_coordinates(x, cfg.grid_x_min, cfg.grid_x_max)\n                    y = wrap_coordinates(y, cfg.grid_y_min, cfg.grid_y_max)\n                segs = seg_indices[idx]\n                segments_to_plot = []\n                for start, end in segs:\n                    if frame &gt; start:\n                        seg_end = min(end, frame)\n                        if seg_end - start &gt; 1:\n                            segments_to_plot.append(\n                                np.column_stack((x[start:seg_end], y[start:seg_end]))\n                            )\n                line_collections[idx].set_segments(segments_to_plot)\n\n                cur_idx = frame - 1\n                cur_x = x[cur_idx]\n                cur_y = y[cur_idx]\n                cur_heading = traj[\"heading\"][cur_idx]\n                # Remove previous arrow if it exists.\n                if heading_arrows[idx] is not None:\n                    try:\n                        heading_arrows[idx].remove()\n                    except ValueError:\n                        pass\n                    heading_arrows[idx] = None\n                arrow_length = 1.5\n                dx = arrow_length * math.cos(cur_heading)\n                dy = arrow_length * math.sin(cur_heading)\n                heading_arrows[idx] = ax.arrow(\n                    cur_x,\n                    cur_y,\n                    dx,\n                    dy,\n                    head_width=1,\n                    head_length=2,\n                    fc=colors[idx],\n                    ec=colors[idx],\n                )\n                left_dx = cfg.antenna_left_offset[0] * math.cos(\n                    cur_heading\n                ) - cfg.antenna_left_offset[1] * math.sin(cur_heading)\n                left_dy = cfg.antenna_left_offset[0] * math.sin(\n                    cur_heading\n                ) + cfg.antenna_left_offset[1] * math.cos(cur_heading)\n                right_dx = cfg.antenna_right_offset[0] * math.cos(\n                    cur_heading\n                ) - cfg.antenna_right_offset[1] * math.sin(cur_heading)\n                right_dy = cfg.antenna_right_offset[0] * math.sin(\n                    cur_heading\n                ) + cfg.antenna_right_offset[1] * math.cos(cur_heading)\n                left_x = cur_x + left_dx\n                left_y = cur_y + left_dy\n                right_x = cur_x + right_dx\n                right_y = cur_y + right_dy\n                odor_left = traj[\"odor_left\"][cur_idx]\n                odor_right = traj[\"odor_right\"][cur_idx]\n                left_scatters[idx].set_offsets(np.array([[left_x, left_y]]))\n                right_scatters[idx].set_offsets(np.array([[right_x, right_y]]))\n                base_size = 100\n                left_scatters[idx].set_sizes(np.array([base_size * odor_left]))\n                right_scatters[idx].set_sizes(np.array([base_size * odor_right]))\n                left_scatters[idx].set_array(np.array([odor_left]))\n                right_scatters[idx].set_array(np.array([odor_right]))\n            time_text.set_text(f\"Frame: {frame}\")\n            return (\n                line_collections\n                + left_scatters\n                + right_scatters\n                + [time_text]\n                + heading_arrows\n            )\n\n        ani = animation.FuncAnimation(\n            fig, update, frames=frames, init_func=init, interval=interval, blit=False\n        )\n        if save_path:\n            ani.save(save_path, writer=\"imagemagick\", fps=1000 // interval)\n        else:\n            plt.show()\n        plt.close(fig)\n\n    def animate_enhanced_trajectory_opencv_old(\n        self,\n        sim_index: int = 0,\n        fps: int = 60,\n        frame_skip: int = 5,\n        wraparound: bool = False,\n        output_file: str = \"animation.mp4\",\n        display: bool = False,\n        progress: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        OpenCV-based animation (legacy version).\n\n        Animates trajectories for all animals with ellipse representations and odor sensor markers.\n\n        Args:\n            sim_index (int): Index of the simulation replicate.\n            fps (int): Frames per second for the output video.\n            frame_skip (int): Process every Nth frame.\n            wraparound (bool): If True, wrap and segment trajectories to avoid spurious connecting lines.\n            output_file (str): Path to the output video file.\n            display (bool): If True, display the animation in an OpenCV window.\n            progress (bool): If True, display a progress bar.\n        \"\"\"\n        result = self.sim_results[sim_index]\n        cfg = self.config\n        x_min, x_max = cfg.grid_x_min, cfg.grid_x_max\n        y_min, y_max = cfg.grid_y_min, cfg.grid_y_max\n\n        # get grid aspect ratio\n        aspect_ratio = (x_max - x_min) / (y_max - y_min)\n\n        # Set a higher resolution (e.g., 1920x1080).\n        img_width, img_height = 1920, int(1920 / aspect_ratio)\n\n        def sim_to_pixel(x, y):\n            # Map simulation coordinates (x, y) to pixel coordinates (col, row).\n            col = int((x - x_min) / (x_max - x_min) * img_width)\n            row = img_height - int((y - y_min) / (y_max - y_min) * img_height)\n            return col, row\n\n        # Generate distinct colors for each trajectory (BGR for OpenCV)\n        cmap = plt.cm.get_cmap(\"rainbow\", len(result[\"trajectories\"]))\n        colors = [\n            tuple(int(255 * c) for c in cmap(i)[:3][::-1])\n            for i in range(len(result[\"trajectories\"]))\n        ]\n\n        # Pre-compute segmentation indices if wraparound is enabled.\n        seg_indices = []\n        if wraparound:\n            for traj in result[\"trajectories\"]:\n                x_arr = np.array(traj[\"x\"])\n                y_arr = np.array(traj[\"y\"])\n                x_wrapped = wrap_coordinates(x_arr, x_min, x_max)\n                y_wrapped = wrap_coordinates(y_arr, y_min, y_max)\n                seg_idx = segment_trajectory_with_indices(\n                    x_wrapped, y_wrapped, x_min, x_max, y_min, y_max\n                )\n                seg_indices.append(seg_idx)\n        else:\n            seg_indices = [[(0, len(traj[\"x\"]))] for traj in result[\"trajectories\"]]\n\n        # Prepare the VideoWriter.\n        fourcc = cv2.VideoWriter_fourcc(*\"mp4v\")\n        fps = int(fps)\n        writer = cv2.VideoWriter(output_file, fourcc, fps, (img_width, img_height))\n\n        total_frames = len(result[\"trajectories\"][0][\"x\"])\n        frames = range(0, total_frames, frame_skip)\n\n        # Parameters for drawing the animal's ellipse.\n        # Define ellipse axes in pixels (half-lengths).\n        ellipse_axes = (20, 10)  # Adjust for a higher resolution display.\n\n        # For time display, compute simulation time from frame index.\n        def format_time(frame_index: int) -&gt; str:\n            t_seconds = frame_index / cfg.fps\n            hours = int(t_seconds // 3600)\n            minutes = int((t_seconds % 3600) // 60)\n            seconds = t_seconds % 60\n            return f\"{hours:02d}:{minutes:02d}:{seconds:05.2f}\"\n\n        for frame in tqdm(frames, disable=not progress):\n            # Create a blank white image.\n            img = np.ones((img_height, img_width, 3), dtype=np.uint8) * 255\n\n            # Draw trajectories (with thin lines).\n            for traj_idx, traj in enumerate(result[\"trajectories\"]):\n                x = np.array(traj[\"x\"])\n                y = np.array(traj[\"y\"])\n                if wraparound:\n                    x = wrap_coordinates(x, x_min, x_max)\n                    y = wrap_coordinates(y, y_min, y_max)\n                segs = seg_indices[traj_idx]\n                for start, end in segs:\n                    if frame &gt; start and (end - start) &gt; 1:\n                        seg_end = min(end, frame)\n                        pts = np.array(\n                            [\n                                sim_to_pixel(xx, yy)\n                                for xx, yy in zip(x[start:seg_end], y[start:seg_end])\n                            ],\n                            dtype=np.int32,\n                        )\n                        if pts.shape[0] &gt;= 2:\n                            cv2.polylines(\n                                img,\n                                [pts],\n                                isClosed=False,\n                                color=colors[traj_idx],\n                                thickness=1,\n                                lineType=cv2.LINE_AA,\n                            )\n\n            # Draw each animal as an ellipse and sensor markers.\n            for traj in result[\"trajectories\"]:\n                if frame &lt; 1:\n                    continue\n                cur_idx = frame - 1\n                cur_x = traj[\"x\"][cur_idx]\n                cur_y = traj[\"y\"][cur_idx]\n                if wraparound:\n                    cur_x = wrap_coordinates(np.array([cur_x]), x_min, x_max)[0]\n                    cur_y = wrap_coordinates(np.array([cur_y]), y_min, y_max)[0]\n                center = sim_to_pixel(cur_x, cur_y)\n                cur_heading = traj[\"heading\"][cur_idx]\n                # OpenCV's ellipse function expects the angle in degrees (clockwise, so we use negative).\n                angle_deg = -math.degrees(cur_heading)\n                cv2.ellipse(\n                    img,\n                    center,\n                    ellipse_axes,\n                    angle_deg,\n                    0,\n                    360,\n                    colors[result[\"trajectories\"].index(traj)],\n                    thickness=1,\n                    lineType=cv2.LINE_AA,\n                )\n\n                # Draw sensor markers as circles.\n                left_dx = cfg.antenna_left_offset[0] * math.cos(\n                    cur_heading\n                ) - cfg.antenna_left_offset[1] * math.sin(cur_heading)\n                left_dy = cfg.antenna_left_offset[0] * math.sin(\n                    cur_heading\n                ) + cfg.antenna_left_offset[1] * math.cos(cur_heading)\n                right_dx = cfg.antenna_right_offset[0] * math.cos(\n                    cur_heading\n                ) - cfg.antenna_right_offset[1] * math.sin(cur_heading)\n                right_dy = cfg.antenna_right_offset[0] * math.sin(\n                    cur_heading\n                ) + cfg.antenna_right_offset[1] * math.cos(cur_heading)\n                left_x = cur_x + left_dx\n                left_y = cur_y + left_dy\n                right_x = cur_x + right_dx\n                right_y = cur_y + right_dy\n                left_center = sim_to_pixel(left_x, left_y)\n                right_center = sim_to_pixel(right_x, right_y)\n                odor_left = traj[\"odor_left\"][cur_idx]\n                odor_right = traj[\"odor_right\"][cur_idx]\n                # Scale marker radius by odor intensity.\n                scale = 10\n                radius_left = max(3, int(scale * np.log1p(odor_left)))\n                radius_right = max(3, int(scale * np.log1p(odor_right)))\n                cv2.circle(\n                    img,\n                    left_center,\n                    radius_left,\n                    color=(255, 0, 0),\n                    thickness=-1,\n                    lineType=cv2.LINE_AA,\n                )\n                cv2.circle(\n                    img,\n                    right_center,\n                    radius_right,\n                    color=(0, 0, 255),\n                    thickness=-1,\n                    lineType=cv2.LINE_AA,\n                )\n\n            # Draw time information.\n            time_str = format_time(frame)\n            cv2.putText(\n                img,\n                f\"Time: {time_str}\",\n                (10, img_height - 20),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                0.9,\n                (50, 50, 50),\n                thickness=2,\n                lineType=cv2.LINE_AA,\n            )\n\n            if display:\n                cv2.imshow(\"Simulation Animation\", img)\n                if cv2.waitKey(interval) &amp; 0xFF == ord(\"q\"):\n                    break\n\n            writer.write(img)\n\n        writer.release()\n        if display:\n            cv2.destroyAllWindows()\n        logger.info(f\"OpenCV animation saved to {output_file}\")\n\n    def animate_enhanced_trajectory_opencv(\n        self,\n        sim_index: int = 0,\n        fps: int = 60,\n        frame_skip: int = 5,\n        wraparound: bool = False,\n        output_file: str = \"animation.mp4\",\n        display: bool = False,\n        progress: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Create an optimized OpenCV-based animation.\n\n        This version caches cumulative trajectory tracks to avoid redrawing the entire history\n        at every frame, significantly improving performance. It also handles wraparound boundaries\n        correctly by segmenting trajectories.\n\n        Args:\n            sim_index (int): Index of the simulation replicate. Defaults to 0.\n            fps (int): Frames per second for the output video. Defaults to 60.\n            frame_skip (int): Process every Nth frame. Defaults to 5.\n            wraparound (bool): If True, use segmentation to avoid drawing across wrap boundaries. Defaults to False.\n            output_file (str): Path to the output video file. Defaults to \"animation.mp4\".\n            display (bool): If True, display the animation in an OpenCV window. Defaults to False.\n            progress (bool): If True, display a progress bar. Defaults to True.\n        \"\"\"\n\n        # Get simulation results and configuration.\n        result = self.sim_results[sim_index]\n        cfg = self.config\n        x_min, x_max = cfg.grid_x_min, cfg.grid_x_max\n        y_min, y_max = cfg.grid_y_min, cfg.grid_y_max\n\n        # Compute aspect ratio and output image size.\n        aspect_ratio = (x_max - x_min) / (y_max - y_min)\n        img_width, img_height = 1920, int(1920 / aspect_ratio)\n\n        def sim_to_pixel(x, y):\n            \"\"\"Map simulation coordinates (mm) to pixel coordinates.\"\"\"\n            col = int((x - x_min) / (x_max - x_min) * img_width)\n            row = img_height - int((y - y_min) / (y_max - y_min) * img_height)\n            return col, row\n\n        # Precompute pixel trajectories and segments for each animal.\n        pixel_trajs = []\n        segments_list = []  # List of lists of (start, end) indices for each animal\n        for traj in result[\"trajectories\"]:\n            xs = np.array(traj[\"x\"])\n            ys = np.array(traj[\"y\"])\n            if wraparound:\n                xs_wrapped = wrap_coordinates(xs, x_min, x_max)\n                ys_wrapped = wrap_coordinates(ys, y_min, y_max)\n            else:\n                xs_wrapped, ys_wrapped = xs, ys\n            pts = [sim_to_pixel(x, y) for x, y in zip(xs_wrapped, ys_wrapped)]\n            pixel_trajs.append(pts)\n            if wraparound:\n                segs = segment_trajectory_with_indices(\n                    xs_wrapped, ys_wrapped, x_min, x_max, y_min, y_max\n                )\n            else:\n                segs = [(0, len(pts))]\n            segments_list.append(segs)\n\n        # Cache: create a background image to accumulate trajectory tracks.\n        track_img = np.ones((img_height, img_width, 3), dtype=np.uint8) * 255\n        # For each animal, track the last drawn index per segment.\n        # We store a list (one per animal) of lists (one per segment) with the last drawn index.\n        last_drawn = []\n        for segs in segments_list:\n            last_drawn.append(\n                [s[0] for s in segs]\n            )  # initialize at each segment's start\n\n        # Get colors for each trajectory.\n        cmap = plt.cm.get_cmap(\"rainbow\", len(result[\"trajectories\"]))\n        colors = [\n            tuple(int(255 * c) for c in cmap(i)[:3][::-1])\n            for i in range(len(result[\"trajectories\"]))\n        ]\n\n        # Set up video writer.\n        fourcc = cv2.VideoWriter_fourcc(*\"mp4v\")\n        writer = cv2.VideoWriter(output_file, fourcc, fps, (img_width, img_height))\n\n        total_frames = len(result[\"trajectories\"][0][\"x\"])\n        frames = range(0, total_frames, frame_skip)\n\n        # Animation loop.\n        for frame in tqdm(frames, disable=not progress):\n            # Update cached track image: for each animal and each segment, add new line segments.\n            for a, pts in enumerate(pixel_trajs):\n                segs = segments_list[a]\n                for s_idx, (start, end) in enumerate(segs):\n                    # Only update if the current frame is within this segment.\n                    if frame &gt; start:\n                        # Determine segment endpoint to draw.\n                        seg_end = min(end, frame)\n                        # Only draw if new points exist.\n                        if seg_end - last_drawn[a][s_idx] &gt;= 1:\n                            for k in range(last_drawn[a][s_idx], seg_end - 1):\n                                cv2.line(\n                                    track_img,\n                                    pts[k],\n                                    pts[k + 1],\n                                    colors[a],\n                                    thickness=1,\n                                    lineType=cv2.LINE_AA,\n                                )\n                            last_drawn[a][s_idx] = seg_end\n\n            # Start with a copy of the cached track background.\n            frame_img = track_img.copy()\n\n            # Draw current animal markers (ellipse and sensor markers).\n            for traj_idx, traj in enumerate(result[\"trajectories\"]):\n                if frame &lt; 1:\n                    continue\n                cur_idx = frame - 1\n                # For wraparound, use wrapped coordinates.\n                if wraparound:\n                    cur_x = wrap_coordinates(\n                        np.array([traj[\"x\"][cur_idx]]), x_min, x_max\n                    )[0]\n                    cur_y = wrap_coordinates(\n                        np.array([traj[\"y\"][cur_idx]]), y_min, y_max\n                    )[0]\n                else:\n                    cur_x = traj[\"x\"][cur_idx]\n                    cur_y = traj[\"y\"][cur_idx]\n                center = sim_to_pixel(cur_x, cur_y)\n                cur_heading = traj[\"heading\"][cur_idx]\n                angle_deg = -math.degrees(cur_heading)\n                cv2.ellipse(\n                    frame_img,\n                    center,\n                    (20, 10),\n                    angle_deg,\n                    0,\n                    360,\n                    colors[traj_idx],\n                    thickness=1,\n                    lineType=cv2.LINE_AA,\n                )\n\n                # Compute antenna positions.\n                left_dx = cfg.antenna_left_offset[0] * math.cos(\n                    cur_heading\n                ) - cfg.antenna_left_offset[1] * math.sin(cur_heading)\n                left_dy = cfg.antenna_left_offset[0] * math.sin(\n                    cur_heading\n                ) + cfg.antenna_left_offset[1] * math.cos(cur_heading)\n                right_dx = cfg.antenna_right_offset[0] * math.cos(\n                    cur_heading\n                ) - cfg.antenna_right_offset[1] * math.sin(cur_heading)\n                right_dy = cfg.antenna_right_offset[0] * math.sin(\n                    cur_heading\n                ) + cfg.antenna_right_offset[1] * math.cos(cur_heading)\n                left_x = cur_x + left_dx\n                left_y = cur_y + left_dy\n                right_x = cur_x + right_dx\n                right_y = cur_y + right_dy\n                left_pt = sim_to_pixel(left_x, left_y)\n                right_pt = sim_to_pixel(right_x, right_y)\n                odor_left = traj[\"odor_left\"][cur_idx]\n                odor_right = traj[\"odor_right\"][cur_idx]\n                scale = 10\n                radius_left = max(3, int(scale * np.log1p(odor_left)))\n                radius_right = max(3, int(scale * np.log1p(odor_right)))\n                cv2.circle(\n                    frame_img,\n                    left_pt,\n                    radius_left,\n                    (255, 0, 0),\n                    thickness=-1,\n                    lineType=cv2.LINE_AA,\n                )\n                cv2.circle(\n                    frame_img,\n                    right_pt,\n                    radius_right,\n                    (0, 0, 255),\n                    thickness=-1,\n                    lineType=cv2.LINE_AA,\n                )\n\n            # Draw time information.\n            t_seconds = frame / cfg.fps\n            hours = int(t_seconds // 3600)\n            minutes = int((t_seconds % 3600) // 60)\n            seconds = t_seconds % 60\n            time_str = f\"{hours:02d}:{minutes:02d}:{seconds:05.2f}\"\n            cv2.putText(\n                frame_img,\n                f\"Time: {time_str}\",\n                (10, img_height - 20),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                0.9,\n                (50, 50, 50),\n                thickness=2,\n                lineType=cv2.LINE_AA,\n            )\n\n            if display:\n                cv2.imshow(\"Simulation Animation\", frame_img)\n                if cv2.waitKey(int(1000 / fps)) &amp; 0xFF == ord(\"q\"):\n                    break\n\n            writer.write(frame_img)\n\n        writer.release()\n        if display:\n            cv2.destroyAllWindows()\n        logger.info(f\"OpenCV animation saved to {output_file}\")\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.VisualizationPipeline.__init__","title":"<code>__init__(sim_results, config, arena)</code>","text":"<p>Initialize the visualization pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>sim_results</code> <code>List[Dict[str, Any]]</code> <p>A list of simulation result dictionaries.                                 Each result should contain \"trajectories\" and optionally \"final_odor_grid\".</p> required <code>config</code> <code>SimulationConfig</code> <p>The simulation configuration.</p> required <code>arena</code> <code>GridArena</code> <p>The arena object used in the simulation.</p> required Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def __init__(\n    self,\n    sim_results: List[Dict[str, Any]],\n    config: SimulationConfig,\n    arena: GridArena,\n):\n    \"\"\"\n    Initialize the visualization pipeline.\n\n    Args:\n        sim_results (List[Dict[str, Any]]): A list of simulation result dictionaries.\n                                            Each result should contain \"trajectories\" and optionally \"final_odor_grid\".\n        config (SimulationConfig): The simulation configuration.\n        arena (GridArena): The arena object used in the simulation.\n    \"\"\"\n    self.sim_results = sim_results\n    self.config = config\n    self.arena = arena\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.VisualizationPipeline.animate_enhanced_trajectory","title":"<code>animate_enhanced_trajectory(sim_index=0, interval=50, frame_skip=5, save_path=None, wraparound=False)</code>","text":"<p>Create an enhanced animation using Matplotlib.</p> <p>Animates trajectories for all animals with heading arrows and antenna markers. Handles wraparound boundaries by segmenting trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>sim_index</code> <code>int</code> <p>Index of the simulation replicate. Defaults to 0.</p> <code>0</code> <code>interval</code> <code>int</code> <p>Delay between frames in milliseconds. Defaults to 50.</p> <code>50</code> <code>frame_skip</code> <code>int</code> <p>Number of simulation frames to skip per animation frame. Defaults to 5.</p> <code>5</code> <code>save_path</code> <code>str</code> <p>Path to save the animation (e.g., .mp4 or .gif). Defaults to None.</p> <code>None</code> <code>wraparound</code> <code>bool</code> <p>Whether to handle periodic boundaries. Defaults to False.</p> <code>False</code> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def animate_enhanced_trajectory(\n    self,\n    sim_index: int = 0,\n    interval: int = 50,\n    frame_skip: int = 5,\n    save_path: str = None,\n    wraparound: bool = False,\n) -&gt; None:\n    \"\"\"\n    Create an enhanced animation using Matplotlib.\n\n    Animates trajectories for all animals with heading arrows and antenna markers.\n    Handles wraparound boundaries by segmenting trajectories.\n\n    Args:\n        sim_index (int): Index of the simulation replicate. Defaults to 0.\n        interval (int): Delay between frames in milliseconds. Defaults to 50.\n        frame_skip (int): Number of simulation frames to skip per animation frame. Defaults to 5.\n        save_path (str, optional): Path to save the animation (e.g., .mp4 or .gif). Defaults to None.\n        wraparound (bool): Whether to handle periodic boundaries. Defaults to False.\n    \"\"\"\n    result = self.sim_results[sim_index]\n    cfg = self.config\n    num = len(result[\"trajectories\"])\n    colors = plt.cm.rainbow(np.linspace(0, 1, num))\n\n    # Pre-compute segmentation indices if wraparound is enabled.\n    seg_indices = []\n    if wraparound:\n        for traj in result[\"trajectories\"]:\n            x = np.array(traj[\"x\"])\n            y = np.array(traj[\"y\"])\n            x_wrapped = wrap_coordinates(x, cfg.grid_x_min, cfg.grid_x_max)\n            y_wrapped = wrap_coordinates(y, cfg.grid_y_min, cfg.grid_y_max)\n            seg_idx = segment_trajectory_with_indices(\n                x_wrapped,\n                y_wrapped,\n                cfg.grid_x_min,\n                cfg.grid_x_max,\n                cfg.grid_y_min,\n                cfg.grid_y_max,\n            )\n            seg_indices.append(seg_idx)\n    else:\n        seg_indices = [[(0, len(traj[\"x\"]))] for traj in result[\"trajectories\"]]\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n    ax.set_xlim(cfg.grid_x_min, cfg.grid_x_max)\n    ax.set_ylim(cfg.grid_y_min, cfg.grid_y_max)\n    ax.set_xlabel(\"x (mm)\")\n    ax.set_ylabel(\"y (mm)\")\n    ax.set_title(\"Enhanced Multi-Animal Trajectory Animation\")\n    ax.set_aspect(\"equal\")\n\n    # Create a LineCollection for each animal to hold segments.\n    line_collections = []\n    for idx in range(num):\n        lc = LineCollection([], colors=[colors[idx]], linewidths=0.5)\n        line_collections.append(lc)\n        ax.add_collection(lc)\n\n    # Create heading arrows and antenna scatter objects.\n    heading_arrows = [None] * num\n    left_scatters = []\n    right_scatters = []\n    for idx in range(num):\n        ls = ax.scatter([], [], s=[], c=[], cmap=\"viridis\", edgecolors=\"k\")\n        rs = ax.scatter([], [], s=[], c=[], cmap=\"viridis\", edgecolors=\"k\")\n        left_scatters.append(ls)\n        right_scatters.append(rs)\n\n    time_text = ax.text(0.02, 0.95, \"\", transform=ax.transAxes)\n\n    total_frames = len(result[\"trajectories\"][0][\"x\"])\n    frames = range(0, total_frames, frame_skip)\n\n    def init():\n        for lc in line_collections:\n            lc.set_segments([])\n        for idx in range(num):\n            left_scatters[idx].set_offsets(np.empty((0, 2)))\n            right_scatters[idx].set_offsets(np.empty((0, 2)))\n            left_scatters[idx].set_sizes(np.array([]))\n            right_scatters[idx].set_sizes(np.array([]))\n            left_scatters[idx].set_array(np.array([]))\n            right_scatters[idx].set_array(np.array([]))\n            if heading_arrows[idx] is not None:\n                try:\n                    heading_arrows[idx].remove()\n                except ValueError:\n                    pass\n                heading_arrows[idx] = None\n        time_text.set_text(\"\")\n        return line_collections + left_scatters + right_scatters + [time_text]\n\n    def update(frame):\n        for idx, traj in enumerate(result[\"trajectories\"]):\n            x = np.array(traj[\"x\"])\n            y = np.array(traj[\"y\"])\n            if wraparound:\n                x = wrap_coordinates(x, cfg.grid_x_min, cfg.grid_x_max)\n                y = wrap_coordinates(y, cfg.grid_y_min, cfg.grid_y_max)\n            segs = seg_indices[idx]\n            segments_to_plot = []\n            for start, end in segs:\n                if frame &gt; start:\n                    seg_end = min(end, frame)\n                    if seg_end - start &gt; 1:\n                        segments_to_plot.append(\n                            np.column_stack((x[start:seg_end], y[start:seg_end]))\n                        )\n            line_collections[idx].set_segments(segments_to_plot)\n\n            cur_idx = frame - 1\n            cur_x = x[cur_idx]\n            cur_y = y[cur_idx]\n            cur_heading = traj[\"heading\"][cur_idx]\n            # Remove previous arrow if it exists.\n            if heading_arrows[idx] is not None:\n                try:\n                    heading_arrows[idx].remove()\n                except ValueError:\n                    pass\n                heading_arrows[idx] = None\n            arrow_length = 1.5\n            dx = arrow_length * math.cos(cur_heading)\n            dy = arrow_length * math.sin(cur_heading)\n            heading_arrows[idx] = ax.arrow(\n                cur_x,\n                cur_y,\n                dx,\n                dy,\n                head_width=1,\n                head_length=2,\n                fc=colors[idx],\n                ec=colors[idx],\n            )\n            left_dx = cfg.antenna_left_offset[0] * math.cos(\n                cur_heading\n            ) - cfg.antenna_left_offset[1] * math.sin(cur_heading)\n            left_dy = cfg.antenna_left_offset[0] * math.sin(\n                cur_heading\n            ) + cfg.antenna_left_offset[1] * math.cos(cur_heading)\n            right_dx = cfg.antenna_right_offset[0] * math.cos(\n                cur_heading\n            ) - cfg.antenna_right_offset[1] * math.sin(cur_heading)\n            right_dy = cfg.antenna_right_offset[0] * math.sin(\n                cur_heading\n            ) + cfg.antenna_right_offset[1] * math.cos(cur_heading)\n            left_x = cur_x + left_dx\n            left_y = cur_y + left_dy\n            right_x = cur_x + right_dx\n            right_y = cur_y + right_dy\n            odor_left = traj[\"odor_left\"][cur_idx]\n            odor_right = traj[\"odor_right\"][cur_idx]\n            left_scatters[idx].set_offsets(np.array([[left_x, left_y]]))\n            right_scatters[idx].set_offsets(np.array([[right_x, right_y]]))\n            base_size = 100\n            left_scatters[idx].set_sizes(np.array([base_size * odor_left]))\n            right_scatters[idx].set_sizes(np.array([base_size * odor_right]))\n            left_scatters[idx].set_array(np.array([odor_left]))\n            right_scatters[idx].set_array(np.array([odor_right]))\n        time_text.set_text(f\"Frame: {frame}\")\n        return (\n            line_collections\n            + left_scatters\n            + right_scatters\n            + [time_text]\n            + heading_arrows\n        )\n\n    ani = animation.FuncAnimation(\n        fig, update, frames=frames, init_func=init, interval=interval, blit=False\n    )\n    if save_path:\n        ani.save(save_path, writer=\"imagemagick\", fps=1000 // interval)\n    else:\n        plt.show()\n    plt.close(fig)\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.VisualizationPipeline.animate_enhanced_trajectory_opencv","title":"<code>animate_enhanced_trajectory_opencv(sim_index=0, fps=60, frame_skip=5, wraparound=False, output_file='animation.mp4', display=False, progress=True)</code>","text":"<p>Create an optimized OpenCV-based animation.</p> <p>This version caches cumulative trajectory tracks to avoid redrawing the entire history at every frame, significantly improving performance. It also handles wraparound boundaries correctly by segmenting trajectories.</p> <p>Parameters:</p> Name Type Description Default <code>sim_index</code> <code>int</code> <p>Index of the simulation replicate. Defaults to 0.</p> <code>0</code> <code>fps</code> <code>int</code> <p>Frames per second for the output video. Defaults to 60.</p> <code>60</code> <code>frame_skip</code> <code>int</code> <p>Process every Nth frame. Defaults to 5.</p> <code>5</code> <code>wraparound</code> <code>bool</code> <p>If True, use segmentation to avoid drawing across wrap boundaries. Defaults to False.</p> <code>False</code> <code>output_file</code> <code>str</code> <p>Path to the output video file. Defaults to \"animation.mp4\".</p> <code>'animation.mp4'</code> <code>display</code> <code>bool</code> <p>If True, display the animation in an OpenCV window. Defaults to False.</p> <code>False</code> <code>progress</code> <code>bool</code> <p>If True, display a progress bar. Defaults to True.</p> <code>True</code> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def animate_enhanced_trajectory_opencv(\n    self,\n    sim_index: int = 0,\n    fps: int = 60,\n    frame_skip: int = 5,\n    wraparound: bool = False,\n    output_file: str = \"animation.mp4\",\n    display: bool = False,\n    progress: bool = True,\n) -&gt; None:\n    \"\"\"\n    Create an optimized OpenCV-based animation.\n\n    This version caches cumulative trajectory tracks to avoid redrawing the entire history\n    at every frame, significantly improving performance. It also handles wraparound boundaries\n    correctly by segmenting trajectories.\n\n    Args:\n        sim_index (int): Index of the simulation replicate. Defaults to 0.\n        fps (int): Frames per second for the output video. Defaults to 60.\n        frame_skip (int): Process every Nth frame. Defaults to 5.\n        wraparound (bool): If True, use segmentation to avoid drawing across wrap boundaries. Defaults to False.\n        output_file (str): Path to the output video file. Defaults to \"animation.mp4\".\n        display (bool): If True, display the animation in an OpenCV window. Defaults to False.\n        progress (bool): If True, display a progress bar. Defaults to True.\n    \"\"\"\n\n    # Get simulation results and configuration.\n    result = self.sim_results[sim_index]\n    cfg = self.config\n    x_min, x_max = cfg.grid_x_min, cfg.grid_x_max\n    y_min, y_max = cfg.grid_y_min, cfg.grid_y_max\n\n    # Compute aspect ratio and output image size.\n    aspect_ratio = (x_max - x_min) / (y_max - y_min)\n    img_width, img_height = 1920, int(1920 / aspect_ratio)\n\n    def sim_to_pixel(x, y):\n        \"\"\"Map simulation coordinates (mm) to pixel coordinates.\"\"\"\n        col = int((x - x_min) / (x_max - x_min) * img_width)\n        row = img_height - int((y - y_min) / (y_max - y_min) * img_height)\n        return col, row\n\n    # Precompute pixel trajectories and segments for each animal.\n    pixel_trajs = []\n    segments_list = []  # List of lists of (start, end) indices for each animal\n    for traj in result[\"trajectories\"]:\n        xs = np.array(traj[\"x\"])\n        ys = np.array(traj[\"y\"])\n        if wraparound:\n            xs_wrapped = wrap_coordinates(xs, x_min, x_max)\n            ys_wrapped = wrap_coordinates(ys, y_min, y_max)\n        else:\n            xs_wrapped, ys_wrapped = xs, ys\n        pts = [sim_to_pixel(x, y) for x, y in zip(xs_wrapped, ys_wrapped)]\n        pixel_trajs.append(pts)\n        if wraparound:\n            segs = segment_trajectory_with_indices(\n                xs_wrapped, ys_wrapped, x_min, x_max, y_min, y_max\n            )\n        else:\n            segs = [(0, len(pts))]\n        segments_list.append(segs)\n\n    # Cache: create a background image to accumulate trajectory tracks.\n    track_img = np.ones((img_height, img_width, 3), dtype=np.uint8) * 255\n    # For each animal, track the last drawn index per segment.\n    # We store a list (one per animal) of lists (one per segment) with the last drawn index.\n    last_drawn = []\n    for segs in segments_list:\n        last_drawn.append(\n            [s[0] for s in segs]\n        )  # initialize at each segment's start\n\n    # Get colors for each trajectory.\n    cmap = plt.cm.get_cmap(\"rainbow\", len(result[\"trajectories\"]))\n    colors = [\n        tuple(int(255 * c) for c in cmap(i)[:3][::-1])\n        for i in range(len(result[\"trajectories\"]))\n    ]\n\n    # Set up video writer.\n    fourcc = cv2.VideoWriter_fourcc(*\"mp4v\")\n    writer = cv2.VideoWriter(output_file, fourcc, fps, (img_width, img_height))\n\n    total_frames = len(result[\"trajectories\"][0][\"x\"])\n    frames = range(0, total_frames, frame_skip)\n\n    # Animation loop.\n    for frame in tqdm(frames, disable=not progress):\n        # Update cached track image: for each animal and each segment, add new line segments.\n        for a, pts in enumerate(pixel_trajs):\n            segs = segments_list[a]\n            for s_idx, (start, end) in enumerate(segs):\n                # Only update if the current frame is within this segment.\n                if frame &gt; start:\n                    # Determine segment endpoint to draw.\n                    seg_end = min(end, frame)\n                    # Only draw if new points exist.\n                    if seg_end - last_drawn[a][s_idx] &gt;= 1:\n                        for k in range(last_drawn[a][s_idx], seg_end - 1):\n                            cv2.line(\n                                track_img,\n                                pts[k],\n                                pts[k + 1],\n                                colors[a],\n                                thickness=1,\n                                lineType=cv2.LINE_AA,\n                            )\n                        last_drawn[a][s_idx] = seg_end\n\n        # Start with a copy of the cached track background.\n        frame_img = track_img.copy()\n\n        # Draw current animal markers (ellipse and sensor markers).\n        for traj_idx, traj in enumerate(result[\"trajectories\"]):\n            if frame &lt; 1:\n                continue\n            cur_idx = frame - 1\n            # For wraparound, use wrapped coordinates.\n            if wraparound:\n                cur_x = wrap_coordinates(\n                    np.array([traj[\"x\"][cur_idx]]), x_min, x_max\n                )[0]\n                cur_y = wrap_coordinates(\n                    np.array([traj[\"y\"][cur_idx]]), y_min, y_max\n                )[0]\n            else:\n                cur_x = traj[\"x\"][cur_idx]\n                cur_y = traj[\"y\"][cur_idx]\n            center = sim_to_pixel(cur_x, cur_y)\n            cur_heading = traj[\"heading\"][cur_idx]\n            angle_deg = -math.degrees(cur_heading)\n            cv2.ellipse(\n                frame_img,\n                center,\n                (20, 10),\n                angle_deg,\n                0,\n                360,\n                colors[traj_idx],\n                thickness=1,\n                lineType=cv2.LINE_AA,\n            )\n\n            # Compute antenna positions.\n            left_dx = cfg.antenna_left_offset[0] * math.cos(\n                cur_heading\n            ) - cfg.antenna_left_offset[1] * math.sin(cur_heading)\n            left_dy = cfg.antenna_left_offset[0] * math.sin(\n                cur_heading\n            ) + cfg.antenna_left_offset[1] * math.cos(cur_heading)\n            right_dx = cfg.antenna_right_offset[0] * math.cos(\n                cur_heading\n            ) - cfg.antenna_right_offset[1] * math.sin(cur_heading)\n            right_dy = cfg.antenna_right_offset[0] * math.sin(\n                cur_heading\n            ) + cfg.antenna_right_offset[1] * math.cos(cur_heading)\n            left_x = cur_x + left_dx\n            left_y = cur_y + left_dy\n            right_x = cur_x + right_dx\n            right_y = cur_y + right_dy\n            left_pt = sim_to_pixel(left_x, left_y)\n            right_pt = sim_to_pixel(right_x, right_y)\n            odor_left = traj[\"odor_left\"][cur_idx]\n            odor_right = traj[\"odor_right\"][cur_idx]\n            scale = 10\n            radius_left = max(3, int(scale * np.log1p(odor_left)))\n            radius_right = max(3, int(scale * np.log1p(odor_right)))\n            cv2.circle(\n                frame_img,\n                left_pt,\n                radius_left,\n                (255, 0, 0),\n                thickness=-1,\n                lineType=cv2.LINE_AA,\n            )\n            cv2.circle(\n                frame_img,\n                right_pt,\n                radius_right,\n                (0, 0, 255),\n                thickness=-1,\n                lineType=cv2.LINE_AA,\n            )\n\n        # Draw time information.\n        t_seconds = frame / cfg.fps\n        hours = int(t_seconds // 3600)\n        minutes = int((t_seconds % 3600) // 60)\n        seconds = t_seconds % 60\n        time_str = f\"{hours:02d}:{minutes:02d}:{seconds:05.2f}\"\n        cv2.putText(\n            frame_img,\n            f\"Time: {time_str}\",\n            (10, img_height - 20),\n            cv2.FONT_HERSHEY_SIMPLEX,\n            0.9,\n            (50, 50, 50),\n            thickness=2,\n            lineType=cv2.LINE_AA,\n        )\n\n        if display:\n            cv2.imshow(\"Simulation Animation\", frame_img)\n            if cv2.waitKey(int(1000 / fps)) &amp; 0xFF == ord(\"q\"):\n                break\n\n        writer.write(frame_img)\n\n    writer.release()\n    if display:\n        cv2.destroyAllWindows()\n    logger.info(f\"OpenCV animation saved to {output_file}\")\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.VisualizationPipeline.animate_enhanced_trajectory_opencv_old","title":"<code>animate_enhanced_trajectory_opencv_old(sim_index=0, fps=60, frame_skip=5, wraparound=False, output_file='animation.mp4', display=False, progress=True)</code>","text":"<p>OpenCV-based animation (legacy version).</p> <p>Animates trajectories for all animals with ellipse representations and odor sensor markers.</p> <p>Parameters:</p> Name Type Description Default <code>sim_index</code> <code>int</code> <p>Index of the simulation replicate.</p> <code>0</code> <code>fps</code> <code>int</code> <p>Frames per second for the output video.</p> <code>60</code> <code>frame_skip</code> <code>int</code> <p>Process every Nth frame.</p> <code>5</code> <code>wraparound</code> <code>bool</code> <p>If True, wrap and segment trajectories to avoid spurious connecting lines.</p> <code>False</code> <code>output_file</code> <code>str</code> <p>Path to the output video file.</p> <code>'animation.mp4'</code> <code>display</code> <code>bool</code> <p>If True, display the animation in an OpenCV window.</p> <code>False</code> <code>progress</code> <code>bool</code> <p>If True, display a progress bar.</p> <code>True</code> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def animate_enhanced_trajectory_opencv_old(\n    self,\n    sim_index: int = 0,\n    fps: int = 60,\n    frame_skip: int = 5,\n    wraparound: bool = False,\n    output_file: str = \"animation.mp4\",\n    display: bool = False,\n    progress: bool = True,\n) -&gt; None:\n    \"\"\"\n    OpenCV-based animation (legacy version).\n\n    Animates trajectories for all animals with ellipse representations and odor sensor markers.\n\n    Args:\n        sim_index (int): Index of the simulation replicate.\n        fps (int): Frames per second for the output video.\n        frame_skip (int): Process every Nth frame.\n        wraparound (bool): If True, wrap and segment trajectories to avoid spurious connecting lines.\n        output_file (str): Path to the output video file.\n        display (bool): If True, display the animation in an OpenCV window.\n        progress (bool): If True, display a progress bar.\n    \"\"\"\n    result = self.sim_results[sim_index]\n    cfg = self.config\n    x_min, x_max = cfg.grid_x_min, cfg.grid_x_max\n    y_min, y_max = cfg.grid_y_min, cfg.grid_y_max\n\n    # get grid aspect ratio\n    aspect_ratio = (x_max - x_min) / (y_max - y_min)\n\n    # Set a higher resolution (e.g., 1920x1080).\n    img_width, img_height = 1920, int(1920 / aspect_ratio)\n\n    def sim_to_pixel(x, y):\n        # Map simulation coordinates (x, y) to pixel coordinates (col, row).\n        col = int((x - x_min) / (x_max - x_min) * img_width)\n        row = img_height - int((y - y_min) / (y_max - y_min) * img_height)\n        return col, row\n\n    # Generate distinct colors for each trajectory (BGR for OpenCV)\n    cmap = plt.cm.get_cmap(\"rainbow\", len(result[\"trajectories\"]))\n    colors = [\n        tuple(int(255 * c) for c in cmap(i)[:3][::-1])\n        for i in range(len(result[\"trajectories\"]))\n    ]\n\n    # Pre-compute segmentation indices if wraparound is enabled.\n    seg_indices = []\n    if wraparound:\n        for traj in result[\"trajectories\"]:\n            x_arr = np.array(traj[\"x\"])\n            y_arr = np.array(traj[\"y\"])\n            x_wrapped = wrap_coordinates(x_arr, x_min, x_max)\n            y_wrapped = wrap_coordinates(y_arr, y_min, y_max)\n            seg_idx = segment_trajectory_with_indices(\n                x_wrapped, y_wrapped, x_min, x_max, y_min, y_max\n            )\n            seg_indices.append(seg_idx)\n    else:\n        seg_indices = [[(0, len(traj[\"x\"]))] for traj in result[\"trajectories\"]]\n\n    # Prepare the VideoWriter.\n    fourcc = cv2.VideoWriter_fourcc(*\"mp4v\")\n    fps = int(fps)\n    writer = cv2.VideoWriter(output_file, fourcc, fps, (img_width, img_height))\n\n    total_frames = len(result[\"trajectories\"][0][\"x\"])\n    frames = range(0, total_frames, frame_skip)\n\n    # Parameters for drawing the animal's ellipse.\n    # Define ellipse axes in pixels (half-lengths).\n    ellipse_axes = (20, 10)  # Adjust for a higher resolution display.\n\n    # For time display, compute simulation time from frame index.\n    def format_time(frame_index: int) -&gt; str:\n        t_seconds = frame_index / cfg.fps\n        hours = int(t_seconds // 3600)\n        minutes = int((t_seconds % 3600) // 60)\n        seconds = t_seconds % 60\n        return f\"{hours:02d}:{minutes:02d}:{seconds:05.2f}\"\n\n    for frame in tqdm(frames, disable=not progress):\n        # Create a blank white image.\n        img = np.ones((img_height, img_width, 3), dtype=np.uint8) * 255\n\n        # Draw trajectories (with thin lines).\n        for traj_idx, traj in enumerate(result[\"trajectories\"]):\n            x = np.array(traj[\"x\"])\n            y = np.array(traj[\"y\"])\n            if wraparound:\n                x = wrap_coordinates(x, x_min, x_max)\n                y = wrap_coordinates(y, y_min, y_max)\n            segs = seg_indices[traj_idx]\n            for start, end in segs:\n                if frame &gt; start and (end - start) &gt; 1:\n                    seg_end = min(end, frame)\n                    pts = np.array(\n                        [\n                            sim_to_pixel(xx, yy)\n                            for xx, yy in zip(x[start:seg_end], y[start:seg_end])\n                        ],\n                        dtype=np.int32,\n                    )\n                    if pts.shape[0] &gt;= 2:\n                        cv2.polylines(\n                            img,\n                            [pts],\n                            isClosed=False,\n                            color=colors[traj_idx],\n                            thickness=1,\n                            lineType=cv2.LINE_AA,\n                        )\n\n        # Draw each animal as an ellipse and sensor markers.\n        for traj in result[\"trajectories\"]:\n            if frame &lt; 1:\n                continue\n            cur_idx = frame - 1\n            cur_x = traj[\"x\"][cur_idx]\n            cur_y = traj[\"y\"][cur_idx]\n            if wraparound:\n                cur_x = wrap_coordinates(np.array([cur_x]), x_min, x_max)[0]\n                cur_y = wrap_coordinates(np.array([cur_y]), y_min, y_max)[0]\n            center = sim_to_pixel(cur_x, cur_y)\n            cur_heading = traj[\"heading\"][cur_idx]\n            # OpenCV's ellipse function expects the angle in degrees (clockwise, so we use negative).\n            angle_deg = -math.degrees(cur_heading)\n            cv2.ellipse(\n                img,\n                center,\n                ellipse_axes,\n                angle_deg,\n                0,\n                360,\n                colors[result[\"trajectories\"].index(traj)],\n                thickness=1,\n                lineType=cv2.LINE_AA,\n            )\n\n            # Draw sensor markers as circles.\n            left_dx = cfg.antenna_left_offset[0] * math.cos(\n                cur_heading\n            ) - cfg.antenna_left_offset[1] * math.sin(cur_heading)\n            left_dy = cfg.antenna_left_offset[0] * math.sin(\n                cur_heading\n            ) + cfg.antenna_left_offset[1] * math.cos(cur_heading)\n            right_dx = cfg.antenna_right_offset[0] * math.cos(\n                cur_heading\n            ) - cfg.antenna_right_offset[1] * math.sin(cur_heading)\n            right_dy = cfg.antenna_right_offset[0] * math.sin(\n                cur_heading\n            ) + cfg.antenna_right_offset[1] * math.cos(cur_heading)\n            left_x = cur_x + left_dx\n            left_y = cur_y + left_dy\n            right_x = cur_x + right_dx\n            right_y = cur_y + right_dy\n            left_center = sim_to_pixel(left_x, left_y)\n            right_center = sim_to_pixel(right_x, right_y)\n            odor_left = traj[\"odor_left\"][cur_idx]\n            odor_right = traj[\"odor_right\"][cur_idx]\n            # Scale marker radius by odor intensity.\n            scale = 10\n            radius_left = max(3, int(scale * np.log1p(odor_left)))\n            radius_right = max(3, int(scale * np.log1p(odor_right)))\n            cv2.circle(\n                img,\n                left_center,\n                radius_left,\n                color=(255, 0, 0),\n                thickness=-1,\n                lineType=cv2.LINE_AA,\n            )\n            cv2.circle(\n                img,\n                right_center,\n                radius_right,\n                color=(0, 0, 255),\n                thickness=-1,\n                lineType=cv2.LINE_AA,\n            )\n\n        # Draw time information.\n        time_str = format_time(frame)\n        cv2.putText(\n            img,\n            f\"Time: {time_str}\",\n            (10, img_height - 20),\n            cv2.FONT_HERSHEY_SIMPLEX,\n            0.9,\n            (50, 50, 50),\n            thickness=2,\n            lineType=cv2.LINE_AA,\n        )\n\n        if display:\n            cv2.imshow(\"Simulation Animation\", img)\n            if cv2.waitKey(interval) &amp; 0xFF == ord(\"q\"):\n                break\n\n        writer.write(img)\n\n    writer.release()\n    if display:\n        cv2.destroyAllWindows()\n    logger.info(f\"OpenCV animation saved to {output_file}\")\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.VisualizationPipeline.plot_final_odor_grid","title":"<code>plot_final_odor_grid(sim_index=0, downsample_factor=1, show=True, save_path=None)</code>","text":"<p>Plot the final odor grid as a heatmap.</p> <p>Parameters:</p> Name Type Description Default <code>sim_index</code> <code>int</code> <p>Index of the simulation replicate. Defaults to 0.</p> <code>0</code> <code>downsample_factor</code> <code>int</code> <p>Factor by which to downsample the grid for plotting. Defaults to 1.</p> <code>1</code> <code>show</code> <code>bool</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <code>save_path</code> <code>str</code> <p>Path to save the plot image. Defaults to None.</p> <code>None</code> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def plot_final_odor_grid(\n    self,\n    sim_index: int = 0,\n    downsample_factor: int = 1,\n    show: bool = True,\n    save_path: str = None,\n) -&gt; None:\n    \"\"\"\n    Plot the final odor grid as a heatmap.\n\n    Args:\n        sim_index (int): Index of the simulation replicate. Defaults to 0.\n        downsample_factor (int): Factor by which to downsample the grid for plotting. Defaults to 1.\n        show (bool): Whether to display the plot. Defaults to True.\n        save_path (str, optional): Path to save the plot image. Defaults to None.\n    \"\"\"\n    result = self.sim_results[sim_index]\n    odor_grid = result[\"final_odor_grid\"]\n    if downsample_factor &gt; 1:\n        odor_grid = odor_grid[::downsample_factor, ::downsample_factor]\n        extent = [\n            self.config.grid_x_min,\n            self.config.grid_x_max,\n            self.config.grid_y_min,\n            self.config.grid_y_max,\n        ]\n    else:\n        extent = [\n            self.config.grid_x_min,\n            self.config.grid_x_max,\n            self.config.grid_y_min,\n            self.config.grid_y_max,\n        ]\n    fig, ax = plt.subplots(figsize=(8, 8))\n    im = ax.imshow(odor_grid, origin=\"lower\", extent=extent, cmap=\"viridis\")\n    ax.set_title(\"Final Odor Grid\")\n    ax.set_xlabel(\"x (mm)\")\n    ax.set_ylabel(\"y (mm)\")\n    ax.set_aspect(\"equal\")\n    fig.colorbar(im, ax=ax, label=\"Odor Intensity\")\n    if save_path:\n        plt.savefig(save_path, dpi=150)\n    if show:\n        plt.show()\n    plt.close(fig)\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.VisualizationPipeline.plot_odor_time_series","title":"<code>plot_odor_time_series(sim_index=0, show=True, save_path=None)</code>","text":"<p>Plot time series of odor intensity at the antennae for all animals.</p> <p>Parameters:</p> Name Type Description Default <code>sim_index</code> <code>int</code> <p>Index of the simulation replicate. Defaults to 0.</p> <code>0</code> <code>show</code> <code>bool</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <code>save_path</code> <code>str</code> <p>Path to save the plot image. Defaults to None.</p> <code>None</code> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def plot_odor_time_series(\n    self, sim_index: int = 0, show: bool = True, save_path: str = None\n) -&gt; None:\n    \"\"\"\n    Plot time series of odor intensity at the antennae for all animals.\n\n    Args:\n        sim_index (int): Index of the simulation replicate. Defaults to 0.\n        show (bool): Whether to display the plot. Defaults to True.\n        save_path (str, optional): Path to save the plot image. Defaults to None.\n    \"\"\"\n    result = self.sim_results[sim_index]\n    fig, ax = plt.subplots(figsize=(10, 4))\n    for idx, traj in enumerate(result[\"trajectories\"]):\n        ax.plot(traj[\"odor_left\"], label=f\"Animal {idx+1} Left\", lw=2)\n        ax.plot(\n            traj[\"odor_right\"], label=f\"Animal {idx+1} Right\", lw=2, linestyle=\"--\"\n        )\n    ax.set_xlabel(\"Frame\")\n    ax.set_ylabel(\"Odor Intensity\")\n    ax.set_title(\"Odor Time Series at Antennae\")\n    ax.legend(loc=\"upper right\")\n    if save_path:\n        plt.savefig(save_path, dpi=150)\n    if show:\n        plt.show()\n    plt.close(fig)\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.VisualizationPipeline.plot_trajectories_with_odor","title":"<code>plot_trajectories_with_odor(sim_index=0, show=True, save_path=None, wraparound=False)</code>","text":"<p>Plot all animals' trajectories colored by average odor intensity.</p> <p>Parameters:</p> Name Type Description Default <code>sim_index</code> <code>int</code> <p>Index of the simulation replicate to plot. Defaults to 0.</p> <code>0</code> <code>show</code> <code>bool</code> <p>Whether to display the plot. Defaults to True.</p> <code>True</code> <code>save_path</code> <code>str</code> <p>Path to save the plot image. Defaults to None.</p> <code>None</code> <code>wraparound</code> <code>bool</code> <p>If True, segments trajectories to handle periodic boundaries. Defaults to False.</p> <code>False</code> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def plot_trajectories_with_odor(\n    self,\n    sim_index: int = 0,\n    show: bool = True,\n    save_path: str = None,\n    wraparound: bool = False,\n) -&gt; None:\n    \"\"\"\n    Plot all animals' trajectories colored by average odor intensity.\n\n    Args:\n        sim_index (int): Index of the simulation replicate to plot. Defaults to 0.\n        show (bool): Whether to display the plot. Defaults to True.\n        save_path (str, optional): Path to save the plot image. Defaults to None.\n        wraparound (bool): If True, segments trajectories to handle periodic boundaries. Defaults to False.\n    \"\"\"\n    result = self.sim_results[sim_index]\n    fig, ax = plt.subplots(figsize=(8, 8))\n    colors = plt.cm.tab10(np.linspace(0, 1, len(result[\"trajectories\"])))\n\n    for idx, traj in enumerate(result[\"trajectories\"]):\n        x = np.array(traj[\"x\"])\n        y = np.array(traj[\"y\"])\n\n        if wraparound:\n            x_wrapped = wrap_coordinates(\n                x, self.config.grid_x_min, self.config.grid_x_max\n            )\n            y_wrapped = wrap_coordinates(\n                y, self.config.grid_y_min, self.config.grid_y_max\n            )\n            segments_idx = segment_trajectory_with_indices(\n                x_wrapped,\n                y_wrapped,\n                self.config.grid_x_min,\n                self.config.grid_x_max,\n                self.config.grid_y_min,\n                self.config.grid_y_max,\n            )\n        else:\n            segments_idx = [(0, len(x))]\n            x_wrapped = x\n            y_wrapped = y\n\n        avg_odor = (\n            np.array(traj[\"odor_left\"]) + np.array(traj[\"odor_right\"])\n        ) / 2.0\n\n        for start, end in segments_idx:\n            if end - start &lt; 2:\n                continue\n            segment = np.column_stack((x_wrapped[start:end], y_wrapped[start:end]))\n            lc = LineCollection(\n                [segment],\n                cmap=\"viridis\",\n                norm=plt.Normalize(vmin=avg_odor.min(), vmax=avg_odor.max()),\n            )\n            lc.set_array(avg_odor[start : end - 1])\n            lc.set_linewidth(0.5)\n            ax.add_collection(lc)\n\n    ax.set_xlim(self.config.grid_x_min, self.config.grid_x_max)\n    ax.set_ylim(self.config.grid_y_min, self.config.grid_y_max)\n    ax.set_title(\"Fly Trajectories Colored by Average Odor\")\n    ax.set_xlabel(\"x (mm)\")\n    ax.set_ylabel(\"y (mm)\")\n    ax.set_aspect(\"equal\")\n    fig.colorbar(lc, ax=ax, label=\"Average Odor Intensity\")\n    if save_path:\n        plt.savefig(save_path, dpi=150)\n    if show:\n        plt.show()\n    plt.close(fig)\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.segment_trajectory_with_indices","title":"<code>segment_trajectory_with_indices(x, y, x_min, x_max, y_min, y_max, threshold=None)</code>","text":"<p>Segment a trajectory (x, y) into continuous pieces by detecting jumps.</p> <p>This is useful for plotting trajectories in periodic (wraparound) arenas, preventing lines from being drawn across the entire arena when an animal wraps around.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>1D array of x-coordinates.</p> required <code>y</code> <code>ndarray</code> <p>1D array of y-coordinates.</p> required <code>x_min</code> <code>float</code> <p>Minimum x boundary.</p> required <code>x_max</code> <code>float</code> <p>Maximum x boundary.</p> required <code>y_min</code> <code>float</code> <p>Minimum y boundary.</p> required <code>y_max</code> <code>float</code> <p>Maximum y boundary.</p> required <code>threshold</code> <code>Tuple[float, float]</code> <p>(tx, ty) thresholds for detecting jumps.                                        If None, defaults to half the domain width/height.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Tuple[int, int]]</code> <p>List[Tuple[int, int]]: List of (start_idx, end_idx) indices for each continuous segment.</p> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def segment_trajectory_with_indices(\n    x: np.ndarray,\n    y: np.ndarray,\n    x_min: float,\n    x_max: float,\n    y_min: float,\n    y_max: float,\n    threshold: Tuple[float, float] = None,\n) -&gt; List[Tuple[int, int]]:\n    \"\"\"\n    Segment a trajectory (x, y) into continuous pieces by detecting jumps.\n\n    This is useful for plotting trajectories in periodic (wraparound) arenas,\n    preventing lines from being drawn across the entire arena when an animal wraps around.\n\n    Args:\n        x (np.ndarray): 1D array of x-coordinates.\n        y (np.ndarray): 1D array of y-coordinates.\n        x_min (float): Minimum x boundary.\n        x_max (float): Maximum x boundary.\n        y_min (float): Minimum y boundary.\n        y_max (float): Maximum y boundary.\n        threshold (Tuple[float, float], optional): (tx, ty) thresholds for detecting jumps.\n                                                   If None, defaults to half the domain width/height.\n\n    Returns:\n        List[Tuple[int, int]]: List of (start_idx, end_idx) indices for each continuous segment.\n    \"\"\"\n    if threshold is None:\n        threshold = ((x_max - x_min) / 2.0, (y_max - y_min) / 2.0)\n    thresh_x, thresh_y = threshold\n\n    segments = []\n    start = 0\n    for i in range(1, len(x)):\n        if abs(x[i] - x[i - 1]) &gt; thresh_x or abs(y[i] - y[i - 1]) &gt; thresh_y:\n            segments.append((start, i))\n            start = i\n    segments.append((start, len(x)))\n    return segments\n</code></pre>"},{"location":"api/sim/visualization/#arthroscape.sim.visualization.wrap_coordinates","title":"<code>wrap_coordinates(arr, min_val, max_val)</code>","text":"<p>Wrap an array of coordinates into the interval [min_val, max_val).</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>Array of coordinates.</p> required <code>min_val</code> <code>float</code> <p>Minimum boundary value.</p> required <code>max_val</code> <code>float</code> <p>Maximum boundary value.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Wrapped coordinates.</p> Source code in <code>arthroscape/sim/visualization.py</code> <pre><code>def wrap_coordinates(arr: np.ndarray, min_val: float, max_val: float) -&gt; np.ndarray:\n    \"\"\"\n    Wrap an array of coordinates into the interval [min_val, max_val).\n\n    Args:\n        arr (np.ndarray): Array of coordinates.\n        min_val (float): Minimum boundary value.\n        max_val (float): Maximum boundary value.\n\n    Returns:\n        np.ndarray: Wrapped coordinates.\n    \"\"\"\n    width = max_val - min_val\n    return ((arr - min_val) % width) + min_val\n</code></pre>"},{"location":"how-to/data_analysis/","title":"Analyzing Simulation Data","text":"<p>ArthroScape saves simulation results in HDF5 format, which is efficient for large datasets. This guide explains how to load and analyze this data.</p>"},{"location":"how-to/data_analysis/#loading-results","title":"Loading Results","text":"<p>You can use the <code>h5py</code> library or ArthroScape's built-in loader (if available, otherwise standard <code>h5py</code> is recommended).</p> <pre><code>import h5py\nimport numpy as np\n\nfilename = \"path/to/results.h5\"\n\nwith h5py.File(filename, \"r\") as f:\n    # List all replicates\n    replicates = list(f.keys())\n    print(f\"Found {len(replicates)} replicates: {replicates}\")\n\n    # Access data for the first replicate\n    rep0 = f['replicate_0']\n\n    # Load datasets into NumPy arrays\n    x = rep0['x'][:]          # Shape: (time_steps, n_animals)\n    y = rep0['y'][:]\n    headings = rep0['headings'][:]\n    odor = rep0['odor'][:]    # Odor experienced by agents\n</code></pre>"},{"location":"how-to/data_analysis/#data-structure","title":"Data Structure","text":"<p>Each replicate group in the HDF5 file typically contains:</p> <ul> <li><code>x</code>: X-coordinates of agents over time.</li> <li><code>y</code>: Y-coordinates of agents over time.</li> <li><code>headings</code>: Heading angles (radians) over time.</li> <li><code>odor</code>: Odor concentration at the agent's location (or sensors).</li> <li><code>state</code>: Behavioral state (e.g., 0=stop, 1=walk).</li> <li><code>odor_grid_history</code>: (Optional) Snapshots of the full odor grid if <code>record_odor_history</code> was enabled.</li> </ul>"},{"location":"how-to/data_analysis/#example-analysis-success-rate","title":"Example Analysis: Success Rate","text":"<p>Let's calculate the fraction of agents that reached a target zone (e.g., within 10mm of the center).</p> <pre><code>target_radius = 10.0\nsuccess_count = 0\ntotal_animals = x.shape[1]\n\n# Check final positions\nfinal_x = x[-1, :]\nfinal_y = y[-1, :]\ndistances = np.sqrt(final_x**2 + final_y**2)\n\nsuccesses = distances &lt; target_radius\nsuccess_rate = np.sum(successes) / total_animals\n\nprint(f\"Success Rate: {success_rate * 100:.1f}%\")\n</code></pre>"},{"location":"how-to/data_analysis/#example-analysis-occupancy-map","title":"Example Analysis: Occupancy Map","text":"<p>Create a 2D histogram of agent positions to see where they spent the most time.</p> <pre><code>import matplotlib.pyplot as plt\n\n# Flatten all time points and animals\nall_x = x.flatten()\nall_y = y.flatten()\n\nplt.figure(figsize=(6, 6))\nplt.hist2d(all_x, all_y, bins=50, cmap='hot', range=[[-100, 100], [-100, 100]])\nplt.colorbar(label='Occupancy')\nplt.title(\"Agent Occupancy Map\")\nplt.show()\n</code></pre>"},{"location":"how-to/external_odor_sources/","title":"Using External Odor Sources","text":"<p>ArthroScape supports loading odor landscapes from external sources like images and videos. This enables you to:</p> <ul> <li>Use experimentally recorded odor plumes as simulation input.</li> <li>Create complex spatial patterns without code.</li> <li>Replay time-varying odor dynamics from video recordings.</li> </ul>"},{"location":"how-to/external_odor_sources/#static-images-as-odor-maps","title":"Static Images as Odor Maps","text":"<p>The simplest use case is loading a grayscale image where pixel brightness represents odor concentration.</p>"},{"location":"how-to/external_odor_sources/#basic-usage","title":"Basic Usage","text":"<pre><code>from arthroscape.sim.config import SimulationConfig\nfrom arthroscape.sim.arena import PeriodicSquareArena\nfrom arthroscape.sim.odor_sources import load_odor_from_image\n\n# Setup\nconfig = SimulationConfig()\narena = PeriodicSquareArena(\n    config.grid_x_min, config.grid_x_max,\n    config.grid_y_min, config.grid_y_max,\n    config.grid_resolution, config=config\n)\n\n# Load odor landscape from image\nsource = load_odor_from_image(\n    \"my_odor_gradient.png\",\n    arena,\n    scale=10.0,  # Scale pixel values (0-1) to odor units\n    invert=False  # Set True if dark = high odor\n)\n</code></pre>"},{"location":"how-to/external_odor_sources/#advanced-image-options","title":"Advanced Image Options","text":"<p>For more control, use the <code>ImageOdorSource</code> class directly:</p> <pre><code>from arthroscape.sim.odor_sources import ImageOdorSource\n\n# Custom normalization function\ndef log_normalize(img):\n    return np.log1p(img) / np.log1p(255)\n\nsource = ImageOdorSource(\n    \"plume_image.tiff\",\n    invert=True,            # Invert values\n    normalize_func=log_normalize,  # Custom normalization\n    channel=0               # Use only red channel (0=R, 1=G, 2=B)\n)\n\n# Apply to arena with different modes\nsource.apply_to_arena(arena, mode=\"replace\", scale=5.0, offset=0.1)\n</code></pre>"},{"location":"how-to/external_odor_sources/#application-modes","title":"Application Modes","text":"Mode Effect <code>\"replace\"</code> Overwrite the arena's odor grid entirely <code>\"add\"</code> Add image values to existing odor <code>\"multiply\"</code> Multiply existing odor by image values <code>\"max\"</code> Take element-wise maximum"},{"location":"how-to/external_odor_sources/#dynamic-video-as-odor-field","title":"Dynamic Video as Odor Field","text":"<p>For time-varying odor fields, use <code>VideoOdorSource</code> to stream video frames.</p>"},{"location":"how-to/external_odor_sources/#basic-video-usage","title":"Basic Video Usage","text":"<pre><code>from arthroscape.sim.odor_sources import VideoOdorSource\n\n# Load video\nvideo = VideoOdorSource(\n    \"plume_recording.mp4\",\n    loop=True,       # Loop when video ends\n    invert=False\n)\n\n# Apply first frame\nvideo.apply_to_arena(arena, scale=2.0)\n\n# In your simulation loop:\nfor frame in range(total_frames):\n    # Advance video and apply new frame\n    video.advance_frame()\n    video.apply_to_arena(arena, mode=\"replace\", scale=2.0)\n\n    # ... rest of simulation step ...\n</code></pre>"},{"location":"how-to/external_odor_sources/#video-synchronization","title":"Video Synchronization","text":"<p>Use <code>VideoOdorReleaseStrategy</code> for automatic frame synchronization:</p> <pre><code>from arthroscape.sim.odor_sources import VideoOdorReleaseStrategy\n\n# Create synchronized video strategy\nvideo_strategy = VideoOdorReleaseStrategy(\n    \"odor_plume.mp4\",\n    arena,\n    mode=\"replace\",\n    scale=5.0,\n    sync_mode=\"simulation_fps\",  # Map simulation time to video time\n    simulation_fps=60.0,\n    loop=True\n)\n\n# In simulation loop:\nfor sim_frame in range(config.total_frames):\n    video_strategy.update(arena, sim_frame)\n    # ... rest of simulation ...\n</code></pre>"},{"location":"how-to/external_odor_sources/#synchronization-modes","title":"Synchronization Modes","text":"Mode Description <code>\"one_to_one\"</code> Each simulation frame = one video frame <code>\"video_fps\"</code> Use video's native frame rate <code>\"simulation_fps\"</code> Map simulation time to video time (recommended)"},{"location":"how-to/external_odor_sources/#video-options","title":"Video Options","text":"<pre><code>video = VideoOdorSource(\n    \"recording.mp4\",\n    loop=True,          # Loop video\n    start_frame=100,    # Start at frame 100\n    end_frame=500,      # End at frame 500\n    frame_step=2,       # Use every 2nd frame\n    preload=True,       # Load all frames into RAM (faster, more memory)\n    channel=1           # Use green channel only\n)\n</code></pre>"},{"location":"how-to/external_odor_sources/#complete-example-image-agent-pheromone","title":"Complete Example: Image + Agent Pheromone","text":"<p>Combine a static background odor with agent-deposited pheromone:</p> <pre><code>from arthroscape.sim.config import SimulationConfig\nfrom arthroscape.sim.arena import PeriodicSquareArena\nfrom arthroscape.sim.behavior import DefaultBehavior\nfrom arthroscape.sim.odor_release import ConstantOdorRelease\nfrom arthroscape.sim.odor_sources import load_odor_from_image\nfrom arthroscape.sim.runner import run_simulations_vectorized\n\n# Configuration\nconfig = SimulationConfig(\n    T=300,\n    number_of_animals=5,\n    diffusion_coefficient=0.5,  # Enable diffusion\n    odor_decay_tau=60.0         # Odor decays over 60 seconds\n)\n\n# Create arena\narena = PeriodicSquareArena(\n    config.grid_x_min, config.grid_x_max,\n    config.grid_y_min, config.grid_y_max,\n    config.grid_resolution, config=config\n)\n\n# Load background odor from image\nload_odor_from_image(\"food_source.png\", arena, scale=2.0)\n\n# Agents also release pheromone\nodor_release = ConstantOdorRelease(config, deposit_amount=0.1)\n\n# Run simulation\nbehavior = DefaultBehavior()\nresults = run_simulations_vectorized(\n    config, behavior, arena, odor_release, n_replicates=1\n)\n</code></pre>"},{"location":"how-to/external_odor_sources/#complete-example-video-driven-simulation","title":"Complete Example: Video-Driven Simulation","text":"<p>Run agents in a dynamic, video-based odor environment:</p> <pre><code>from arthroscape.sim.config import SimulationConfig\nfrom arthroscape.sim.arena import PeriodicSquareArena\nfrom arthroscape.sim.behavior import DefaultBehavior\nfrom arthroscape.sim.odor_release import DefaultOdorRelease\nfrom arthroscape.sim.odor_sources import VideoOdorReleaseStrategy\nfrom arthroscape.sim.simulator import MultiAnimalSimulator\n\n# Configuration\nconfig = SimulationConfig(T=60, number_of_animals=10, fps=30)\n\n# Create arena\narena = PeriodicSquareArena(\n    config.grid_x_min, config.grid_x_max,\n    config.grid_y_min, config.grid_y_max,\n    config.grid_resolution, config=config\n)\n\n# Video-based dynamic odor\nvideo_strategy = VideoOdorReleaseStrategy(\n    \"turbulent_plume.mp4\",\n    arena,\n    scale=3.0,\n    sync_mode=\"simulation_fps\",\n    simulation_fps=config.fps,\n    loop=True\n)\n\n# No agent-based odor release\nodor_release = DefaultOdorRelease()\n\n# Create simulator\nsimulator = MultiAnimalSimulator(\n    config=config,\n    behavior=DefaultBehavior(),\n    arena=arena,\n    odor_release_strategy=odor_release\n)\n\n# Custom simulation loop with video updates\nfor frame in range(config.total_frames):\n    # Update odor from video BEFORE the simulation step\n    video_strategy.update(arena, frame)\n\n    # ... manual step logic or use simulator internals ...\n\n# Clean up\nvideo_strategy.video_source.close()\n</code></pre>"},{"location":"how-to/external_odor_sources/#utility-functions","title":"Utility Functions","text":""},{"location":"how-to/external_odor_sources/#create-simple-gradients","title":"Create Simple Gradients","text":"<p>For quick testing, use the built-in gradient generator:</p> <pre><code>from arthroscape.sim.odor_sources import create_gradient_odor_map\n\n# Horizontal gradient (left to right)\nhorizontal = create_gradient_odor_map(\n    (arena.ny, arena.nx),\n    direction=\"horizontal\",\n    min_val=0.0,\n    max_val=5.0\n)\narena.odor_grid = horizontal\n\n# Radial gradient (center = high)\nradial = create_gradient_odor_map(\n    (arena.ny, arena.nx),\n    direction=\"radial_inward\",\n    min_val=0.0,\n    max_val=10.0\n)\narena.odor_grid = radial\n</code></pre>"},{"location":"how-to/external_odor_sources/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li> <p>Image Resolution: Use images that roughly match your arena's grid resolution. Very high-resolution images will be downsampled.</p> </li> <li> <p>Video Performance: For long videos, set <code>preload=False</code> (default) to stream frames. Use <code>preload=True</code> only for short videos when you need maximum speed.</p> </li> <li> <p>Coordinate System: Images are loaded with the origin at the top-left. The arena's origin is at <code>(x_min, y_min)</code>. The image is automatically flipped if needed.</p> </li> <li> <p>Normalization: By default, pixel values are normalized to [0, 1]. Use <code>scale</code> to convert to your desired odor units.</p> </li> <li> <p>Combining Sources: You can layer multiple sources using <code>mode=\"add\"</code> or <code>mode=\"max\"</code>.</p> </li> </ol>"},{"location":"how-to/parallel_simulations/","title":"Running Simulations in Parallel","text":"<p>ArthroScape supports parallel execution of simulation replicates to speed up data collection.</p>"},{"location":"how-to/parallel_simulations/#using-the-cli","title":"Using the CLI","text":"<p>To run simulations in parallel using the command line, simply add the <code>--parallel</code> flag.</p> <pre><code>python -m arthroscape.sim.main --arena circular --replicates 10 --parallel\n</code></pre> <p>This will use all available CPU cores to run the 10 replicates concurrently.</p>"},{"location":"how-to/parallel_simulations/#using-the-python-api","title":"Using the Python API","text":"<p>When using the Python API, set the <code>parallel</code> argument to <code>True</code> in the runner functions.</p> <pre><code>from arthroscape.sim.runner import run_simulations_vectorized\n\nresults = run_simulations_vectorized(\n    config, \n    behavior, \n    arena, \n    odor_release, \n    n_replicates=20, \n    parallel=True\n)\n</code></pre>"},{"location":"how-to/parallel_simulations/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Vectorization vs. Parallelization: ArthroScape uses Numba for vectorization within a single simulation (handling multiple agents). Parallelization runs multiple replicates (independent simulations) at the same time. Using both is highly recommended for large-scale parameter sweeps.</li> <li>Memory Usage: Each parallel process requires its own memory. If you are simulating very large arenas or recording high-resolution odor history (<code>record_odor_history=True</code>), be mindful of your system's RAM.</li> <li>CPU Cores: By default, <code>joblib</code> (used internally) attempts to use all available cores.</li> </ul>"},{"location":"how-to/visualization/","title":"Visualizing Results","text":"<p>ArthroScape includes a visualization pipeline to help you inspect simulation outcomes.</p>"},{"location":"how-to/visualization/#the-visualization-pipeline","title":"The Visualization Pipeline","text":"<p>The <code>VisualizationPipeline</code> class in <code>arthroscape.sim.visualization</code> handles plotting. It takes the simulation results, configuration, and arena object as input.</p> <pre><code>from arthroscape.sim.visualization import VisualizationPipeline\n\n# Assuming you have 'results', 'config', and 'arena'\npipeline = VisualizationPipeline(results, config, arena)\n</code></pre>"},{"location":"how-to/visualization/#common-plots","title":"Common Plots","text":""},{"location":"how-to/visualization/#trajectories","title":"Trajectories","text":"<p>Plot the paths of all agents, overlaid on the final odor landscape.</p> <pre><code>pipeline.plot_trajectories_with_odor(\n    sim_index=0,        # Index of the replicate to plot\n    show=True,          # Display the plot\n    save_path=\"traj.png\" # Optional: save to file\n)\n</code></pre>"},{"location":"how-to/visualization/#odor-grid","title":"Odor Grid","text":"<p>Visualize the final state of the odor concentration grid.</p> <pre><code>pipeline.plot_final_odor_grid(\n    sim_index=0,\n    show=True\n)\n</code></pre>"},{"location":"how-to/visualization/#odor-time-series","title":"Odor Time Series","text":"<p>Plot the average odor concentration experienced by agents over time.</p> <pre><code>pipeline.plot_odor_time_series(\n    sim_index=0,\n    show=True\n)\n</code></pre>"},{"location":"how-to/visualization/#creating-animations","title":"Creating Animations","text":"<p>You can create a video animation of the simulation. This requires <code>opencv-python</code>.</p> <pre><code>pipeline.animate_enhanced_trajectory_opencv(\n    sim_index=0,\n    fps=60,\n    output_file=\"simulation_video.mp4\",\n    display=True\n)\n</code></pre>"},{"location":"how-to/visualization/#custom-plotting","title":"Custom Plotting","text":"<p>The simulation results are standard NumPy arrays, so you can also use Matplotlib directly.</p> <pre><code>import matplotlib.pyplot as plt\n\n# Access data for the first replicate\n# Shape: (time_steps, n_animals)\nx_coords = results[0]['x']\ny_coords = results[0]['y']\n\nplt.figure()\nplt.plot(x_coords, y_coords, alpha=0.5)\nplt.title(\"Agent Trajectories\")\nplt.xlabel(\"X (mm)\")\nplt.ylabel(\"Y (mm)\")\nplt.show()\n</code></pre>"},{"location":"tutorials/custom_arena/","title":"Customizing the Arena","text":"<p>ArthroScape allows you to simulate agents in various environments. This tutorial explains how to use existing arena types and how to create custom ones.</p>"},{"location":"tutorials/custom_arena/#using-built-in-arenas","title":"Using Built-in Arenas","text":"<p>ArthroScape comes with a few predefined arena types.</p>"},{"location":"tutorials/custom_arena/#periodic-square-arena","title":"Periodic Square Arena","text":"<p>This is a square arena with periodic boundary conditions (toroidal topology). Agents that exit one side re-enter from the opposite side.</p> <pre><code>from arthroscape.sim.config import SimulationConfig\nfrom arthroscape.sim.arena import PeriodicSquareArena\n\nconfig = SimulationConfig()\narena = PeriodicSquareArena(\n    x_min=-50, x_max=50,\n    y_min=-50, y_max=50,\n    resolution=0.1,\n    config=config\n)\n</code></pre>"},{"location":"tutorials/custom_arena/#circular-arena-with-annular-trail","title":"Circular Arena with Annular Trail","text":"<p>This helper function creates a circular arena with a specific odor trail.</p> <pre><code>from arthroscape.sim.arena import create_circular_arena_with_annular_trail\n\narena = create_circular_arena_with_annular_trail(\n    config,\n    arena_radius=100.0,\n    trail_radius=50.0,\n    trail_width=10.0,\n    trail_odor=1.0\n)\n</code></pre>"},{"location":"tutorials/custom_arena/#creating-a-custom-arena","title":"Creating a Custom Arena","text":"<p>To create a completely new arena, you can inherit from <code>GridArena</code> or <code>Arena</code>.</p>"},{"location":"tutorials/custom_arena/#example-rectangular-arena-with-obstacles","title":"Example: Rectangular Arena with Obstacles","text":"<p>Here is an example of how to create a rectangular arena with a central obstacle.</p> <pre><code>import numpy as np\nfrom arthroscape.sim.arena import GridArena\n\nclass ObstacleArena(GridArena):\n    def __init__(self, width, height, obstacle_radius, config):\n        # Define dimensions\n        x_min, x_max = -width/2, width/2\n        y_min, y_max = -height/2, height/2\n        resolution = config.grid_resolution\n\n        # Create wall mask (True = wall/obstacle)\n        ny = int(np.ceil((y_max - y_min) / resolution)) + 1\n        nx = int(np.ceil((x_max - x_min) / resolution)) + 1\n        wall_mask = np.zeros((ny, nx), dtype=bool)\n\n        # Add central circular obstacle\n        y_indices, x_indices = np.ogrid[:ny, :nx]\n        y_coords = y_min + y_indices * resolution\n        x_coords = x_min + x_indices * resolution\n        dist_sq = x_coords**2 + y_coords**2\n        wall_mask[dist_sq &lt; obstacle_radius**2] = True\n\n        # Initialize base class\n        super().__init__(x_min, x_max, y_min, y_max, resolution, wall_mask, config)\n\n# Usage\narena = ObstacleArena(width=100, height=100, obstacle_radius=20, config=config)\n</code></pre>"},{"location":"tutorials/custom_arena/#modifying-the-odor-landscape","title":"Modifying the Odor Landscape","text":"<p>You can manually set the initial odor grid of an arena.</p> <pre><code># Set a gradient\nfor i in range(arena.ny):\n    arena.odor_grid[i, :] = i / arena.ny\n</code></pre> <p>Remember that if you use <code>ConstantOdorRelease</code>, the odor grid will be updated dynamically during the simulation.</p>"},{"location":"tutorials/custom_behavior/","title":"Creating Custom Behaviors","text":"<p>ArthroScape is designed to be extensible. You can define your own behavioral algorithms to test different hypotheses about agent movement.</p>"},{"location":"tutorials/custom_behavior/#the-behavioralgorithm-class","title":"The <code>BehaviorAlgorithm</code> Class","text":"<p>All behaviors must inherit from the abstract base class <code>BehaviorAlgorithm</code> defined in <code>arthroscape.sim.behavior</code>.</p> <p>You need to implement two methods:</p> <ol> <li><code>update_state</code>: Determines if the agent should stop or walk.</li> <li><code>update_heading</code>: Determines the agent's new heading.</li> </ol>"},{"location":"tutorials/custom_behavior/#example-random-walker","title":"Example: Random Walker","text":"<p>Let's implement a simple random walker that ignores odor.</p> <pre><code>import numpy as np\nfrom arthroscape.sim.behavior import BehaviorAlgorithm\nfrom arthroscape.sim.config import SimulationConfig\n\nclass RandomWalker(BehaviorAlgorithm):\n    def update_state(self, prev_state: int, config: SimulationConfig, rng: np.random.Generator) -&gt; int:\n        # Simple state switching based on probabilities\n        if prev_state == 0: # Stopped\n            if rng.random() &lt; config.rate_stop_to_walk_per_frame:\n                return 1 # Start walking\n            else:\n                return 0 # Stay stopped\n        else: # Walking\n            if rng.random() &lt; config.rate_walk_to_stop_per_frame:\n                return 0 # Stop\n            else:\n                return 1 # Keep walking\n\n    def update_heading(self, prev_heading: float, odor_left: float, odor_right: float,\n                       at_wall: bool, config: SimulationConfig, rng: np.random.Generator) -&gt; float:\n        # Ignore odor, just add random noise (diffusion)\n        # If at wall, turn around randomly\n\n        if at_wall:\n            return rng.uniform(-np.pi, np.pi)\n\n        # Add rotational diffusion\n        noise = rng.normal(0, config.rotation_diffusion)\n\n        # Occasionally make a sharp turn\n        if rng.random() &lt; config.turn_rate_per_frame:\n            turn = config.turn_angle_sampler()\n            if rng.random() &lt; 0.5:\n                turn = -turn\n            return prev_heading + turn + noise\n\n        return prev_heading + noise\n</code></pre>"},{"location":"tutorials/custom_behavior/#using-your-custom-behavior","title":"Using Your Custom Behavior","text":"<p>Once defined, you can pass your new class to the simulation runner.</p> <pre><code>from arthroscape.sim.runner import run_simulations_vectorized\n\n# ... setup config and arena ...\n\nbehavior = RandomWalker()\n\nresults = run_simulations_vectorized(\n    config, \n    behavior, \n    arena, \n    odor_release, \n    n_replicates=1\n)\n</code></pre>"},{"location":"tutorials/custom_behavior/#advanced-odor-driven-behavior","title":"Advanced: Odor-Driven Behavior","text":"<p>To implement chemotaxis, use the <code>odor_left</code> and <code>odor_right</code> arguments in <code>update_heading</code>.</p> <pre><code>    def update_heading(self, prev_heading, odor_left, odor_right, at_wall, config, rng):\n        # ...\n\n        # Calculate contrast\n        contrast = (odor_left - odor_right) / (odor_left + odor_right + 1e-6)\n\n        # Turn towards higher concentration\n        turn_bias = contrast * config.asymmetry_factor\n\n        # ... apply turn_bias to heading ...\n</code></pre>"},{"location":"tutorials/getting_started/","title":"Getting Started with ArthroScape","text":"<p>This tutorial will guide you through running your first simulation with ArthroScape. You will learn how to run simulations using both the command-line interface (CLI) and the Python API.</p>"},{"location":"tutorials/getting_started/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have installed ArthroScape as described in the Installation guide.</p>"},{"location":"tutorials/getting_started/#running-a-simulation-via-cli","title":"Running a Simulation via CLI","text":"<p>The easiest way to start is using the provided CLI tool.</p> <ol> <li>Open your terminal.</li> <li> <p>Run a basic simulation:</p> <pre><code>python -m arthroscape.sim.main --arena circular --animals 5 --visualize\n</code></pre> <p>This command does the following: * Selects a <code>circular</code> arena. * Places <code>5</code> animals in the arena. * Enables visualization (<code>--visualize</code>), which will generate plots and animations after the simulation finishes.</p> </li> <li> <p>Check the output:</p> <p>By default, results are saved in <code>data/simulation/&lt;date&gt;/&lt;time&gt;_&lt;description&gt;/</code>. You should see a <code>results.h5</code> file and a <code>plots/</code> directory containing trajectories and odor grid visualizations.</p> </li> </ol>"},{"location":"tutorials/getting_started/#running-a-simulation-via-python","title":"Running a Simulation via Python","text":"<p>For more control, you can run simulations directly from a Python script.</p> <ol> <li>Create a new Python file (e.g., <code>my_simulation.py</code>).</li> <li> <p>Import the necessary modules:</p> <pre><code>from arthroscape.sim.config import SimulationConfig\nfrom arthroscape.sim.arena import create_circular_arena_with_annular_trail\nfrom arthroscape.sim.behavior import DefaultBehavior\nfrom arthroscape.sim.odor_release import ConstantOdorRelease\nfrom arthroscape.sim.runner import run_simulations_vectorized\nfrom arthroscape.sim.visualization import VisualizationPipeline\n</code></pre> </li> <li> <p>Configure the simulation:</p> <pre><code># Create a configuration object\nconfig = SimulationConfig(\n    T=300,              # 5 minutes\n    number_of_animals=10,\n    walking_speed=15.0\n)\n</code></pre> </li> <li> <p>Set up the environment:</p> <pre><code># Create an arena\narena = create_circular_arena_with_annular_trail(\n    config, \n    arena_radius=100.0, \n    trail_radius=60.0\n)\n\n# Define behavior and odor release\nbehavior = DefaultBehavior()\nodor_release = ConstantOdorRelease(config, deposit_amount=0.5)\n</code></pre> </li> <li> <p>Run the simulation:</p> <pre><code>print(\"Running simulation...\")\nresults = run_simulations_vectorized(\n    config, \n    behavior, \n    arena, \n    odor_release, \n    n_replicates=1\n)\nprint(\"Simulation complete!\")\n</code></pre> </li> <li> <p>Visualize the results:</p> <pre><code>pipeline = VisualizationPipeline(results, config, arena)\npipeline.plot_trajectories_with_odor(sim_index=0, show=True)\n</code></pre> </li> </ol>"},{"location":"tutorials/getting_started/#next-steps","title":"Next Steps","text":"<p>Now that you can run a basic simulation, try:</p> <ul> <li>Customizing the Arena to create different environments.</li> <li>Creating Custom Behaviors to test new algorithms.</li> </ul>"}]}